{
  "version": 3,
  "sources": ["../bundle-76pCT6/checked-fetch.js", "wrangler-modules-watch:wrangler:modules-watch", "../../../node_modules/wrangler/templates/modules-watch-stub.js", "../../../node_modules/wrangler/node_modules/mime/Mime.js", "../../../node_modules/wrangler/node_modules/mime/types/standard.js", "../../../node_modules/wrangler/node_modules/mime/types/other.js", "../../../node_modules/wrangler/node_modules/mime/index.js", "../../../node_modules/wrangler/node_modules/@cloudflare/kv-asset-handler/dist/types.js", "../../../node_modules/wrangler/node_modules/@cloudflare/kv-asset-handler/dist/index.js", "../bundle-76pCT6/middleware-loader.entry.ts", "../bundle-76pCT6/middleware-insertion-facade.js", "../bundle-2HsAiA/checked-fetch.js", "../pages-kK9EY1/wrangler-modules-watch:wrangler:modules-watch", "../../../node_modules/wrangler/templates/modules-watch-stub.js", "../../../functions/auth/home.ts", "../../../node_modules/@cloudflare/pages-plugin-cloudflare-access/api/index.ts", "../../../functions/auth/login.ts", "../../../functions/auth/logout.ts", "../../../node_modules/cookie/index.js", "../../../node_modules/@remix-run/server-runtime/dist/warnings.js", "../../../node_modules/@remix-run/server-runtime/dist/cookies.js", "../../../node_modules/@web3-storage/multipart-parser/esm/src/utils.js", "../../../node_modules/@web3-storage/multipart-parser/esm/src/search.js", "../../../node_modules/@web3-storage/multipart-parser/esm/src/index.js", "../../../node_modules/@remix-run/server-runtime/dist/formData.js", "../../../node_modules/@remix-run/router/history.ts", "../../../node_modules/@remix-run/router/utils.ts", "../../../node_modules/@remix-run/router/router.ts", "../../../node_modules/@remix-run/server-runtime/dist/mode.js", "../../../node_modules/@remix-run/server-runtime/dist/errors.js", "../../../node_modules/@remix-run/server-runtime/dist/responses.js", "../../../node_modules/@remix-run/server-runtime/dist/entry.js", "../../../node_modules/set-cookie-parser/lib/set-cookie.js", "../../../node_modules/@remix-run/server-runtime/dist/headers.js", "../../../node_modules/@remix-run/server-runtime/dist/invariant.js", "../../../node_modules/@remix-run/server-runtime/dist/routeMatching.js", "../../../node_modules/@remix-run/server-runtime/dist/data.js", "../../../node_modules/@remix-run/server-runtime/dist/routes.js", "../../../node_modules/@remix-run/server-runtime/dist/markup.js", "../../../node_modules/@remix-run/server-runtime/dist/serverHandoff.js", "../../../node_modules/@remix-run/server-runtime/dist/dev.js", "../../../node_modules/@remix-run/server-runtime/dist/server.js", "../../../node_modules/@remix-run/server-runtime/dist/sessions.js", "../../../node_modules/@remix-run/server-runtime/dist/sessions/cookieStorage.js", "../../../node_modules/@remix-run/server-runtime/dist/sessions/memoryStorage.js", "../../../node_modules/@remix-run/server-runtime/dist/upload/errors.js", "../../../node_modules/@remix-run/server-runtime/dist/upload/memoryUploadHandler.js", "../../../node_modules/@remix-run/server-runtime/dist/index.js", "../../../node_modules/@remix-run/cloudflare/dist/crypto.js", "../../../node_modules/@remix-run/cloudflare/dist/implementations.js", "../../../node_modules/@remix-run/cloudflare/dist/sessions/workersKVStorage.js", "../../../node_modules/@remix-run/cloudflare/dist/index.js", "../../../app/utils/session/session.ts", "../../../app/utils/checkAuthentication.ts", "../../../functions/auth/root.ts", "../../../functions/greet.ts", "../pages-kK9EY1/functionsRoutes-0.2765862793624314.mjs", "../bundle-2HsAiA/middleware-loader.entry.ts", "../bundle-2HsAiA/middleware-insertion-facade.js", "../../../node_modules/wrangler/templates/pages-template-worker.ts", "../../../node_modules/wrangler/node_modules/path-to-regexp/src/index.ts", "../../../node_modules/wrangler/templates/middleware/middleware-miniflare3-json-error.ts", "../../../node_modules/wrangler/templates/middleware/common.ts", "../../../node_modules/wrangler/templates/pages-dev-util.ts", "../pages-kK9EY1/<define:__ROUTES__>", "../../../node_modules/wrangler/templates/pages-dev-pipeline.ts", "../../../node_modules/wrangler/templates/middleware/middleware-miniflare3-json-error.ts", "../../../node_modules/wrangler/templates/middleware/middleware-serve-static-assets.ts", "wrangler-config:config:middleware/serve-static-assets", "../../../node_modules/wrangler/templates/middleware/common.ts"],
  "sourceRoot": "/home/runmy/Desktop/clarance/.wrangler/tmp/dev-G2O7oS",
  "sourcesContent": ["const urls = new Set();\n\nfunction checkURL(request, init) {\n\tconst url =\n\t\trequest instanceof URL\n\t\t\t? request\n\t\t\t: new URL(\n\t\t\t\t\t(typeof request === \"string\"\n\t\t\t\t\t\t? new Request(request, init)\n\t\t\t\t\t\t: request\n\t\t\t\t\t).url\n\t\t\t  );\n\tif (url.port && url.port !== \"443\" && url.protocol === \"https:\") {\n\t\tif (!urls.has(url.toString())) {\n\t\t\turls.add(url.toString());\n\t\t\tconsole.warn(\n\t\t\t\t`WARNING: known issue with \\`fetch()\\` requests to custom HTTPS ports in published Workers:\\n` +\n\t\t\t\t\t` - ${url.toString()} - the custom port will be ignored when the Worker is published using the \\`wrangler deploy\\` command.\\n`\n\t\t\t);\n\t\t}\n\t}\n}\n\nglobalThis.fetch = new Proxy(globalThis.fetch, {\n\tapply(target, thisArg, argArray) {\n\t\tconst [request, init] = argArray;\n\t\tcheckURL(request, init);\n\t\treturn Reflect.apply(target, thisArg, argArray);\n\t},\n});\n", "", "// `esbuild` doesn't support returning `watch*` options from `onStart()`\n// plugin callbacks. Instead, we define an empty virtual module that is\n// imported by this injected file. Importing the module registers watchers.\nimport \"wrangler:modules-watch\";\n", "'use strict';\n\n/**\n * @param typeMap [Object] Map of MIME type -> Array[extensions]\n * @param ...\n */\nfunction Mime() {\n  this._types = Object.create(null);\n  this._extensions = Object.create(null);\n\n  for (let i = 0; i < arguments.length; i++) {\n    this.define(arguments[i]);\n  }\n\n  this.define = this.define.bind(this);\n  this.getType = this.getType.bind(this);\n  this.getExtension = this.getExtension.bind(this);\n}\n\n/**\n * Define mimetype -> extension mappings.  Each key is a mime-type that maps\n * to an array of extensions associated with the type.  The first extension is\n * used as the default extension for the type.\n *\n * e.g. mime.define({'audio/ogg', ['oga', 'ogg', 'spx']});\n *\n * If a type declares an extension that has already been defined, an error will\n * be thrown.  To suppress this error and force the extension to be associated\n * with the new type, pass `force`=true.  Alternatively, you may prefix the\n * extension with \"*\" to map the type to extension, without mapping the\n * extension to the type.\n *\n * e.g. mime.define({'audio/wav', ['wav']}, {'audio/x-wav', ['*wav']});\n *\n *\n * @param map (Object) type definitions\n * @param force (Boolean) if true, force overriding of existing definitions\n */\nMime.prototype.define = function(typeMap, force) {\n  for (let type in typeMap) {\n    let extensions = typeMap[type].map(function(t) {\n      return t.toLowerCase();\n    });\n    type = type.toLowerCase();\n\n    for (let i = 0; i < extensions.length; i++) {\n      const ext = extensions[i];\n\n      // '*' prefix = not the preferred type for this extension.  So fixup the\n      // extension, and skip it.\n      if (ext[0] === '*') {\n        continue;\n      }\n\n      if (!force && (ext in this._types)) {\n        throw new Error(\n          'Attempt to change mapping for \"' + ext +\n          '\" extension from \"' + this._types[ext] + '\" to \"' + type +\n          '\". Pass `force=true` to allow this, otherwise remove \"' + ext +\n          '\" from the list of extensions for \"' + type + '\".'\n        );\n      }\n\n      this._types[ext] = type;\n    }\n\n    // Use first extension as default\n    if (force || !this._extensions[type]) {\n      const ext = extensions[0];\n      this._extensions[type] = (ext[0] !== '*') ? ext : ext.substr(1);\n    }\n  }\n};\n\n/**\n * Lookup a mime type based on extension\n */\nMime.prototype.getType = function(path) {\n  path = String(path);\n  let last = path.replace(/^.*[/\\\\]/, '').toLowerCase();\n  let ext = last.replace(/^.*\\./, '').toLowerCase();\n\n  let hasPath = last.length < path.length;\n  let hasDot = ext.length < last.length - 1;\n\n  return (hasDot || !hasPath) && this._types[ext] || null;\n};\n\n/**\n * Return file extension associated with a mime type\n */\nMime.prototype.getExtension = function(type) {\n  type = /^\\s*([^;\\s]*)/.test(type) && RegExp.$1;\n  return type && this._extensions[type.toLowerCase()] || null;\n};\n\nmodule.exports = Mime;\n", "module.exports = {\"application/andrew-inset\":[\"ez\"],\"application/applixware\":[\"aw\"],\"application/atom+xml\":[\"atom\"],\"application/atomcat+xml\":[\"atomcat\"],\"application/atomdeleted+xml\":[\"atomdeleted\"],\"application/atomsvc+xml\":[\"atomsvc\"],\"application/atsc-dwd+xml\":[\"dwd\"],\"application/atsc-held+xml\":[\"held\"],\"application/atsc-rsat+xml\":[\"rsat\"],\"application/bdoc\":[\"bdoc\"],\"application/calendar+xml\":[\"xcs\"],\"application/ccxml+xml\":[\"ccxml\"],\"application/cdfx+xml\":[\"cdfx\"],\"application/cdmi-capability\":[\"cdmia\"],\"application/cdmi-container\":[\"cdmic\"],\"application/cdmi-domain\":[\"cdmid\"],\"application/cdmi-object\":[\"cdmio\"],\"application/cdmi-queue\":[\"cdmiq\"],\"application/cu-seeme\":[\"cu\"],\"application/dash+xml\":[\"mpd\"],\"application/davmount+xml\":[\"davmount\"],\"application/docbook+xml\":[\"dbk\"],\"application/dssc+der\":[\"dssc\"],\"application/dssc+xml\":[\"xdssc\"],\"application/ecmascript\":[\"es\",\"ecma\"],\"application/emma+xml\":[\"emma\"],\"application/emotionml+xml\":[\"emotionml\"],\"application/epub+zip\":[\"epub\"],\"application/exi\":[\"exi\"],\"application/express\":[\"exp\"],\"application/fdt+xml\":[\"fdt\"],\"application/font-tdpfr\":[\"pfr\"],\"application/geo+json\":[\"geojson\"],\"application/gml+xml\":[\"gml\"],\"application/gpx+xml\":[\"gpx\"],\"application/gxf\":[\"gxf\"],\"application/gzip\":[\"gz\"],\"application/hjson\":[\"hjson\"],\"application/hyperstudio\":[\"stk\"],\"application/inkml+xml\":[\"ink\",\"inkml\"],\"application/ipfix\":[\"ipfix\"],\"application/its+xml\":[\"its\"],\"application/java-archive\":[\"jar\",\"war\",\"ear\"],\"application/java-serialized-object\":[\"ser\"],\"application/java-vm\":[\"class\"],\"application/javascript\":[\"js\",\"mjs\"],\"application/json\":[\"json\",\"map\"],\"application/json5\":[\"json5\"],\"application/jsonml+json\":[\"jsonml\"],\"application/ld+json\":[\"jsonld\"],\"application/lgr+xml\":[\"lgr\"],\"application/lost+xml\":[\"lostxml\"],\"application/mac-binhex40\":[\"hqx\"],\"application/mac-compactpro\":[\"cpt\"],\"application/mads+xml\":[\"mads\"],\"application/manifest+json\":[\"webmanifest\"],\"application/marc\":[\"mrc\"],\"application/marcxml+xml\":[\"mrcx\"],\"application/mathematica\":[\"ma\",\"nb\",\"mb\"],\"application/mathml+xml\":[\"mathml\"],\"application/mbox\":[\"mbox\"],\"application/mediaservercontrol+xml\":[\"mscml\"],\"application/metalink+xml\":[\"metalink\"],\"application/metalink4+xml\":[\"meta4\"],\"application/mets+xml\":[\"mets\"],\"application/mmt-aei+xml\":[\"maei\"],\"application/mmt-usd+xml\":[\"musd\"],\"application/mods+xml\":[\"mods\"],\"application/mp21\":[\"m21\",\"mp21\"],\"application/mp4\":[\"mp4s\",\"m4p\"],\"application/msword\":[\"doc\",\"dot\"],\"application/mxf\":[\"mxf\"],\"application/n-quads\":[\"nq\"],\"application/n-triples\":[\"nt\"],\"application/node\":[\"cjs\"],\"application/octet-stream\":[\"bin\",\"dms\",\"lrf\",\"mar\",\"so\",\"dist\",\"distz\",\"pkg\",\"bpk\",\"dump\",\"elc\",\"deploy\",\"exe\",\"dll\",\"deb\",\"dmg\",\"iso\",\"img\",\"msi\",\"msp\",\"msm\",\"buffer\"],\"application/oda\":[\"oda\"],\"application/oebps-package+xml\":[\"opf\"],\"application/ogg\":[\"ogx\"],\"application/omdoc+xml\":[\"omdoc\"],\"application/onenote\":[\"onetoc\",\"onetoc2\",\"onetmp\",\"onepkg\"],\"application/oxps\":[\"oxps\"],\"application/p2p-overlay+xml\":[\"relo\"],\"application/patch-ops-error+xml\":[\"xer\"],\"application/pdf\":[\"pdf\"],\"application/pgp-encrypted\":[\"pgp\"],\"application/pgp-signature\":[\"asc\",\"sig\"],\"application/pics-rules\":[\"prf\"],\"application/pkcs10\":[\"p10\"],\"application/pkcs7-mime\":[\"p7m\",\"p7c\"],\"application/pkcs7-signature\":[\"p7s\"],\"application/pkcs8\":[\"p8\"],\"application/pkix-attr-cert\":[\"ac\"],\"application/pkix-cert\":[\"cer\"],\"application/pkix-crl\":[\"crl\"],\"application/pkix-pkipath\":[\"pkipath\"],\"application/pkixcmp\":[\"pki\"],\"application/pls+xml\":[\"pls\"],\"application/postscript\":[\"ai\",\"eps\",\"ps\"],\"application/provenance+xml\":[\"provx\"],\"application/pskc+xml\":[\"pskcxml\"],\"application/raml+yaml\":[\"raml\"],\"application/rdf+xml\":[\"rdf\",\"owl\"],\"application/reginfo+xml\":[\"rif\"],\"application/relax-ng-compact-syntax\":[\"rnc\"],\"application/resource-lists+xml\":[\"rl\"],\"application/resource-lists-diff+xml\":[\"rld\"],\"application/rls-services+xml\":[\"rs\"],\"application/route-apd+xml\":[\"rapd\"],\"application/route-s-tsid+xml\":[\"sls\"],\"application/route-usd+xml\":[\"rusd\"],\"application/rpki-ghostbusters\":[\"gbr\"],\"application/rpki-manifest\":[\"mft\"],\"application/rpki-roa\":[\"roa\"],\"application/rsd+xml\":[\"rsd\"],\"application/rss+xml\":[\"rss\"],\"application/rtf\":[\"rtf\"],\"application/sbml+xml\":[\"sbml\"],\"application/scvp-cv-request\":[\"scq\"],\"application/scvp-cv-response\":[\"scs\"],\"application/scvp-vp-request\":[\"spq\"],\"application/scvp-vp-response\":[\"spp\"],\"application/sdp\":[\"sdp\"],\"application/senml+xml\":[\"senmlx\"],\"application/sensml+xml\":[\"sensmlx\"],\"application/set-payment-initiation\":[\"setpay\"],\"application/set-registration-initiation\":[\"setreg\"],\"application/shf+xml\":[\"shf\"],\"application/sieve\":[\"siv\",\"sieve\"],\"application/smil+xml\":[\"smi\",\"smil\"],\"application/sparql-query\":[\"rq\"],\"application/sparql-results+xml\":[\"srx\"],\"application/srgs\":[\"gram\"],\"application/srgs+xml\":[\"grxml\"],\"application/sru+xml\":[\"sru\"],\"application/ssdl+xml\":[\"ssdl\"],\"application/ssml+xml\":[\"ssml\"],\"application/swid+xml\":[\"swidtag\"],\"application/tei+xml\":[\"tei\",\"teicorpus\"],\"application/thraud+xml\":[\"tfi\"],\"application/timestamped-data\":[\"tsd\"],\"application/toml\":[\"toml\"],\"application/trig\":[\"trig\"],\"application/ttml+xml\":[\"ttml\"],\"application/ubjson\":[\"ubj\"],\"application/urc-ressheet+xml\":[\"rsheet\"],\"application/urc-targetdesc+xml\":[\"td\"],\"application/voicexml+xml\":[\"vxml\"],\"application/wasm\":[\"wasm\"],\"application/widget\":[\"wgt\"],\"application/winhlp\":[\"hlp\"],\"application/wsdl+xml\":[\"wsdl\"],\"application/wspolicy+xml\":[\"wspolicy\"],\"application/xaml+xml\":[\"xaml\"],\"application/xcap-att+xml\":[\"xav\"],\"application/xcap-caps+xml\":[\"xca\"],\"application/xcap-diff+xml\":[\"xdf\"],\"application/xcap-el+xml\":[\"xel\"],\"application/xcap-ns+xml\":[\"xns\"],\"application/xenc+xml\":[\"xenc\"],\"application/xhtml+xml\":[\"xhtml\",\"xht\"],\"application/xliff+xml\":[\"xlf\"],\"application/xml\":[\"xml\",\"xsl\",\"xsd\",\"rng\"],\"application/xml-dtd\":[\"dtd\"],\"application/xop+xml\":[\"xop\"],\"application/xproc+xml\":[\"xpl\"],\"application/xslt+xml\":[\"*xsl\",\"xslt\"],\"application/xspf+xml\":[\"xspf\"],\"application/xv+xml\":[\"mxml\",\"xhvml\",\"xvml\",\"xvm\"],\"application/yang\":[\"yang\"],\"application/yin+xml\":[\"yin\"],\"application/zip\":[\"zip\"],\"audio/3gpp\":[\"*3gpp\"],\"audio/adpcm\":[\"adp\"],\"audio/amr\":[\"amr\"],\"audio/basic\":[\"au\",\"snd\"],\"audio/midi\":[\"mid\",\"midi\",\"kar\",\"rmi\"],\"audio/mobile-xmf\":[\"mxmf\"],\"audio/mp3\":[\"*mp3\"],\"audio/mp4\":[\"m4a\",\"mp4a\"],\"audio/mpeg\":[\"mpga\",\"mp2\",\"mp2a\",\"mp3\",\"m2a\",\"m3a\"],\"audio/ogg\":[\"oga\",\"ogg\",\"spx\",\"opus\"],\"audio/s3m\":[\"s3m\"],\"audio/silk\":[\"sil\"],\"audio/wav\":[\"wav\"],\"audio/wave\":[\"*wav\"],\"audio/webm\":[\"weba\"],\"audio/xm\":[\"xm\"],\"font/collection\":[\"ttc\"],\"font/otf\":[\"otf\"],\"font/ttf\":[\"ttf\"],\"font/woff\":[\"woff\"],\"font/woff2\":[\"woff2\"],\"image/aces\":[\"exr\"],\"image/apng\":[\"apng\"],\"image/avif\":[\"avif\"],\"image/bmp\":[\"bmp\"],\"image/cgm\":[\"cgm\"],\"image/dicom-rle\":[\"drle\"],\"image/emf\":[\"emf\"],\"image/fits\":[\"fits\"],\"image/g3fax\":[\"g3\"],\"image/gif\":[\"gif\"],\"image/heic\":[\"heic\"],\"image/heic-sequence\":[\"heics\"],\"image/heif\":[\"heif\"],\"image/heif-sequence\":[\"heifs\"],\"image/hej2k\":[\"hej2\"],\"image/hsj2\":[\"hsj2\"],\"image/ief\":[\"ief\"],\"image/jls\":[\"jls\"],\"image/jp2\":[\"jp2\",\"jpg2\"],\"image/jpeg\":[\"jpeg\",\"jpg\",\"jpe\"],\"image/jph\":[\"jph\"],\"image/jphc\":[\"jhc\"],\"image/jpm\":[\"jpm\"],\"image/jpx\":[\"jpx\",\"jpf\"],\"image/jxr\":[\"jxr\"],\"image/jxra\":[\"jxra\"],\"image/jxrs\":[\"jxrs\"],\"image/jxs\":[\"jxs\"],\"image/jxsc\":[\"jxsc\"],\"image/jxsi\":[\"jxsi\"],\"image/jxss\":[\"jxss\"],\"image/ktx\":[\"ktx\"],\"image/ktx2\":[\"ktx2\"],\"image/png\":[\"png\"],\"image/sgi\":[\"sgi\"],\"image/svg+xml\":[\"svg\",\"svgz\"],\"image/t38\":[\"t38\"],\"image/tiff\":[\"tif\",\"tiff\"],\"image/tiff-fx\":[\"tfx\"],\"image/webp\":[\"webp\"],\"image/wmf\":[\"wmf\"],\"message/disposition-notification\":[\"disposition-notification\"],\"message/global\":[\"u8msg\"],\"message/global-delivery-status\":[\"u8dsn\"],\"message/global-disposition-notification\":[\"u8mdn\"],\"message/global-headers\":[\"u8hdr\"],\"message/rfc822\":[\"eml\",\"mime\"],\"model/3mf\":[\"3mf\"],\"model/gltf+json\":[\"gltf\"],\"model/gltf-binary\":[\"glb\"],\"model/iges\":[\"igs\",\"iges\"],\"model/mesh\":[\"msh\",\"mesh\",\"silo\"],\"model/mtl\":[\"mtl\"],\"model/obj\":[\"obj\"],\"model/step+xml\":[\"stpx\"],\"model/step+zip\":[\"stpz\"],\"model/step-xml+zip\":[\"stpxz\"],\"model/stl\":[\"stl\"],\"model/vrml\":[\"wrl\",\"vrml\"],\"model/x3d+binary\":[\"*x3db\",\"x3dbz\"],\"model/x3d+fastinfoset\":[\"x3db\"],\"model/x3d+vrml\":[\"*x3dv\",\"x3dvz\"],\"model/x3d+xml\":[\"x3d\",\"x3dz\"],\"model/x3d-vrml\":[\"x3dv\"],\"text/cache-manifest\":[\"appcache\",\"manifest\"],\"text/calendar\":[\"ics\",\"ifb\"],\"text/coffeescript\":[\"coffee\",\"litcoffee\"],\"text/css\":[\"css\"],\"text/csv\":[\"csv\"],\"text/html\":[\"html\",\"htm\",\"shtml\"],\"text/jade\":[\"jade\"],\"text/jsx\":[\"jsx\"],\"text/less\":[\"less\"],\"text/markdown\":[\"markdown\",\"md\"],\"text/mathml\":[\"mml\"],\"text/mdx\":[\"mdx\"],\"text/n3\":[\"n3\"],\"text/plain\":[\"txt\",\"text\",\"conf\",\"def\",\"list\",\"log\",\"in\",\"ini\"],\"text/richtext\":[\"rtx\"],\"text/rtf\":[\"*rtf\"],\"text/sgml\":[\"sgml\",\"sgm\"],\"text/shex\":[\"shex\"],\"text/slim\":[\"slim\",\"slm\"],\"text/spdx\":[\"spdx\"],\"text/stylus\":[\"stylus\",\"styl\"],\"text/tab-separated-values\":[\"tsv\"],\"text/troff\":[\"t\",\"tr\",\"roff\",\"man\",\"me\",\"ms\"],\"text/turtle\":[\"ttl\"],\"text/uri-list\":[\"uri\",\"uris\",\"urls\"],\"text/vcard\":[\"vcard\"],\"text/vtt\":[\"vtt\"],\"text/xml\":[\"*xml\"],\"text/yaml\":[\"yaml\",\"yml\"],\"video/3gpp\":[\"3gp\",\"3gpp\"],\"video/3gpp2\":[\"3g2\"],\"video/h261\":[\"h261\"],\"video/h263\":[\"h263\"],\"video/h264\":[\"h264\"],\"video/iso.segment\":[\"m4s\"],\"video/jpeg\":[\"jpgv\"],\"video/jpm\":[\"*jpm\",\"jpgm\"],\"video/mj2\":[\"mj2\",\"mjp2\"],\"video/mp2t\":[\"ts\"],\"video/mp4\":[\"mp4\",\"mp4v\",\"mpg4\"],\"video/mpeg\":[\"mpeg\",\"mpg\",\"mpe\",\"m1v\",\"m2v\"],\"video/ogg\":[\"ogv\"],\"video/quicktime\":[\"qt\",\"mov\"],\"video/webm\":[\"webm\"]};", "module.exports = {\"application/prs.cww\":[\"cww\"],\"application/vnd.1000minds.decision-model+xml\":[\"1km\"],\"application/vnd.3gpp.pic-bw-large\":[\"plb\"],\"application/vnd.3gpp.pic-bw-small\":[\"psb\"],\"application/vnd.3gpp.pic-bw-var\":[\"pvb\"],\"application/vnd.3gpp2.tcap\":[\"tcap\"],\"application/vnd.3m.post-it-notes\":[\"pwn\"],\"application/vnd.accpac.simply.aso\":[\"aso\"],\"application/vnd.accpac.simply.imp\":[\"imp\"],\"application/vnd.acucobol\":[\"acu\"],\"application/vnd.acucorp\":[\"atc\",\"acutc\"],\"application/vnd.adobe.air-application-installer-package+zip\":[\"air\"],\"application/vnd.adobe.formscentral.fcdt\":[\"fcdt\"],\"application/vnd.adobe.fxp\":[\"fxp\",\"fxpl\"],\"application/vnd.adobe.xdp+xml\":[\"xdp\"],\"application/vnd.adobe.xfdf\":[\"xfdf\"],\"application/vnd.ahead.space\":[\"ahead\"],\"application/vnd.airzip.filesecure.azf\":[\"azf\"],\"application/vnd.airzip.filesecure.azs\":[\"azs\"],\"application/vnd.amazon.ebook\":[\"azw\"],\"application/vnd.americandynamics.acc\":[\"acc\"],\"application/vnd.amiga.ami\":[\"ami\"],\"application/vnd.android.package-archive\":[\"apk\"],\"application/vnd.anser-web-certificate-issue-initiation\":[\"cii\"],\"application/vnd.anser-web-funds-transfer-initiation\":[\"fti\"],\"application/vnd.antix.game-component\":[\"atx\"],\"application/vnd.apple.installer+xml\":[\"mpkg\"],\"application/vnd.apple.keynote\":[\"key\"],\"application/vnd.apple.mpegurl\":[\"m3u8\"],\"application/vnd.apple.numbers\":[\"numbers\"],\"application/vnd.apple.pages\":[\"pages\"],\"application/vnd.apple.pkpass\":[\"pkpass\"],\"application/vnd.aristanetworks.swi\":[\"swi\"],\"application/vnd.astraea-software.iota\":[\"iota\"],\"application/vnd.audiograph\":[\"aep\"],\"application/vnd.balsamiq.bmml+xml\":[\"bmml\"],\"application/vnd.blueice.multipass\":[\"mpm\"],\"application/vnd.bmi\":[\"bmi\"],\"application/vnd.businessobjects\":[\"rep\"],\"application/vnd.chemdraw+xml\":[\"cdxml\"],\"application/vnd.chipnuts.karaoke-mmd\":[\"mmd\"],\"application/vnd.cinderella\":[\"cdy\"],\"application/vnd.citationstyles.style+xml\":[\"csl\"],\"application/vnd.claymore\":[\"cla\"],\"application/vnd.cloanto.rp9\":[\"rp9\"],\"application/vnd.clonk.c4group\":[\"c4g\",\"c4d\",\"c4f\",\"c4p\",\"c4u\"],\"application/vnd.cluetrust.cartomobile-config\":[\"c11amc\"],\"application/vnd.cluetrust.cartomobile-config-pkg\":[\"c11amz\"],\"application/vnd.commonspace\":[\"csp\"],\"application/vnd.contact.cmsg\":[\"cdbcmsg\"],\"application/vnd.cosmocaller\":[\"cmc\"],\"application/vnd.crick.clicker\":[\"clkx\"],\"application/vnd.crick.clicker.keyboard\":[\"clkk\"],\"application/vnd.crick.clicker.palette\":[\"clkp\"],\"application/vnd.crick.clicker.template\":[\"clkt\"],\"application/vnd.crick.clicker.wordbank\":[\"clkw\"],\"application/vnd.criticaltools.wbs+xml\":[\"wbs\"],\"application/vnd.ctc-posml\":[\"pml\"],\"application/vnd.cups-ppd\":[\"ppd\"],\"application/vnd.curl.car\":[\"car\"],\"application/vnd.curl.pcurl\":[\"pcurl\"],\"application/vnd.dart\":[\"dart\"],\"application/vnd.data-vision.rdz\":[\"rdz\"],\"application/vnd.dbf\":[\"dbf\"],\"application/vnd.dece.data\":[\"uvf\",\"uvvf\",\"uvd\",\"uvvd\"],\"application/vnd.dece.ttml+xml\":[\"uvt\",\"uvvt\"],\"application/vnd.dece.unspecified\":[\"uvx\",\"uvvx\"],\"application/vnd.dece.zip\":[\"uvz\",\"uvvz\"],\"application/vnd.denovo.fcselayout-link\":[\"fe_launch\"],\"application/vnd.dna\":[\"dna\"],\"application/vnd.dolby.mlp\":[\"mlp\"],\"application/vnd.dpgraph\":[\"dpg\"],\"application/vnd.dreamfactory\":[\"dfac\"],\"application/vnd.ds-keypoint\":[\"kpxx\"],\"application/vnd.dvb.ait\":[\"ait\"],\"application/vnd.dvb.service\":[\"svc\"],\"application/vnd.dynageo\":[\"geo\"],\"application/vnd.ecowin.chart\":[\"mag\"],\"application/vnd.enliven\":[\"nml\"],\"application/vnd.epson.esf\":[\"esf\"],\"application/vnd.epson.msf\":[\"msf\"],\"application/vnd.epson.quickanime\":[\"qam\"],\"application/vnd.epson.salt\":[\"slt\"],\"application/vnd.epson.ssf\":[\"ssf\"],\"application/vnd.eszigno3+xml\":[\"es3\",\"et3\"],\"application/vnd.ezpix-album\":[\"ez2\"],\"application/vnd.ezpix-package\":[\"ez3\"],\"application/vnd.fdf\":[\"fdf\"],\"application/vnd.fdsn.mseed\":[\"mseed\"],\"application/vnd.fdsn.seed\":[\"seed\",\"dataless\"],\"application/vnd.flographit\":[\"gph\"],\"application/vnd.fluxtime.clip\":[\"ftc\"],\"application/vnd.framemaker\":[\"fm\",\"frame\",\"maker\",\"book\"],\"application/vnd.frogans.fnc\":[\"fnc\"],\"application/vnd.frogans.ltf\":[\"ltf\"],\"application/vnd.fsc.weblaunch\":[\"fsc\"],\"application/vnd.fujitsu.oasys\":[\"oas\"],\"application/vnd.fujitsu.oasys2\":[\"oa2\"],\"application/vnd.fujitsu.oasys3\":[\"oa3\"],\"application/vnd.fujitsu.oasysgp\":[\"fg5\"],\"application/vnd.fujitsu.oasysprs\":[\"bh2\"],\"application/vnd.fujixerox.ddd\":[\"ddd\"],\"application/vnd.fujixerox.docuworks\":[\"xdw\"],\"application/vnd.fujixerox.docuworks.binder\":[\"xbd\"],\"application/vnd.fuzzysheet\":[\"fzs\"],\"application/vnd.genomatix.tuxedo\":[\"txd\"],\"application/vnd.geogebra.file\":[\"ggb\"],\"application/vnd.geogebra.tool\":[\"ggt\"],\"application/vnd.geometry-explorer\":[\"gex\",\"gre\"],\"application/vnd.geonext\":[\"gxt\"],\"application/vnd.geoplan\":[\"g2w\"],\"application/vnd.geospace\":[\"g3w\"],\"application/vnd.gmx\":[\"gmx\"],\"application/vnd.google-apps.document\":[\"gdoc\"],\"application/vnd.google-apps.presentation\":[\"gslides\"],\"application/vnd.google-apps.spreadsheet\":[\"gsheet\"],\"application/vnd.google-earth.kml+xml\":[\"kml\"],\"application/vnd.google-earth.kmz\":[\"kmz\"],\"application/vnd.grafeq\":[\"gqf\",\"gqs\"],\"application/vnd.groove-account\":[\"gac\"],\"application/vnd.groove-help\":[\"ghf\"],\"application/vnd.groove-identity-message\":[\"gim\"],\"application/vnd.groove-injector\":[\"grv\"],\"application/vnd.groove-tool-message\":[\"gtm\"],\"application/vnd.groove-tool-template\":[\"tpl\"],\"application/vnd.groove-vcard\":[\"vcg\"],\"application/vnd.hal+xml\":[\"hal\"],\"application/vnd.handheld-entertainment+xml\":[\"zmm\"],\"application/vnd.hbci\":[\"hbci\"],\"application/vnd.hhe.lesson-player\":[\"les\"],\"application/vnd.hp-hpgl\":[\"hpgl\"],\"application/vnd.hp-hpid\":[\"hpid\"],\"application/vnd.hp-hps\":[\"hps\"],\"application/vnd.hp-jlyt\":[\"jlt\"],\"application/vnd.hp-pcl\":[\"pcl\"],\"application/vnd.hp-pclxl\":[\"pclxl\"],\"application/vnd.hydrostatix.sof-data\":[\"sfd-hdstx\"],\"application/vnd.ibm.minipay\":[\"mpy\"],\"application/vnd.ibm.modcap\":[\"afp\",\"listafp\",\"list3820\"],\"application/vnd.ibm.rights-management\":[\"irm\"],\"application/vnd.ibm.secure-container\":[\"sc\"],\"application/vnd.iccprofile\":[\"icc\",\"icm\"],\"application/vnd.igloader\":[\"igl\"],\"application/vnd.immervision-ivp\":[\"ivp\"],\"application/vnd.immervision-ivu\":[\"ivu\"],\"application/vnd.insors.igm\":[\"igm\"],\"application/vnd.intercon.formnet\":[\"xpw\",\"xpx\"],\"application/vnd.intergeo\":[\"i2g\"],\"application/vnd.intu.qbo\":[\"qbo\"],\"application/vnd.intu.qfx\":[\"qfx\"],\"application/vnd.ipunplugged.rcprofile\":[\"rcprofile\"],\"application/vnd.irepository.package+xml\":[\"irp\"],\"application/vnd.is-xpr\":[\"xpr\"],\"application/vnd.isac.fcs\":[\"fcs\"],\"application/vnd.jam\":[\"jam\"],\"application/vnd.jcp.javame.midlet-rms\":[\"rms\"],\"application/vnd.jisp\":[\"jisp\"],\"application/vnd.joost.joda-archive\":[\"joda\"],\"application/vnd.kahootz\":[\"ktz\",\"ktr\"],\"application/vnd.kde.karbon\":[\"karbon\"],\"application/vnd.kde.kchart\":[\"chrt\"],\"application/vnd.kde.kformula\":[\"kfo\"],\"application/vnd.kde.kivio\":[\"flw\"],\"application/vnd.kde.kontour\":[\"kon\"],\"application/vnd.kde.kpresenter\":[\"kpr\",\"kpt\"],\"application/vnd.kde.kspread\":[\"ksp\"],\"application/vnd.kde.kword\":[\"kwd\",\"kwt\"],\"application/vnd.kenameaapp\":[\"htke\"],\"application/vnd.kidspiration\":[\"kia\"],\"application/vnd.kinar\":[\"kne\",\"knp\"],\"application/vnd.koan\":[\"skp\",\"skd\",\"skt\",\"skm\"],\"application/vnd.kodak-descriptor\":[\"sse\"],\"application/vnd.las.las+xml\":[\"lasxml\"],\"application/vnd.llamagraphics.life-balance.desktop\":[\"lbd\"],\"application/vnd.llamagraphics.life-balance.exchange+xml\":[\"lbe\"],\"application/vnd.lotus-1-2-3\":[\"123\"],\"application/vnd.lotus-approach\":[\"apr\"],\"application/vnd.lotus-freelance\":[\"pre\"],\"application/vnd.lotus-notes\":[\"nsf\"],\"application/vnd.lotus-organizer\":[\"org\"],\"application/vnd.lotus-screencam\":[\"scm\"],\"application/vnd.lotus-wordpro\":[\"lwp\"],\"application/vnd.macports.portpkg\":[\"portpkg\"],\"application/vnd.mapbox-vector-tile\":[\"mvt\"],\"application/vnd.mcd\":[\"mcd\"],\"application/vnd.medcalcdata\":[\"mc1\"],\"application/vnd.mediastation.cdkey\":[\"cdkey\"],\"application/vnd.mfer\":[\"mwf\"],\"application/vnd.mfmp\":[\"mfm\"],\"application/vnd.micrografx.flo\":[\"flo\"],\"application/vnd.micrografx.igx\":[\"igx\"],\"application/vnd.mif\":[\"mif\"],\"application/vnd.mobius.daf\":[\"daf\"],\"application/vnd.mobius.dis\":[\"dis\"],\"application/vnd.mobius.mbk\":[\"mbk\"],\"application/vnd.mobius.mqy\":[\"mqy\"],\"application/vnd.mobius.msl\":[\"msl\"],\"application/vnd.mobius.plc\":[\"plc\"],\"application/vnd.mobius.txf\":[\"txf\"],\"application/vnd.mophun.application\":[\"mpn\"],\"application/vnd.mophun.certificate\":[\"mpc\"],\"application/vnd.mozilla.xul+xml\":[\"xul\"],\"application/vnd.ms-artgalry\":[\"cil\"],\"application/vnd.ms-cab-compressed\":[\"cab\"],\"application/vnd.ms-excel\":[\"xls\",\"xlm\",\"xla\",\"xlc\",\"xlt\",\"xlw\"],\"application/vnd.ms-excel.addin.macroenabled.12\":[\"xlam\"],\"application/vnd.ms-excel.sheet.binary.macroenabled.12\":[\"xlsb\"],\"application/vnd.ms-excel.sheet.macroenabled.12\":[\"xlsm\"],\"application/vnd.ms-excel.template.macroenabled.12\":[\"xltm\"],\"application/vnd.ms-fontobject\":[\"eot\"],\"application/vnd.ms-htmlhelp\":[\"chm\"],\"application/vnd.ms-ims\":[\"ims\"],\"application/vnd.ms-lrm\":[\"lrm\"],\"application/vnd.ms-officetheme\":[\"thmx\"],\"application/vnd.ms-outlook\":[\"msg\"],\"application/vnd.ms-pki.seccat\":[\"cat\"],\"application/vnd.ms-pki.stl\":[\"*stl\"],\"application/vnd.ms-powerpoint\":[\"ppt\",\"pps\",\"pot\"],\"application/vnd.ms-powerpoint.addin.macroenabled.12\":[\"ppam\"],\"application/vnd.ms-powerpoint.presentation.macroenabled.12\":[\"pptm\"],\"application/vnd.ms-powerpoint.slide.macroenabled.12\":[\"sldm\"],\"application/vnd.ms-powerpoint.slideshow.macroenabled.12\":[\"ppsm\"],\"application/vnd.ms-powerpoint.template.macroenabled.12\":[\"potm\"],\"application/vnd.ms-project\":[\"mpp\",\"mpt\"],\"application/vnd.ms-word.document.macroenabled.12\":[\"docm\"],\"application/vnd.ms-word.template.macroenabled.12\":[\"dotm\"],\"application/vnd.ms-works\":[\"wps\",\"wks\",\"wcm\",\"wdb\"],\"application/vnd.ms-wpl\":[\"wpl\"],\"application/vnd.ms-xpsdocument\":[\"xps\"],\"application/vnd.mseq\":[\"mseq\"],\"application/vnd.musician\":[\"mus\"],\"application/vnd.muvee.style\":[\"msty\"],\"application/vnd.mynfc\":[\"taglet\"],\"application/vnd.neurolanguage.nlu\":[\"nlu\"],\"application/vnd.nitf\":[\"ntf\",\"nitf\"],\"application/vnd.noblenet-directory\":[\"nnd\"],\"application/vnd.noblenet-sealer\":[\"nns\"],\"application/vnd.noblenet-web\":[\"nnw\"],\"application/vnd.nokia.n-gage.ac+xml\":[\"*ac\"],\"application/vnd.nokia.n-gage.data\":[\"ngdat\"],\"application/vnd.nokia.n-gage.symbian.install\":[\"n-gage\"],\"application/vnd.nokia.radio-preset\":[\"rpst\"],\"application/vnd.nokia.radio-presets\":[\"rpss\"],\"application/vnd.novadigm.edm\":[\"edm\"],\"application/vnd.novadigm.edx\":[\"edx\"],\"application/vnd.novadigm.ext\":[\"ext\"],\"application/vnd.oasis.opendocument.chart\":[\"odc\"],\"application/vnd.oasis.opendocument.chart-template\":[\"otc\"],\"application/vnd.oasis.opendocument.database\":[\"odb\"],\"application/vnd.oasis.opendocument.formula\":[\"odf\"],\"application/vnd.oasis.opendocument.formula-template\":[\"odft\"],\"application/vnd.oasis.opendocument.graphics\":[\"odg\"],\"application/vnd.oasis.opendocument.graphics-template\":[\"otg\"],\"application/vnd.oasis.opendocument.image\":[\"odi\"],\"application/vnd.oasis.opendocument.image-template\":[\"oti\"],\"application/vnd.oasis.opendocument.presentation\":[\"odp\"],\"application/vnd.oasis.opendocument.presentation-template\":[\"otp\"],\"application/vnd.oasis.opendocument.spreadsheet\":[\"ods\"],\"application/vnd.oasis.opendocument.spreadsheet-template\":[\"ots\"],\"application/vnd.oasis.opendocument.text\":[\"odt\"],\"application/vnd.oasis.opendocument.text-master\":[\"odm\"],\"application/vnd.oasis.opendocument.text-template\":[\"ott\"],\"application/vnd.oasis.opendocument.text-web\":[\"oth\"],\"application/vnd.olpc-sugar\":[\"xo\"],\"application/vnd.oma.dd2+xml\":[\"dd2\"],\"application/vnd.openblox.game+xml\":[\"obgx\"],\"application/vnd.openofficeorg.extension\":[\"oxt\"],\"application/vnd.openstreetmap.data+xml\":[\"osm\"],\"application/vnd.openxmlformats-officedocument.presentationml.presentation\":[\"pptx\"],\"application/vnd.openxmlformats-officedocument.presentationml.slide\":[\"sldx\"],\"application/vnd.openxmlformats-officedocument.presentationml.slideshow\":[\"ppsx\"],\"application/vnd.openxmlformats-officedocument.presentationml.template\":[\"potx\"],\"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\":[\"xlsx\"],\"application/vnd.openxmlformats-officedocument.spreadsheetml.template\":[\"xltx\"],\"application/vnd.openxmlformats-officedocument.wordprocessingml.document\":[\"docx\"],\"application/vnd.openxmlformats-officedocument.wordprocessingml.template\":[\"dotx\"],\"application/vnd.osgeo.mapguide.package\":[\"mgp\"],\"application/vnd.osgi.dp\":[\"dp\"],\"application/vnd.osgi.subsystem\":[\"esa\"],\"application/vnd.palm\":[\"pdb\",\"pqa\",\"oprc\"],\"application/vnd.pawaafile\":[\"paw\"],\"application/vnd.pg.format\":[\"str\"],\"application/vnd.pg.osasli\":[\"ei6\"],\"application/vnd.picsel\":[\"efif\"],\"application/vnd.pmi.widget\":[\"wg\"],\"application/vnd.pocketlearn\":[\"plf\"],\"application/vnd.powerbuilder6\":[\"pbd\"],\"application/vnd.previewsystems.box\":[\"box\"],\"application/vnd.proteus.magazine\":[\"mgz\"],\"application/vnd.publishare-delta-tree\":[\"qps\"],\"application/vnd.pvi.ptid1\":[\"ptid\"],\"application/vnd.quark.quarkxpress\":[\"qxd\",\"qxt\",\"qwd\",\"qwt\",\"qxl\",\"qxb\"],\"application/vnd.rar\":[\"rar\"],\"application/vnd.realvnc.bed\":[\"bed\"],\"application/vnd.recordare.musicxml\":[\"mxl\"],\"application/vnd.recordare.musicxml+xml\":[\"musicxml\"],\"application/vnd.rig.cryptonote\":[\"cryptonote\"],\"application/vnd.rim.cod\":[\"cod\"],\"application/vnd.rn-realmedia\":[\"rm\"],\"application/vnd.rn-realmedia-vbr\":[\"rmvb\"],\"application/vnd.route66.link66+xml\":[\"link66\"],\"application/vnd.sailingtracker.track\":[\"st\"],\"application/vnd.seemail\":[\"see\"],\"application/vnd.sema\":[\"sema\"],\"application/vnd.semd\":[\"semd\"],\"application/vnd.semf\":[\"semf\"],\"application/vnd.shana.informed.formdata\":[\"ifm\"],\"application/vnd.shana.informed.formtemplate\":[\"itp\"],\"application/vnd.shana.informed.interchange\":[\"iif\"],\"application/vnd.shana.informed.package\":[\"ipk\"],\"application/vnd.simtech-mindmapper\":[\"twd\",\"twds\"],\"application/vnd.smaf\":[\"mmf\"],\"application/vnd.smart.teacher\":[\"teacher\"],\"application/vnd.software602.filler.form+xml\":[\"fo\"],\"application/vnd.solent.sdkm+xml\":[\"sdkm\",\"sdkd\"],\"application/vnd.spotfire.dxp\":[\"dxp\"],\"application/vnd.spotfire.sfs\":[\"sfs\"],\"application/vnd.stardivision.calc\":[\"sdc\"],\"application/vnd.stardivision.draw\":[\"sda\"],\"application/vnd.stardivision.impress\":[\"sdd\"],\"application/vnd.stardivision.math\":[\"smf\"],\"application/vnd.stardivision.writer\":[\"sdw\",\"vor\"],\"application/vnd.stardivision.writer-global\":[\"sgl\"],\"application/vnd.stepmania.package\":[\"smzip\"],\"application/vnd.stepmania.stepchart\":[\"sm\"],\"application/vnd.sun.wadl+xml\":[\"wadl\"],\"application/vnd.sun.xml.calc\":[\"sxc\"],\"application/vnd.sun.xml.calc.template\":[\"stc\"],\"application/vnd.sun.xml.draw\":[\"sxd\"],\"application/vnd.sun.xml.draw.template\":[\"std\"],\"application/vnd.sun.xml.impress\":[\"sxi\"],\"application/vnd.sun.xml.impress.template\":[\"sti\"],\"application/vnd.sun.xml.math\":[\"sxm\"],\"application/vnd.sun.xml.writer\":[\"sxw\"],\"application/vnd.sun.xml.writer.global\":[\"sxg\"],\"application/vnd.sun.xml.writer.template\":[\"stw\"],\"application/vnd.sus-calendar\":[\"sus\",\"susp\"],\"application/vnd.svd\":[\"svd\"],\"application/vnd.symbian.install\":[\"sis\",\"sisx\"],\"application/vnd.syncml+xml\":[\"xsm\"],\"application/vnd.syncml.dm+wbxml\":[\"bdm\"],\"application/vnd.syncml.dm+xml\":[\"xdm\"],\"application/vnd.syncml.dmddf+xml\":[\"ddf\"],\"application/vnd.tao.intent-module-archive\":[\"tao\"],\"application/vnd.tcpdump.pcap\":[\"pcap\",\"cap\",\"dmp\"],\"application/vnd.tmobile-livetv\":[\"tmo\"],\"application/vnd.trid.tpt\":[\"tpt\"],\"application/vnd.triscape.mxs\":[\"mxs\"],\"application/vnd.trueapp\":[\"tra\"],\"application/vnd.ufdl\":[\"ufd\",\"ufdl\"],\"application/vnd.uiq.theme\":[\"utz\"],\"application/vnd.umajin\":[\"umj\"],\"application/vnd.unity\":[\"unityweb\"],\"application/vnd.uoml+xml\":[\"uoml\"],\"application/vnd.vcx\":[\"vcx\"],\"application/vnd.visio\":[\"vsd\",\"vst\",\"vss\",\"vsw\"],\"application/vnd.visionary\":[\"vis\"],\"application/vnd.vsf\":[\"vsf\"],\"application/vnd.wap.wbxml\":[\"wbxml\"],\"application/vnd.wap.wmlc\":[\"wmlc\"],\"application/vnd.wap.wmlscriptc\":[\"wmlsc\"],\"application/vnd.webturbo\":[\"wtb\"],\"application/vnd.wolfram.player\":[\"nbp\"],\"application/vnd.wordperfect\":[\"wpd\"],\"application/vnd.wqd\":[\"wqd\"],\"application/vnd.wt.stf\":[\"stf\"],\"application/vnd.xara\":[\"xar\"],\"application/vnd.xfdl\":[\"xfdl\"],\"application/vnd.yamaha.hv-dic\":[\"hvd\"],\"application/vnd.yamaha.hv-script\":[\"hvs\"],\"application/vnd.yamaha.hv-voice\":[\"hvp\"],\"application/vnd.yamaha.openscoreformat\":[\"osf\"],\"application/vnd.yamaha.openscoreformat.osfpvg+xml\":[\"osfpvg\"],\"application/vnd.yamaha.smaf-audio\":[\"saf\"],\"application/vnd.yamaha.smaf-phrase\":[\"spf\"],\"application/vnd.yellowriver-custom-menu\":[\"cmp\"],\"application/vnd.zul\":[\"zir\",\"zirz\"],\"application/vnd.zzazz.deck+xml\":[\"zaz\"],\"application/x-7z-compressed\":[\"7z\"],\"application/x-abiword\":[\"abw\"],\"application/x-ace-compressed\":[\"ace\"],\"application/x-apple-diskimage\":[\"*dmg\"],\"application/x-arj\":[\"arj\"],\"application/x-authorware-bin\":[\"aab\",\"x32\",\"u32\",\"vox\"],\"application/x-authorware-map\":[\"aam\"],\"application/x-authorware-seg\":[\"aas\"],\"application/x-bcpio\":[\"bcpio\"],\"application/x-bdoc\":[\"*bdoc\"],\"application/x-bittorrent\":[\"torrent\"],\"application/x-blorb\":[\"blb\",\"blorb\"],\"application/x-bzip\":[\"bz\"],\"application/x-bzip2\":[\"bz2\",\"boz\"],\"application/x-cbr\":[\"cbr\",\"cba\",\"cbt\",\"cbz\",\"cb7\"],\"application/x-cdlink\":[\"vcd\"],\"application/x-cfs-compressed\":[\"cfs\"],\"application/x-chat\":[\"chat\"],\"application/x-chess-pgn\":[\"pgn\"],\"application/x-chrome-extension\":[\"crx\"],\"application/x-cocoa\":[\"cco\"],\"application/x-conference\":[\"nsc\"],\"application/x-cpio\":[\"cpio\"],\"application/x-csh\":[\"csh\"],\"application/x-debian-package\":[\"*deb\",\"udeb\"],\"application/x-dgc-compressed\":[\"dgc\"],\"application/x-director\":[\"dir\",\"dcr\",\"dxr\",\"cst\",\"cct\",\"cxt\",\"w3d\",\"fgd\",\"swa\"],\"application/x-doom\":[\"wad\"],\"application/x-dtbncx+xml\":[\"ncx\"],\"application/x-dtbook+xml\":[\"dtb\"],\"application/x-dtbresource+xml\":[\"res\"],\"application/x-dvi\":[\"dvi\"],\"application/x-envoy\":[\"evy\"],\"application/x-eva\":[\"eva\"],\"application/x-font-bdf\":[\"bdf\"],\"application/x-font-ghostscript\":[\"gsf\"],\"application/x-font-linux-psf\":[\"psf\"],\"application/x-font-pcf\":[\"pcf\"],\"application/x-font-snf\":[\"snf\"],\"application/x-font-type1\":[\"pfa\",\"pfb\",\"pfm\",\"afm\"],\"application/x-freearc\":[\"arc\"],\"application/x-futuresplash\":[\"spl\"],\"application/x-gca-compressed\":[\"gca\"],\"application/x-glulx\":[\"ulx\"],\"application/x-gnumeric\":[\"gnumeric\"],\"application/x-gramps-xml\":[\"gramps\"],\"application/x-gtar\":[\"gtar\"],\"application/x-hdf\":[\"hdf\"],\"application/x-httpd-php\":[\"php\"],\"application/x-install-instructions\":[\"install\"],\"application/x-iso9660-image\":[\"*iso\"],\"application/x-iwork-keynote-sffkey\":[\"*key\"],\"application/x-iwork-numbers-sffnumbers\":[\"*numbers\"],\"application/x-iwork-pages-sffpages\":[\"*pages\"],\"application/x-java-archive-diff\":[\"jardiff\"],\"application/x-java-jnlp-file\":[\"jnlp\"],\"application/x-keepass2\":[\"kdbx\"],\"application/x-latex\":[\"latex\"],\"application/x-lua-bytecode\":[\"luac\"],\"application/x-lzh-compressed\":[\"lzh\",\"lha\"],\"application/x-makeself\":[\"run\"],\"application/x-mie\":[\"mie\"],\"application/x-mobipocket-ebook\":[\"prc\",\"mobi\"],\"application/x-ms-application\":[\"application\"],\"application/x-ms-shortcut\":[\"lnk\"],\"application/x-ms-wmd\":[\"wmd\"],\"application/x-ms-wmz\":[\"wmz\"],\"application/x-ms-xbap\":[\"xbap\"],\"application/x-msaccess\":[\"mdb\"],\"application/x-msbinder\":[\"obd\"],\"application/x-mscardfile\":[\"crd\"],\"application/x-msclip\":[\"clp\"],\"application/x-msdos-program\":[\"*exe\"],\"application/x-msdownload\":[\"*exe\",\"*dll\",\"com\",\"bat\",\"*msi\"],\"application/x-msmediaview\":[\"mvb\",\"m13\",\"m14\"],\"application/x-msmetafile\":[\"*wmf\",\"*wmz\",\"*emf\",\"emz\"],\"application/x-msmoney\":[\"mny\"],\"application/x-mspublisher\":[\"pub\"],\"application/x-msschedule\":[\"scd\"],\"application/x-msterminal\":[\"trm\"],\"application/x-mswrite\":[\"wri\"],\"application/x-netcdf\":[\"nc\",\"cdf\"],\"application/x-ns-proxy-autoconfig\":[\"pac\"],\"application/x-nzb\":[\"nzb\"],\"application/x-perl\":[\"pl\",\"pm\"],\"application/x-pilot\":[\"*prc\",\"*pdb\"],\"application/x-pkcs12\":[\"p12\",\"pfx\"],\"application/x-pkcs7-certificates\":[\"p7b\",\"spc\"],\"application/x-pkcs7-certreqresp\":[\"p7r\"],\"application/x-rar-compressed\":[\"*rar\"],\"application/x-redhat-package-manager\":[\"rpm\"],\"application/x-research-info-systems\":[\"ris\"],\"application/x-sea\":[\"sea\"],\"application/x-sh\":[\"sh\"],\"application/x-shar\":[\"shar\"],\"application/x-shockwave-flash\":[\"swf\"],\"application/x-silverlight-app\":[\"xap\"],\"application/x-sql\":[\"sql\"],\"application/x-stuffit\":[\"sit\"],\"application/x-stuffitx\":[\"sitx\"],\"application/x-subrip\":[\"srt\"],\"application/x-sv4cpio\":[\"sv4cpio\"],\"application/x-sv4crc\":[\"sv4crc\"],\"application/x-t3vm-image\":[\"t3\"],\"application/x-tads\":[\"gam\"],\"application/x-tar\":[\"tar\"],\"application/x-tcl\":[\"tcl\",\"tk\"],\"application/x-tex\":[\"tex\"],\"application/x-tex-tfm\":[\"tfm\"],\"application/x-texinfo\":[\"texinfo\",\"texi\"],\"application/x-tgif\":[\"*obj\"],\"application/x-ustar\":[\"ustar\"],\"application/x-virtualbox-hdd\":[\"hdd\"],\"application/x-virtualbox-ova\":[\"ova\"],\"application/x-virtualbox-ovf\":[\"ovf\"],\"application/x-virtualbox-vbox\":[\"vbox\"],\"application/x-virtualbox-vbox-extpack\":[\"vbox-extpack\"],\"application/x-virtualbox-vdi\":[\"vdi\"],\"application/x-virtualbox-vhd\":[\"vhd\"],\"application/x-virtualbox-vmdk\":[\"vmdk\"],\"application/x-wais-source\":[\"src\"],\"application/x-web-app-manifest+json\":[\"webapp\"],\"application/x-x509-ca-cert\":[\"der\",\"crt\",\"pem\"],\"application/x-xfig\":[\"fig\"],\"application/x-xliff+xml\":[\"*xlf\"],\"application/x-xpinstall\":[\"xpi\"],\"application/x-xz\":[\"xz\"],\"application/x-zmachine\":[\"z1\",\"z2\",\"z3\",\"z4\",\"z5\",\"z6\",\"z7\",\"z8\"],\"audio/vnd.dece.audio\":[\"uva\",\"uvva\"],\"audio/vnd.digital-winds\":[\"eol\"],\"audio/vnd.dra\":[\"dra\"],\"audio/vnd.dts\":[\"dts\"],\"audio/vnd.dts.hd\":[\"dtshd\"],\"audio/vnd.lucent.voice\":[\"lvp\"],\"audio/vnd.ms-playready.media.pya\":[\"pya\"],\"audio/vnd.nuera.ecelp4800\":[\"ecelp4800\"],\"audio/vnd.nuera.ecelp7470\":[\"ecelp7470\"],\"audio/vnd.nuera.ecelp9600\":[\"ecelp9600\"],\"audio/vnd.rip\":[\"rip\"],\"audio/x-aac\":[\"aac\"],\"audio/x-aiff\":[\"aif\",\"aiff\",\"aifc\"],\"audio/x-caf\":[\"caf\"],\"audio/x-flac\":[\"flac\"],\"audio/x-m4a\":[\"*m4a\"],\"audio/x-matroska\":[\"mka\"],\"audio/x-mpegurl\":[\"m3u\"],\"audio/x-ms-wax\":[\"wax\"],\"audio/x-ms-wma\":[\"wma\"],\"audio/x-pn-realaudio\":[\"ram\",\"ra\"],\"audio/x-pn-realaudio-plugin\":[\"rmp\"],\"audio/x-realaudio\":[\"*ra\"],\"audio/x-wav\":[\"*wav\"],\"chemical/x-cdx\":[\"cdx\"],\"chemical/x-cif\":[\"cif\"],\"chemical/x-cmdf\":[\"cmdf\"],\"chemical/x-cml\":[\"cml\"],\"chemical/x-csml\":[\"csml\"],\"chemical/x-xyz\":[\"xyz\"],\"image/prs.btif\":[\"btif\"],\"image/prs.pti\":[\"pti\"],\"image/vnd.adobe.photoshop\":[\"psd\"],\"image/vnd.airzip.accelerator.azv\":[\"azv\"],\"image/vnd.dece.graphic\":[\"uvi\",\"uvvi\",\"uvg\",\"uvvg\"],\"image/vnd.djvu\":[\"djvu\",\"djv\"],\"image/vnd.dvb.subtitle\":[\"*sub\"],\"image/vnd.dwg\":[\"dwg\"],\"image/vnd.dxf\":[\"dxf\"],\"image/vnd.fastbidsheet\":[\"fbs\"],\"image/vnd.fpx\":[\"fpx\"],\"image/vnd.fst\":[\"fst\"],\"image/vnd.fujixerox.edmics-mmr\":[\"mmr\"],\"image/vnd.fujixerox.edmics-rlc\":[\"rlc\"],\"image/vnd.microsoft.icon\":[\"ico\"],\"image/vnd.ms-dds\":[\"dds\"],\"image/vnd.ms-modi\":[\"mdi\"],\"image/vnd.ms-photo\":[\"wdp\"],\"image/vnd.net-fpx\":[\"npx\"],\"image/vnd.pco.b16\":[\"b16\"],\"image/vnd.tencent.tap\":[\"tap\"],\"image/vnd.valve.source.texture\":[\"vtf\"],\"image/vnd.wap.wbmp\":[\"wbmp\"],\"image/vnd.xiff\":[\"xif\"],\"image/vnd.zbrush.pcx\":[\"pcx\"],\"image/x-3ds\":[\"3ds\"],\"image/x-cmu-raster\":[\"ras\"],\"image/x-cmx\":[\"cmx\"],\"image/x-freehand\":[\"fh\",\"fhc\",\"fh4\",\"fh5\",\"fh7\"],\"image/x-icon\":[\"*ico\"],\"image/x-jng\":[\"jng\"],\"image/x-mrsid-image\":[\"sid\"],\"image/x-ms-bmp\":[\"*bmp\"],\"image/x-pcx\":[\"*pcx\"],\"image/x-pict\":[\"pic\",\"pct\"],\"image/x-portable-anymap\":[\"pnm\"],\"image/x-portable-bitmap\":[\"pbm\"],\"image/x-portable-graymap\":[\"pgm\"],\"image/x-portable-pixmap\":[\"ppm\"],\"image/x-rgb\":[\"rgb\"],\"image/x-tga\":[\"tga\"],\"image/x-xbitmap\":[\"xbm\"],\"image/x-xpixmap\":[\"xpm\"],\"image/x-xwindowdump\":[\"xwd\"],\"message/vnd.wfa.wsc\":[\"wsc\"],\"model/vnd.collada+xml\":[\"dae\"],\"model/vnd.dwf\":[\"dwf\"],\"model/vnd.gdl\":[\"gdl\"],\"model/vnd.gtw\":[\"gtw\"],\"model/vnd.mts\":[\"mts\"],\"model/vnd.opengex\":[\"ogex\"],\"model/vnd.parasolid.transmit.binary\":[\"x_b\"],\"model/vnd.parasolid.transmit.text\":[\"x_t\"],\"model/vnd.sap.vds\":[\"vds\"],\"model/vnd.usdz+zip\":[\"usdz\"],\"model/vnd.valve.source.compiled-map\":[\"bsp\"],\"model/vnd.vtu\":[\"vtu\"],\"text/prs.lines.tag\":[\"dsc\"],\"text/vnd.curl\":[\"curl\"],\"text/vnd.curl.dcurl\":[\"dcurl\"],\"text/vnd.curl.mcurl\":[\"mcurl\"],\"text/vnd.curl.scurl\":[\"scurl\"],\"text/vnd.dvb.subtitle\":[\"sub\"],\"text/vnd.fly\":[\"fly\"],\"text/vnd.fmi.flexstor\":[\"flx\"],\"text/vnd.graphviz\":[\"gv\"],\"text/vnd.in3d.3dml\":[\"3dml\"],\"text/vnd.in3d.spot\":[\"spot\"],\"text/vnd.sun.j2me.app-descriptor\":[\"jad\"],\"text/vnd.wap.wml\":[\"wml\"],\"text/vnd.wap.wmlscript\":[\"wmls\"],\"text/x-asm\":[\"s\",\"asm\"],\"text/x-c\":[\"c\",\"cc\",\"cxx\",\"cpp\",\"h\",\"hh\",\"dic\"],\"text/x-component\":[\"htc\"],\"text/x-fortran\":[\"f\",\"for\",\"f77\",\"f90\"],\"text/x-handlebars-template\":[\"hbs\"],\"text/x-java-source\":[\"java\"],\"text/x-lua\":[\"lua\"],\"text/x-markdown\":[\"mkd\"],\"text/x-nfo\":[\"nfo\"],\"text/x-opml\":[\"opml\"],\"text/x-org\":[\"*org\"],\"text/x-pascal\":[\"p\",\"pas\"],\"text/x-processing\":[\"pde\"],\"text/x-sass\":[\"sass\"],\"text/x-scss\":[\"scss\"],\"text/x-setext\":[\"etx\"],\"text/x-sfv\":[\"sfv\"],\"text/x-suse-ymp\":[\"ymp\"],\"text/x-uuencode\":[\"uu\"],\"text/x-vcalendar\":[\"vcs\"],\"text/x-vcard\":[\"vcf\"],\"video/vnd.dece.hd\":[\"uvh\",\"uvvh\"],\"video/vnd.dece.mobile\":[\"uvm\",\"uvvm\"],\"video/vnd.dece.pd\":[\"uvp\",\"uvvp\"],\"video/vnd.dece.sd\":[\"uvs\",\"uvvs\"],\"video/vnd.dece.video\":[\"uvv\",\"uvvv\"],\"video/vnd.dvb.file\":[\"dvb\"],\"video/vnd.fvt\":[\"fvt\"],\"video/vnd.mpegurl\":[\"mxu\",\"m4u\"],\"video/vnd.ms-playready.media.pyv\":[\"pyv\"],\"video/vnd.uvvu.mp4\":[\"uvu\",\"uvvu\"],\"video/vnd.vivo\":[\"viv\"],\"video/x-f4v\":[\"f4v\"],\"video/x-fli\":[\"fli\"],\"video/x-flv\":[\"flv\"],\"video/x-m4v\":[\"m4v\"],\"video/x-matroska\":[\"mkv\",\"mk3d\",\"mks\"],\"video/x-mng\":[\"mng\"],\"video/x-ms-asf\":[\"asf\",\"asx\"],\"video/x-ms-vob\":[\"vob\"],\"video/x-ms-wm\":[\"wm\"],\"video/x-ms-wmv\":[\"wmv\"],\"video/x-ms-wmx\":[\"wmx\"],\"video/x-ms-wvx\":[\"wvx\"],\"video/x-msvideo\":[\"avi\"],\"video/x-sgi-movie\":[\"movie\"],\"video/x-smv\":[\"smv\"],\"x-conference/x-cooltalk\":[\"ice\"]};", "'use strict';\n\nlet Mime = require('./Mime');\nmodule.exports = new Mime(require('./types/standard'), require('./types/other'));\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.InternalError = exports.NotFoundError = exports.MethodNotAllowedError = exports.KVError = void 0;\nclass KVError extends Error {\n    constructor(message, status = 500) {\n        super(message);\n        // see: typescriptlang.org/docs/handbook/release-notes/typescript-2-2.html\n        Object.setPrototypeOf(this, new.target.prototype); // restore prototype chain\n        this.name = KVError.name; // stack traces display correctly now\n        this.status = status;\n    }\n}\nexports.KVError = KVError;\nclass MethodNotAllowedError extends KVError {\n    constructor(message = `Not a valid request method`, status = 405) {\n        super(message, status);\n    }\n}\nexports.MethodNotAllowedError = MethodNotAllowedError;\nclass NotFoundError extends KVError {\n    constructor(message = `Not Found`, status = 404) {\n        super(message, status);\n    }\n}\nexports.NotFoundError = NotFoundError;\nclass InternalError extends KVError {\n    constructor(message = `Internal Error in KV Asset Handler`, status = 500) {\n        super(message, status);\n    }\n}\nexports.InternalError = InternalError;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.InternalError = exports.NotFoundError = exports.MethodNotAllowedError = exports.serveSinglePageApp = exports.mapRequestToAsset = exports.getAssetFromKV = void 0;\nconst mime = require(\"mime\");\nconst types_1 = require(\"./types\");\nObject.defineProperty(exports, \"MethodNotAllowedError\", { enumerable: true, get: function () { return types_1.MethodNotAllowedError; } });\nObject.defineProperty(exports, \"NotFoundError\", { enumerable: true, get: function () { return types_1.NotFoundError; } });\nObject.defineProperty(exports, \"InternalError\", { enumerable: true, get: function () { return types_1.InternalError; } });\nconst defaultCacheControl = {\n    browserTTL: null,\n    edgeTTL: 2 * 60 * 60 * 24, // 2 days\n    bypassCache: false, // do not bypass Cloudflare's cache\n};\nconst parseStringAsObject = (maybeString) => typeof maybeString === 'string' ? JSON.parse(maybeString) : maybeString;\nconst getAssetFromKVDefaultOptions = {\n    ASSET_NAMESPACE: typeof __STATIC_CONTENT !== 'undefined' ? __STATIC_CONTENT : undefined,\n    ASSET_MANIFEST: typeof __STATIC_CONTENT_MANIFEST !== 'undefined'\n        ? parseStringAsObject(__STATIC_CONTENT_MANIFEST)\n        : {},\n    cacheControl: defaultCacheControl,\n    defaultMimeType: 'text/plain',\n    defaultDocument: 'index.html',\n    pathIsEncoded: false,\n    defaultETag: 'strong',\n};\nfunction assignOptions(options) {\n    // Assign any missing options passed in to the default\n    // options.mapRequestToAsset is handled manually later\n    return Object.assign({}, getAssetFromKVDefaultOptions, options);\n}\n/**\n * maps the path of incoming request to the request pathKey to look up\n * in bucket and in cache\n * e.g.  for a path '/' returns '/index.html' which serves\n * the content of bucket/index.html\n * @param {Request} request incoming request\n */\nconst mapRequestToAsset = (request, options) => {\n    options = assignOptions(options);\n    const parsedUrl = new URL(request.url);\n    let pathname = parsedUrl.pathname;\n    if (pathname.endsWith('/')) {\n        // If path looks like a directory append options.defaultDocument\n        // e.g. If path is /about/ -> /about/index.html\n        pathname = pathname.concat(options.defaultDocument);\n    }\n    else if (!mime.getType(pathname)) {\n        // If path doesn't look like valid content\n        //  e.g. /about.me ->  /about.me/index.html\n        pathname = pathname.concat('/' + options.defaultDocument);\n    }\n    parsedUrl.pathname = pathname;\n    return new Request(parsedUrl.toString(), request);\n};\nexports.mapRequestToAsset = mapRequestToAsset;\n/**\n * maps the path of incoming request to /index.html if it evaluates to\n * any HTML file.\n * @param {Request} request incoming request\n */\nfunction serveSinglePageApp(request, options) {\n    options = assignOptions(options);\n    // First apply the default handler, which already has logic to detect\n    // paths that should map to HTML files.\n    request = mapRequestToAsset(request, options);\n    const parsedUrl = new URL(request.url);\n    // Detect if the default handler decided to map to\n    // a HTML file in some specific directory.\n    if (parsedUrl.pathname.endsWith('.html')) {\n        // If expected HTML file was missing, just return the root index.html (or options.defaultDocument)\n        return new Request(`${parsedUrl.origin}/${options.defaultDocument}`, request);\n    }\n    else {\n        // The default handler decided this is not an HTML page. It's probably\n        // an image, CSS, or JS file. Leave it as-is.\n        return request;\n    }\n}\nexports.serveSinglePageApp = serveSinglePageApp;\nconst getAssetFromKV = async (event, options) => {\n    options = assignOptions(options);\n    const request = event.request;\n    const ASSET_NAMESPACE = options.ASSET_NAMESPACE;\n    const ASSET_MANIFEST = parseStringAsObject(options.ASSET_MANIFEST);\n    if (typeof ASSET_NAMESPACE === 'undefined') {\n        throw new types_1.InternalError(`there is no KV namespace bound to the script`);\n    }\n    const rawPathKey = new URL(request.url).pathname.replace(/^\\/+/, ''); // strip any preceding /'s\n    let pathIsEncoded = options.pathIsEncoded;\n    let requestKey;\n    // if options.mapRequestToAsset is explicitly passed in, always use it and assume user has own intentions\n    // otherwise handle request as normal, with default mapRequestToAsset below\n    if (options.mapRequestToAsset) {\n        requestKey = options.mapRequestToAsset(request);\n    }\n    else if (ASSET_MANIFEST[rawPathKey]) {\n        requestKey = request;\n    }\n    else if (ASSET_MANIFEST[decodeURIComponent(rawPathKey)]) {\n        pathIsEncoded = true;\n        requestKey = request;\n    }\n    else {\n        const mappedRequest = mapRequestToAsset(request);\n        const mappedRawPathKey = new URL(mappedRequest.url).pathname.replace(/^\\/+/, '');\n        if (ASSET_MANIFEST[decodeURIComponent(mappedRawPathKey)]) {\n            pathIsEncoded = true;\n            requestKey = mappedRequest;\n        }\n        else {\n            // use default mapRequestToAsset\n            requestKey = mapRequestToAsset(request, options);\n        }\n    }\n    const SUPPORTED_METHODS = ['GET', 'HEAD'];\n    if (!SUPPORTED_METHODS.includes(requestKey.method)) {\n        throw new types_1.MethodNotAllowedError(`${requestKey.method} is not a valid request method`);\n    }\n    const parsedUrl = new URL(requestKey.url);\n    const pathname = pathIsEncoded ? decodeURIComponent(parsedUrl.pathname) : parsedUrl.pathname; // decode percentage encoded path only when necessary\n    // pathKey is the file path to look up in the manifest\n    let pathKey = pathname.replace(/^\\/+/, ''); // remove prepended /\n    // @ts-ignore\n    const cache = caches.default;\n    let mimeType = mime.getType(pathKey) || options.defaultMimeType;\n    if (mimeType.startsWith('text') || mimeType === 'application/javascript') {\n        mimeType += '; charset=utf-8';\n    }\n    let shouldEdgeCache = false; // false if storing in KV by raw file path i.e. no hash\n    // check manifest for map from file path to hash\n    if (typeof ASSET_MANIFEST !== 'undefined') {\n        if (ASSET_MANIFEST[pathKey]) {\n            pathKey = ASSET_MANIFEST[pathKey];\n            // if path key is in asset manifest, we can assume it contains a content hash and can be cached\n            shouldEdgeCache = true;\n        }\n    }\n    // TODO this excludes search params from cache, investigate ideal behavior\n    let cacheKey = new Request(`${parsedUrl.origin}/${pathKey}`, request);\n    // if argument passed in for cacheControl is a function then\n    // evaluate that function. otherwise return the Object passed in\n    // or default Object\n    const evalCacheOpts = (() => {\n        switch (typeof options.cacheControl) {\n            case 'function':\n                return options.cacheControl(request);\n            case 'object':\n                return options.cacheControl;\n            default:\n                return defaultCacheControl;\n        }\n    })();\n    // formats the etag depending on the response context. if the entityId\n    // is invalid, returns an empty string (instead of null) to prevent the\n    // the potentially disastrous scenario where the value of the Etag resp\n    // header is \"null\". Could be modified in future to base64 encode etc\n    const formatETag = (entityId = pathKey, validatorType = options.defaultETag) => {\n        if (!entityId) {\n            return '';\n        }\n        switch (validatorType) {\n            case 'weak':\n                if (!entityId.startsWith('W/')) {\n                    if (entityId.startsWith(`\"`) && entityId.endsWith(`\"`)) {\n                        return `W/${entityId}`;\n                    }\n                    return `W/\"${entityId}\"`;\n                }\n                return entityId;\n            case 'strong':\n                if (entityId.startsWith(`W/\"`)) {\n                    entityId = entityId.replace('W/', '');\n                }\n                if (!entityId.endsWith(`\"`)) {\n                    entityId = `\"${entityId}\"`;\n                }\n                return entityId;\n            default:\n                return '';\n        }\n    };\n    options.cacheControl = Object.assign({}, defaultCacheControl, evalCacheOpts);\n    // override shouldEdgeCache if options say to bypassCache\n    if (options.cacheControl.bypassCache ||\n        options.cacheControl.edgeTTL === null ||\n        request.method == 'HEAD') {\n        shouldEdgeCache = false;\n    }\n    // only set max-age if explicitly passed in a number as an arg\n    const shouldSetBrowserCache = typeof options.cacheControl.browserTTL === 'number';\n    let response = null;\n    if (shouldEdgeCache) {\n        response = await cache.match(cacheKey);\n    }\n    if (response) {\n        if (response.status > 300 && response.status < 400) {\n            if (response.body && 'cancel' in Object.getPrototypeOf(response.body)) {\n                // Body exists and environment supports readable streams\n                response.body.cancel();\n            }\n            else {\n                // Environment doesnt support readable streams, or null repsonse body. Nothing to do\n            }\n            response = new Response(null, response);\n        }\n        else {\n            // fixes #165\n            let opts = {\n                headers: new Headers(response.headers),\n                status: 0,\n                statusText: '',\n            };\n            opts.headers.set('cf-cache-status', 'HIT');\n            if (response.status) {\n                opts.status = response.status;\n                opts.statusText = response.statusText;\n            }\n            else if (opts.headers.has('Content-Range')) {\n                opts.status = 206;\n                opts.statusText = 'Partial Content';\n            }\n            else {\n                opts.status = 200;\n                opts.statusText = 'OK';\n            }\n            response = new Response(response.body, opts);\n        }\n    }\n    else {\n        const body = await ASSET_NAMESPACE.get(pathKey, 'arrayBuffer');\n        if (body === null) {\n            throw new types_1.NotFoundError(`could not find ${pathKey} in your content namespace`);\n        }\n        response = new Response(body);\n        if (shouldEdgeCache) {\n            response.headers.set('Accept-Ranges', 'bytes');\n            response.headers.set('Content-Length', String(body.byteLength));\n            // set etag before cache insertion\n            if (!response.headers.has('etag')) {\n                response.headers.set('etag', formatETag(pathKey));\n            }\n            // determine Cloudflare cache behavior\n            response.headers.set('Cache-Control', `max-age=${options.cacheControl.edgeTTL}`);\n            event.waitUntil(cache.put(cacheKey, response.clone()));\n            response.headers.set('CF-Cache-Status', 'MISS');\n        }\n    }\n    response.headers.set('Content-Type', mimeType);\n    if (response.status === 304) {\n        let etag = formatETag(response.headers.get('etag'));\n        let ifNoneMatch = cacheKey.headers.get('if-none-match');\n        let proxyCacheStatus = response.headers.get('CF-Cache-Status');\n        if (etag) {\n            if (ifNoneMatch && ifNoneMatch === etag && proxyCacheStatus === 'MISS') {\n                response.headers.set('CF-Cache-Status', 'EXPIRED');\n            }\n            else {\n                response.headers.set('CF-Cache-Status', 'REVALIDATED');\n            }\n            response.headers.set('etag', formatETag(etag, 'weak'));\n        }\n    }\n    if (shouldSetBrowserCache) {\n        response.headers.set('Cache-Control', `max-age=${options.cacheControl.browserTTL}`);\n    }\n    else {\n        response.headers.delete('Cache-Control');\n    }\n    return response;\n};\nexports.getAssetFromKV = getAssetFromKV;\n", "// // This loads all middlewares exposed on the middleware object\n// // and then starts the invocation chain.\n// // The big idea is that we can add these to the middleware export dynamically\n// // through wrangler, or we can potentially let users directly add them as a sort\n// // of \"plugin\" system.\n\nimport worker from \"/home/runmy/Desktop/clarance/.wrangler/tmp/bundle-76pCT6/middleware-insertion-facade.js\";\nimport {\n\t__facade_invoke__,\n\t__facade_register__,\n\tDispatcher,\n\tMiddleware,\n} from \"/home/runmy/Desktop/clarance/node_modules/wrangler/templates/middleware/common.ts\";\n\n// We need to preserve all of the exports from the worker\nexport * from \"/home/runmy/Desktop/clarance/.wrangler/tmp/bundle-76pCT6/middleware-insertion-facade.js\";\n\nclass __Facade_ScheduledController__ implements ScheduledController {\n\t#noRetry: ScheduledController[\"noRetry\"];\n\n\tconstructor(\n\t\treadonly scheduledTime: number,\n\t\treadonly cron: string,\n\t\tnoRetry: ScheduledController[\"noRetry\"]\n\t) {\n\t\tthis.#noRetry = noRetry;\n\t}\n\n\tnoRetry() {\n\t\tif (!(this instanceof __Facade_ScheduledController__)) {\n\t\t\tthrow new TypeError(\"Illegal invocation\");\n\t\t}\n\t\t// Need to call native method immediately in case uncaught error thrown\n\t\tthis.#noRetry();\n\t}\n}\n\nconst __facade_modules_fetch__: ExportedHandlerFetchHandler = function (\n\trequest,\n\tenv,\n\tctx\n) {\n\tif (worker.fetch === undefined)\n\t\tthrow new Error(\"Handler does not export a fetch() function.\");\n\treturn worker.fetch(request, env, ctx);\n};\n\nfunction getMaskedEnv(rawEnv: unknown) {\n\tlet env = rawEnv as Record<string, unknown>;\n\tif (worker.envWrappers && worker.envWrappers.length > 0) {\n\t\tfor (const wrapFn of worker.envWrappers) {\n\t\t\tenv = wrapFn(env);\n\t\t}\n\t}\n\treturn env;\n}\n\n/**\n * This type is here to cause a type error if a new export handler is added to\n * `ExportHandler` without it being included in the `facade` below.\n */\ntype MissingExportHandlers = Omit<\n\tRequired<ExportedHandler>,\n\t\"tail\" | \"trace\" | \"scheduled\" | \"queue\" | \"test\" | \"email\" | \"fetch\"\n>;\n\nlet registeredMiddleware = false;\n\nconst facade: ExportedHandler<unknown> & MissingExportHandlers = {\n\t...(worker.tail && {\n\t\ttail: maskHandlerEnv(worker.tail),\n\t}),\n\t...(worker.trace && {\n\t\ttrace: maskHandlerEnv(worker.trace),\n\t}),\n\t...(worker.scheduled && {\n\t\tscheduled: maskHandlerEnv(worker.scheduled),\n\t}),\n\t...(worker.queue && {\n\t\tqueue: maskHandlerEnv(worker.queue),\n\t}),\n\t...(worker.test && {\n\t\ttest: maskHandlerEnv(worker.test),\n\t}),\n\t...(worker.email && {\n\t\temail: maskHandlerEnv(worker.email),\n\t}),\n\n\tfetch(request, rawEnv, ctx) {\n\t\tconst env = getMaskedEnv(rawEnv);\n\t\t// Get the chain of middleware from the worker object\n\t\tif (worker.middleware && worker.middleware.length > 0) {\n\t\t\t// Make sure we only register middleware once:\n\t\t\t// https://github.com/cloudflare/workers-sdk/issues/2386#issuecomment-1614715911\n\t\t\tif (!registeredMiddleware) {\n\t\t\t\tregisteredMiddleware = true;\n\t\t\t\tfor (const middleware of worker.middleware) {\n\t\t\t\t\t__facade_register__(middleware);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst __facade_modules_dispatch__: Dispatcher = function (type, init) {\n\t\t\t\tif (type === \"scheduled\" && worker.scheduled !== undefined) {\n\t\t\t\t\tconst controller = new __Facade_ScheduledController__(\n\t\t\t\t\t\tDate.now(),\n\t\t\t\t\t\tinit.cron ?? \"\",\n\t\t\t\t\t\t() => {}\n\t\t\t\t\t);\n\t\t\t\t\treturn worker.scheduled(controller, env, ctx);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\treturn __facade_invoke__(\n\t\t\t\trequest,\n\t\t\t\tenv,\n\t\t\t\tctx,\n\t\t\t\t__facade_modules_dispatch__,\n\t\t\t\t__facade_modules_fetch__\n\t\t\t);\n\t\t} else {\n\t\t\t// We didn't have any middleware so we can skip the invocation chain,\n\t\t\t// and just call the fetch handler directly\n\n\t\t\t// We \"don't care\" if this is undefined as we want to have the same behavior\n\t\t\t// as if the worker completely bypassed middleware.\n\t\t\treturn __facade_modules_fetch__(request, env, ctx);\n\t\t}\n\t},\n};\n\ntype HandlerFn<D, R> = (data: D, env: unknown, ctx: ExecutionContext) => R;\nfunction maskHandlerEnv<D, R>(handler: HandlerFn<D, R>): HandlerFn<D, R> {\n\treturn (data, env, ctx) => handler(data, getMaskedEnv(env), ctx);\n}\n\nexport default facade;\n", "\t\t\t\timport worker, * as OTHER_EXPORTS from \"/home/runmy/Desktop/clarance/.wrangler/tmp/pages-kK9EY1/0lvhg0r4174b.js\";\n\t\t\t\timport * as __MIDDLEWARE_0__ from \"/home/runmy/Desktop/clarance/node_modules/wrangler/templates/middleware/middleware-miniflare3-json-error.ts\";\nimport * as __MIDDLEWARE_1__ from \"/home/runmy/Desktop/clarance/node_modules/wrangler/templates/middleware/middleware-serve-static-assets.ts\";\n\t\t\t\tconst envWrappers = [__MIDDLEWARE_0__.wrap,__MIDDLEWARE_1__.wrap].filter(Boolean);\n\t\t\t\tconst facade = {\n\t\t\t\t\t...worker,\n\t\t\t\t\tenvWrappers,\n\t\t\t\t\tmiddleware: [\n\t\t\t\t\t\t__MIDDLEWARE_0__.default,__MIDDLEWARE_1__.default,\n            ...(worker.middleware ? worker.middleware : []),\n\t\t\t\t\t].filter(Boolean)\n\t\t\t\t}\n\t\t\t\texport * from \"/home/runmy/Desktop/clarance/.wrangler/tmp/pages-kK9EY1/0lvhg0r4174b.js\";\n\n\t\t\t\tconst maskDurableObjectDefinition = (cls) =>\n\t\t\t\t\tclass extends cls {\n\t\t\t\t\t\tconstructor(state, env) {\n\t\t\t\t\t\t\tlet wrappedEnv = env\n\t\t\t\t\t\t\tfor (const wrapFn of envWrappers) {\n\t\t\t\t\t\t\t\twrappedEnv = wrapFn(wrappedEnv)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsuper(state, wrappedEnv);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\n\n\t\t\t\texport default facade;", "const urls = new Set();\n\nfunction checkURL(request, init) {\n\tconst url =\n\t\trequest instanceof URL\n\t\t\t? request\n\t\t\t: new URL(\n\t\t\t\t\t(typeof request === \"string\"\n\t\t\t\t\t\t? new Request(request, init)\n\t\t\t\t\t\t: request\n\t\t\t\t\t).url\n\t\t\t  );\n\tif (url.port && url.port !== \"443\" && url.protocol === \"https:\") {\n\t\tif (!urls.has(url.toString())) {\n\t\t\turls.add(url.toString());\n\t\t\tconsole.warn(\n\t\t\t\t`WARNING: known issue with \\`fetch()\\` requests to custom HTTPS ports in published Workers:\\n` +\n\t\t\t\t\t` - ${url.toString()} - the custom port will be ignored when the Worker is published using the \\`wrangler deploy\\` command.\\n`\n\t\t\t);\n\t\t}\n\t}\n}\n\nglobalThis.fetch = new Proxy(globalThis.fetch, {\n\tapply(target, thisArg, argArray) {\n\t\tconst [request, init] = argArray;\n\t\tcheckURL(request, init);\n\t\treturn Reflect.apply(target, thisArg, argArray);\n\t},\n});\n", "", "// `esbuild` doesn't support returning `watch*` options from `onStart()`\n// plugin callbacks. Instead, we define an empty virtual module that is\n// imported by this injected file. Importing the module registers watchers.\nimport \"wrangler:modules-watch\";\n", "interface Env {\n\tKV: KVNamespace;\n}\n\nexport const onRequest: PagesFunction<Env> = async (context) => {\n\tconst value = await context.env.KV.get('example');\n \treturn new Response(value);\n}", "import { Identity } from \"..\";\n\nexport const getIdentity = async ({\n  jwt,\n  domain,\n}: {\n  jwt: string;\n  domain: string;\n}): Promise<undefined | Identity> => {\n  const identityURL = new URL(\"/cdn-cgi/access/get-identity\", domain);\n  const response = await fetch(identityURL.toString(), {\n    headers: { Cookie: `CF_Authorization=${jwt}` },\n  });\n  if (response.ok) return await response.json();\n};\n\nexport const generateLoginURL = ({\n  redirectURL: redirectURLInit,\n  domain,\n  aud,\n}: {\n  redirectURL: string | URL;\n  domain: string;\n  aud: string;\n}): string => {\n  const redirectURL =\n    typeof redirectURLInit === \"string\"\n      ? new URL(redirectURLInit)\n      : redirectURLInit;\n  const { hostname } = redirectURL;\n  const loginPathname = `/cdn-cgi/access/login/${hostname}?`;\n  const searchParams = new URLSearchParams({\n    kid: aud,\n    redirect_url: redirectURL.pathname + redirectURL.search,\n  });\n  return new URL(loginPathname + searchParams.toString(), domain).toString();\n};\n\nexport const generateLogoutURL = ({ domain }: { domain: string }) =>\n  new URL(`/cdn-cgi/access/logout`, domain).toString();\n", "import { generateLoginURL } from \"@cloudflare/pages-plugin-cloudflare-access/api\";\n\nexport const onRequest = () => {\n  const loginURL = generateLoginURL({\n    redirectURL: \"https://example.com/greet\",\n    domain: \"https://test.cloudflareaccess.com\",\n    aud: \"4714c1358e65fe4b408ad6d432a5f878f08194bdb4752441fd56faefa9b2b6f2\",\n  });\n\n  return new Response(null, {\n    status: 302,\n    headers: { Location: loginURL },\n  });\n};", "import { generateLogoutURL } from \"@cloudflare/pages-plugin-cloudflare-access/api\";\n\nexport const onRequest = () =>\n  new Response(null, {\n    status: 302,\n    headers: {\n      Location: generateLogoutURL({\n        domain: \"https://test.cloudflareaccess.com\",\n      }),\n    },\n  });", "/*!\n * cookie\n * Copyright(c) 2012-2014 Roman Shtylman\n * Copyright(c) 2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Module exports.\n * @public\n */\n\nexports.parse = parse;\nexports.serialize = serialize;\n\n/**\n * Module variables.\n * @private\n */\n\nvar __toString = Object.prototype.toString\n\n/**\n * RegExp to match field-content in RFC 7230 sec 3.2\n *\n * field-content = field-vchar [ 1*( SP / HTAB ) field-vchar ]\n * field-vchar   = VCHAR / obs-text\n * obs-text      = %x80-FF\n */\n\nvar fieldContentRegExp = /^[\\u0009\\u0020-\\u007e\\u0080-\\u00ff]+$/;\n\n/**\n * Parse a cookie header.\n *\n * Parse the given cookie header string into an object\n * The object has the various cookies as keys(names) => values\n *\n * @param {string} str\n * @param {object} [options]\n * @return {object}\n * @public\n */\n\nfunction parse(str, options) {\n  if (typeof str !== 'string') {\n    throw new TypeError('argument str must be a string');\n  }\n\n  var obj = {}\n  var opt = options || {};\n  var dec = opt.decode || decode;\n\n  var index = 0\n  while (index < str.length) {\n    var eqIdx = str.indexOf('=', index)\n\n    // no more cookie pairs\n    if (eqIdx === -1) {\n      break\n    }\n\n    var endIdx = str.indexOf(';', index)\n\n    if (endIdx === -1) {\n      endIdx = str.length\n    } else if (endIdx < eqIdx) {\n      // backtrack on prior semicolon\n      index = str.lastIndexOf(';', eqIdx - 1) + 1\n      continue\n    }\n\n    var key = str.slice(index, eqIdx).trim()\n\n    // only assign once\n    if (undefined === obj[key]) {\n      var val = str.slice(eqIdx + 1, endIdx).trim()\n\n      // quoted values\n      if (val.charCodeAt(0) === 0x22) {\n        val = val.slice(1, -1)\n      }\n\n      obj[key] = tryDecode(val, dec);\n    }\n\n    index = endIdx + 1\n  }\n\n  return obj;\n}\n\n/**\n * Serialize data into a cookie header.\n *\n * Serialize the a name value pair into a cookie string suitable for\n * http headers. An optional options object specified cookie parameters.\n *\n * serialize('foo', 'bar', { httpOnly: true })\n *   => \"foo=bar; httpOnly\"\n *\n * @param {string} name\n * @param {string} val\n * @param {object} [options]\n * @return {string}\n * @public\n */\n\nfunction serialize(name, val, options) {\n  var opt = options || {};\n  var enc = opt.encode || encode;\n\n  if (typeof enc !== 'function') {\n    throw new TypeError('option encode is invalid');\n  }\n\n  if (!fieldContentRegExp.test(name)) {\n    throw new TypeError('argument name is invalid');\n  }\n\n  var value = enc(val);\n\n  if (value && !fieldContentRegExp.test(value)) {\n    throw new TypeError('argument val is invalid');\n  }\n\n  var str = name + '=' + value;\n\n  if (null != opt.maxAge) {\n    var maxAge = opt.maxAge - 0;\n\n    if (isNaN(maxAge) || !isFinite(maxAge)) {\n      throw new TypeError('option maxAge is invalid')\n    }\n\n    str += '; Max-Age=' + Math.floor(maxAge);\n  }\n\n  if (opt.domain) {\n    if (!fieldContentRegExp.test(opt.domain)) {\n      throw new TypeError('option domain is invalid');\n    }\n\n    str += '; Domain=' + opt.domain;\n  }\n\n  if (opt.path) {\n    if (!fieldContentRegExp.test(opt.path)) {\n      throw new TypeError('option path is invalid');\n    }\n\n    str += '; Path=' + opt.path;\n  }\n\n  if (opt.expires) {\n    var expires = opt.expires\n\n    if (!isDate(expires) || isNaN(expires.valueOf())) {\n      throw new TypeError('option expires is invalid');\n    }\n\n    str += '; Expires=' + expires.toUTCString()\n  }\n\n  if (opt.httpOnly) {\n    str += '; HttpOnly';\n  }\n\n  if (opt.secure) {\n    str += '; Secure';\n  }\n\n  if (opt.priority) {\n    var priority = typeof opt.priority === 'string'\n      ? opt.priority.toLowerCase()\n      : opt.priority\n\n    switch (priority) {\n      case 'low':\n        str += '; Priority=Low'\n        break\n      case 'medium':\n        str += '; Priority=Medium'\n        break\n      case 'high':\n        str += '; Priority=High'\n        break\n      default:\n        throw new TypeError('option priority is invalid')\n    }\n  }\n\n  if (opt.sameSite) {\n    var sameSite = typeof opt.sameSite === 'string'\n      ? opt.sameSite.toLowerCase() : opt.sameSite;\n\n    switch (sameSite) {\n      case true:\n        str += '; SameSite=Strict';\n        break;\n      case 'lax':\n        str += '; SameSite=Lax';\n        break;\n      case 'strict':\n        str += '; SameSite=Strict';\n        break;\n      case 'none':\n        str += '; SameSite=None';\n        break;\n      default:\n        throw new TypeError('option sameSite is invalid');\n    }\n  }\n\n  return str;\n}\n\n/**\n * URL-decode string value. Optimized to skip native call when no %.\n *\n * @param {string} str\n * @returns {string}\n */\n\nfunction decode (str) {\n  return str.indexOf('%') !== -1\n    ? decodeURIComponent(str)\n    : str\n}\n\n/**\n * URL-encode value.\n *\n * @param {string} str\n * @returns {string}\n */\n\nfunction encode (val) {\n  return encodeURIComponent(val)\n}\n\n/**\n * Determine if value is a Date.\n *\n * @param {*} val\n * @private\n */\n\nfunction isDate (val) {\n  return __toString.call(val) === '[object Date]' ||\n    val instanceof Date\n}\n\n/**\n * Try decoding a string using a decoding function.\n *\n * @param {string} str\n * @param {function} decode\n * @private\n */\n\nfunction tryDecode(str, decode) {\n  try {\n    return decode(str);\n  } catch (e) {\n    return str;\n  }\n}\n", "/**\n * @remix-run/server-runtime v2.4.1\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst alreadyWarned = {};\nfunction warnOnce(condition, message) {\n  if (!condition && !alreadyWarned[message]) {\n    alreadyWarned[message] = true;\n    console.warn(message);\n  }\n}\n\nexports.warnOnce = warnOnce;\n", "/**\n * @remix-run/server-runtime v2.4.1\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar cookie = require('cookie');\nvar warnings = require('./warnings.js');\n\n/**\n * A HTTP cookie.\n *\n * A Cookie is a logical container for metadata about a HTTP cookie; its name\n * and options. But it doesn't contain a value. Instead, it has `parse()` and\n * `serialize()` methods that allow a single instance to be reused for\n * parsing/encoding multiple different values.\n *\n * @see https://remix.run/utils/cookies#cookie-api\n */\n\n/**\n * Creates a logical container for managing a browser cookie from the server.\n *\n * @see https://remix.run/utils/cookies#createcookie\n */\nconst createCookieFactory = ({\n  sign,\n  unsign\n}) => (name, cookieOptions = {}) => {\n  let {\n    secrets = [],\n    ...options\n  } = {\n    path: \"/\",\n    sameSite: \"lax\",\n    ...cookieOptions\n  };\n  warnOnceAboutExpiresCookie(name, options.expires);\n  return {\n    get name() {\n      return name;\n    },\n    get isSigned() {\n      return secrets.length > 0;\n    },\n    get expires() {\n      // Max-Age takes precedence over Expires\n      return typeof options.maxAge !== \"undefined\" ? new Date(Date.now() + options.maxAge * 1000) : options.expires;\n    },\n    async parse(cookieHeader, parseOptions) {\n      if (!cookieHeader) return null;\n      let cookies = cookie.parse(cookieHeader, {\n        ...options,\n        ...parseOptions\n      });\n      return name in cookies ? cookies[name] === \"\" ? \"\" : await decodeCookieValue(unsign, cookies[name], secrets) : null;\n    },\n    async serialize(value, serializeOptions) {\n      return cookie.serialize(name, value === \"\" ? \"\" : await encodeCookieValue(sign, value, secrets), {\n        ...options,\n        ...serializeOptions\n      });\n    }\n  };\n};\n/**\n * Returns true if an object is a Remix cookie container.\n *\n * @see https://remix.run/utils/cookies#iscookie\n */\nconst isCookie = object => {\n  return object != null && typeof object.name === \"string\" && typeof object.isSigned === \"boolean\" && typeof object.parse === \"function\" && typeof object.serialize === \"function\";\n};\nasync function encodeCookieValue(sign, value, secrets) {\n  let encoded = encodeData(value);\n  if (secrets.length > 0) {\n    encoded = await sign(encoded, secrets[0]);\n  }\n  return encoded;\n}\nasync function decodeCookieValue(unsign, value, secrets) {\n  if (secrets.length > 0) {\n    for (let secret of secrets) {\n      let unsignedValue = await unsign(value, secret);\n      if (unsignedValue !== false) {\n        return decodeData(unsignedValue);\n      }\n    }\n    return null;\n  }\n  return decodeData(value);\n}\nfunction encodeData(value) {\n  return btoa(myUnescape(encodeURIComponent(JSON.stringify(value))));\n}\nfunction decodeData(value) {\n  try {\n    return JSON.parse(decodeURIComponent(myEscape(atob(value))));\n  } catch (error) {\n    return {};\n  }\n}\n\n// See: https://github.com/zloirock/core-js/blob/master/packages/core-js/modules/es.escape.js\nfunction myEscape(value) {\n  let str = value.toString();\n  let result = \"\";\n  let index = 0;\n  let chr, code;\n  while (index < str.length) {\n    chr = str.charAt(index++);\n    if (/[\\w*+\\-./@]/.exec(chr)) {\n      result += chr;\n    } else {\n      code = chr.charCodeAt(0);\n      if (code < 256) {\n        result += \"%\" + hex(code, 2);\n      } else {\n        result += \"%u\" + hex(code, 4).toUpperCase();\n      }\n    }\n  }\n  return result;\n}\nfunction hex(code, length) {\n  let result = code.toString(16);\n  while (result.length < length) result = \"0\" + result;\n  return result;\n}\n\n// See: https://github.com/zloirock/core-js/blob/master/packages/core-js/modules/es.unescape.js\nfunction myUnescape(value) {\n  let str = value.toString();\n  let result = \"\";\n  let index = 0;\n  let chr, part;\n  while (index < str.length) {\n    chr = str.charAt(index++);\n    if (chr === \"%\") {\n      if (str.charAt(index) === \"u\") {\n        part = str.slice(index + 1, index + 5);\n        if (/^[\\da-f]{4}$/i.exec(part)) {\n          result += String.fromCharCode(parseInt(part, 16));\n          index += 5;\n          continue;\n        }\n      } else {\n        part = str.slice(index, index + 2);\n        if (/^[\\da-f]{2}$/i.exec(part)) {\n          result += String.fromCharCode(parseInt(part, 16));\n          index += 2;\n          continue;\n        }\n      }\n    }\n    result += chr;\n  }\n  return result;\n}\nfunction warnOnceAboutExpiresCookie(name, expires) {\n  warnings.warnOnce(!expires, `The \"${name}\" cookie has an \"expires\" property set. ` + `This will cause the expires value to not be updated when the session is committed. ` + `Instead, you should set the expires value when serializing the cookie. ` + `You can use \\`commitSession(session, { expires })\\` if using a session storage object, ` + `or \\`cookie.serialize(\"value\", { expires })\\` if you're using the cookie directly.`);\n}\n\nexports.createCookieFactory = createCookieFactory;\nexports.isCookie = isCookie;\n", "export function stringToArray(s) {\n  const utf8 = unescape(encodeURIComponent(s));\n  return Uint8Array.from(utf8, (_, i) => utf8.charCodeAt(i));\n}\nexport function arrayToString(a) {\n  const utf8 = String.fromCharCode.apply(null, a);\n  return decodeURIComponent(escape(utf8));\n}\nexport function mergeArrays(...arrays) {\n  const out = new Uint8Array(arrays.reduce((total, arr) => total + arr.length, 0));\n  let offset = 0;\n  for (const arr of arrays) {\n    out.set(arr, offset);\n    offset += arr.length;\n  }\n  return out;\n}\nexport function arraysEqual(a, b) {\n  if (a.length !== b.length) {\n    return false;\n  }\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n  return true;\n}", "import {\n  stringToArray,\n  mergeArrays,\n  arrayToString\n} from './utils.js';\nfunction coerce(a) {\n  if (a instanceof Uint8Array) {\n    return index => a[index];\n  }\n  return a;\n}\nfunction jsmemcmp(buf1, pos1, buf2, pos2, len) {\n  const fn1 = coerce(buf1);\n  const fn2 = coerce(buf2);\n  for (let i = 0; i < len; ++i) {\n    if (fn1(pos1 + i) !== fn2(pos2 + i)) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction createOccurenceTable(s) {\n  const table = new Array(256).fill(s.length);\n  if (s.length > 1) {\n    for (let i = 0; i < s.length - 1; i++) {\n      table[s[i]] = s.length - 1 - i;\n    }\n  }\n  return table;\n}\nconst MATCH = Symbol('Match');\nclass StreamSearch {\n  constructor(needle) {\n    this._lookbehind = new Uint8Array();\n    if (typeof needle === 'string') {\n      this._needle = needle = stringToArray(needle);\n    } else {\n      this._needle = needle;\n    }\n    this._lastChar = needle[needle.length - 1];\n    this._occ = createOccurenceTable(needle);\n  }\n  feed(chunk) {\n    let pos = 0;\n    let tokens;\n    const allTokens = [];\n    while (pos !== chunk.length) {\n      ;\n      [pos, ...tokens] = this._feed(chunk, pos);\n      allTokens.push(...tokens);\n    }\n    return allTokens;\n  }\n  end() {\n    const tail = this._lookbehind;\n    this._lookbehind = new Uint8Array();\n    return tail;\n  }\n  _feed(data, bufPos) {\n    const tokens = [];\n    let pos = -this._lookbehind.length;\n    if (pos < 0) {\n      while (pos < 0 && pos <= data.length - this._needle.length) {\n        const ch = this._charAt(data, pos + this._needle.length - 1);\n        if (ch === this._lastChar && this._memcmp(data, pos, this._needle.length - 1)) {\n          if (pos > -this._lookbehind.length) {\n            tokens.push(this._lookbehind.slice(0, this._lookbehind.length + pos));\n          }\n          tokens.push(MATCH);\n          this._lookbehind = new Uint8Array();\n          return [\n            pos + this._needle.length,\n            ...tokens\n          ];\n        } else {\n          pos += this._occ[ch];\n        }\n      }\n      if (pos < 0) {\n        while (pos < 0 && !this._memcmp(data, pos, data.length - pos)) {\n          pos++;\n        }\n      }\n      if (pos >= 0) {\n        tokens.push(this._lookbehind);\n        this._lookbehind = new Uint8Array();\n      } else {\n        const bytesToCutOff = this._lookbehind.length + pos;\n        if (bytesToCutOff > 0) {\n          tokens.push(this._lookbehind.slice(0, bytesToCutOff));\n          this._lookbehind = this._lookbehind.slice(bytesToCutOff);\n        }\n        this._lookbehind = Uint8Array.from(new Array(this._lookbehind.length + data.length), (_, i) => this._charAt(data, i - this._lookbehind.length));\n        return [\n          data.length,\n          ...tokens\n        ];\n      }\n    }\n    pos += bufPos;\n    while (pos <= data.length - this._needle.length) {\n      const ch = data[pos + this._needle.length - 1];\n      if (ch === this._lastChar && data[pos] === this._needle[0] && jsmemcmp(this._needle, 0, data, pos, this._needle.length - 1)) {\n        if (pos > bufPos) {\n          tokens.push(data.slice(bufPos, pos));\n        }\n        tokens.push(MATCH);\n        return [\n          pos + this._needle.length,\n          ...tokens\n        ];\n      } else {\n        pos += this._occ[ch];\n      }\n    }\n    if (pos < data.length) {\n      while (pos < data.length && (data[pos] !== this._needle[0] || !jsmemcmp(data, pos, this._needle, 0, data.length - pos))) {\n        ++pos;\n      }\n      if (pos < data.length) {\n        this._lookbehind = data.slice(pos);\n      }\n    }\n    if (pos > 0) {\n      tokens.push(data.slice(bufPos, pos < data.length ? pos : data.length));\n    }\n    return [\n      data.length,\n      ...tokens\n    ];\n  }\n  _charAt(data, pos) {\n    if (pos < 0) {\n      return this._lookbehind[this._lookbehind.length + pos];\n    }\n    return data[pos];\n  }\n  _memcmp(data, pos, len) {\n    return jsmemcmp(this._charAt.bind(this, data), pos, this._needle, 0, len);\n  }\n}\nclass ReadableStreamSearch {\n  constructor(needle, _readableStream) {\n    this._readableStream = _readableStream;\n    this._search = new StreamSearch(needle);\n  }\n  async *[Symbol.asyncIterator]() {\n    const reader = this._readableStream.getReader();\n    try {\n      while (true) {\n        const result = await reader.read();\n        if (result.done) {\n          break;\n        }\n        yield* this._search.feed(result.value);\n      }\n      const tail = this._search.end();\n      if (tail.length) {\n        yield tail;\n      }\n    } finally {\n      reader.releaseLock();\n    }\n  }\n}\nconst EOQ = Symbol('End of Queue');\nclass QueueableStreamSearch {\n  constructor(needle) {\n    this._chunksQueue = [];\n    this._closed = false;\n    this._search = new StreamSearch(needle);\n  }\n  push(...chunks) {\n    if (this._closed) {\n      throw new Error('cannot call push after close');\n    }\n    this._chunksQueue.push(...chunks);\n    if (this._notify) {\n      this._notify();\n    }\n  }\n  close() {\n    if (this._closed) {\n      throw new Error('close was already called');\n    }\n    this._closed = true;\n    this._chunksQueue.push(EOQ);\n    if (this._notify) {\n      this._notify();\n    }\n  }\n  async *[Symbol.asyncIterator]() {\n    while (true) {\n      let chunk;\n      while (!(chunk = this._chunksQueue.shift())) {\n        await new Promise(resolve => this._notify = resolve);\n        this._notify = undefined;\n      }\n      if (chunk === EOQ) {\n        break;\n      }\n      yield* this._search.feed(chunk);\n    }\n    const tail = this._search.end();\n    if (tail.length) {\n      yield tail;\n    }\n  }\n}\nfunction splitChunks(chunks, needle) {\n  const search = new StreamSearch(needle);\n  const outchunks = [[]];\n  for (const chunk of chunks) {\n    for (const token of search.feed(chunk)) {\n      if (token === MATCH) {\n        outchunks.push([]);\n      } else {\n        outchunks[outchunks.length - 1].push(token);\n      }\n    }\n  }\n  const end = search.end();\n  outchunks[outchunks.length - 1].push(end);\n  return outchunks.map(chunks => mergeArrays(...chunks));\n}\nfunction split(buf, needle) {\n  return splitChunks([buf], needle);\n}\nasync function* chunksIterator(iter) {\n  let chunks = [];\n  for await (const value of iter) {\n    if (value === MATCH) {\n      yield chunks;\n      chunks = [];\n    } else {\n      chunks.push(value);\n    }\n  }\n  yield chunks;\n}\nasync function* stringIterator(iter) {\n  for await (const chunk of chunksIterator(iter)) {\n    yield chunk.map(arrayToString).join('');\n  }\n}\nasync function allStrings(iter) {\n  const segments = [];\n  for await (const value of stringIterator(iter)) {\n    segments.push(value);\n  }\n  return segments;\n}\nasync function* arrayIterator(iter) {\n  for await (const chunk of chunksIterator(iter)) {\n    yield mergeArrays(...chunk);\n  }\n}\nexport {\n  MATCH,\n  QueueableStreamSearch,\n  ReadableStreamSearch,\n  StreamSearch,\n  allStrings,\n  arrayIterator,\n  chunksIterator,\n  split,\n  splitChunks,\n  stringIterator\n};", "import {\n  ReadableStreamSearch,\n  StreamSearch,\n  MATCH\n} from './search.js';\nimport {\n  arraysEqual,\n  stringToArray,\n  arrayToString,\n  mergeArrays\n} from './utils.js';\nconst mergeArrays2 = Function.prototype.apply.bind(mergeArrays, undefined);\nconst dash = stringToArray('--');\nconst CRLF = stringToArray('\\r\\n');\nfunction parseContentDisposition(header) {\n  const parts = header.split(';').map(part => part.trim());\n  if (parts.shift() !== 'form-data') {\n    throw new Error('malformed content-disposition header: missing \"form-data\" in `' + JSON.stringify(parts) + '`');\n  }\n  const out = {};\n  for (const part of parts) {\n    const kv = part.split('=', 2);\n    if (kv.length !== 2) {\n      throw new Error('malformed content-disposition header: key-value pair not found - ' + part + ' in `' + header + '`');\n    }\n    const [name, value] = kv;\n    if (value[0] === '\"' && value[value.length - 1] === '\"') {\n      out[name] = value.slice(1, -1).replace(/\\\\\"/g, '\"');\n    } else if (value[0] !== '\"' && value[value.length - 1] !== '\"') {\n      out[name] = value;\n    } else if (value[0] === '\"' && value[value.length - 1] !== '\"' || value[0] !== '\"' && value[value.length - 1] === '\"') {\n      throw new Error('malformed content-disposition header: mismatched quotations in `' + header + '`');\n    }\n  }\n  if (!out.name) {\n    throw new Error('malformed content-disposition header: missing field name in `' + header + '`');\n  }\n  return out;\n}\nfunction parsePartHeaders(lines) {\n  const entries = [];\n  let disposition = false;\n  let line;\n  while (typeof (line = lines.shift()) !== 'undefined') {\n    const colon = line.indexOf(':');\n    if (colon === -1) {\n      throw new Error('malformed multipart-form header: missing colon');\n    }\n    const header = line.slice(0, colon).trim().toLowerCase();\n    const value = line.slice(colon + 1).trim();\n    switch (header) {\n    case 'content-disposition':\n      disposition = true;\n      entries.push(...Object.entries(parseContentDisposition(value)));\n      break;\n    case 'content-type':\n      entries.push([\n        'contentType',\n        value\n      ]);\n    }\n  }\n  if (!disposition) {\n    throw new Error('malformed multipart-form header: missing content-disposition');\n  }\n  return Object.fromEntries(entries);\n}\nasync function readHeaderLines(it, needle) {\n  let firstChunk = true;\n  let lastTokenWasMatch = false;\n  const headerLines = [[]];\n  const crlfSearch = new StreamSearch(CRLF);\n  for (;;) {\n    const result = await it.next();\n    if (result.done) {\n      throw new Error('malformed multipart-form data: unexpected end of stream');\n    }\n    if (firstChunk && result.value !== MATCH && arraysEqual(result.value.slice(0, 2), dash)) {\n      return [\n        undefined,\n        new Uint8Array()\n      ];\n    }\n    let chunk;\n    if (result.value !== MATCH) {\n      chunk = result.value;\n    } else if (!lastTokenWasMatch) {\n      chunk = needle;\n    } else {\n      throw new Error('malformed multipart-form data: unexpected boundary');\n    }\n    if (!chunk.length) {\n      continue;\n    }\n    if (firstChunk) {\n      firstChunk = false;\n    }\n    const tokens = crlfSearch.feed(chunk);\n    for (const [i, token] of tokens.entries()) {\n      const isMatch = token === MATCH;\n      if (!isMatch && !token.length) {\n        continue;\n      }\n      if (lastTokenWasMatch && isMatch) {\n        tokens.push(crlfSearch.end());\n        return [\n          headerLines.filter(chunks => chunks.length).map(mergeArrays2).map(arrayToString),\n          mergeArrays(...tokens.slice(i + 1).map(token => token === MATCH ? CRLF : token))\n        ];\n      }\n      if (lastTokenWasMatch = isMatch) {\n        headerLines.push([]);\n      } else {\n        headerLines[headerLines.length - 1].push(token);\n      }\n    }\n  }\n}\nexport async function* streamMultipart(body, boundary) {\n  const needle = mergeArrays(dash, stringToArray(boundary));\n  const it = new ReadableStreamSearch(needle, body)[Symbol.asyncIterator]();\n  for (;;) {\n    const result = await it.next();\n    if (result.done) {\n      return;\n    }\n    if (result.value === MATCH) {\n      break;\n    }\n  }\n  const crlfSearch = new StreamSearch(CRLF);\n  for (;;) {\n    const [headerLines, tail] = await readHeaderLines(it, needle);\n    if (!headerLines) {\n      return;\n    }\n    async function nextToken() {\n      const result = await it.next();\n      if (result.done) {\n        throw new Error('malformed multipart-form data: unexpected end of stream');\n      }\n      return result;\n    }\n    let trailingCRLF = false;\n    function feedChunk(chunk) {\n      const chunks = [];\n      for (const token of crlfSearch.feed(chunk)) {\n        if (trailingCRLF) {\n          chunks.push(CRLF);\n        }\n        if (!(trailingCRLF = token === MATCH)) {\n          chunks.push(token);\n        }\n      }\n      return mergeArrays(...chunks);\n    }\n    let done = false;\n    async function nextChunk() {\n      const result = await nextToken();\n      let chunk;\n      if (result.value !== MATCH) {\n        chunk = result.value;\n      } else if (!trailingCRLF) {\n        chunk = CRLF;\n      } else {\n        done = true;\n        return { value: crlfSearch.end() };\n      }\n      return { value: feedChunk(chunk) };\n    }\n    const bufferedChunks = [{ value: feedChunk(tail) }];\n    yield {\n      ...parsePartHeaders(headerLines),\n      data: {\n        [Symbol.asyncIterator]() {\n          return this;\n        },\n        async next() {\n          for (;;) {\n            const result = bufferedChunks.shift();\n            if (!result) {\n              break;\n            }\n            if (result.value.length > 0) {\n              return result;\n            }\n          }\n          for (;;) {\n            if (done) {\n              return {\n                done,\n                value: undefined\n              };\n            }\n            const result = await nextChunk();\n            if (result.value.length > 0) {\n              return result;\n            }\n          }\n        }\n      }\n    };\n    while (!done) {\n      bufferedChunks.push(await nextChunk());\n    }\n  }\n}\nexport async function* iterateMultipart(body, boundary) {\n  for await (const part of streamMultipart(body, boundary)) {\n    const chunks = [];\n    for await (const chunk of part.data) {\n      chunks.push(chunk);\n    }\n    yield {\n      ...part,\n      data: mergeArrays(...chunks)\n    };\n  }\n}", "/**\n * @remix-run/server-runtime v2.4.1\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar multipartParser = require('@web3-storage/multipart-parser');\n\n// @ts-ignore\nfunction composeUploadHandlers(...handlers) {\n  return async part => {\n    for (let handler of handlers) {\n      let value = await handler(part);\n      if (typeof value !== \"undefined\" && value !== null) {\n        return value;\n      }\n    }\n    return undefined;\n  };\n}\n\n/**\n * Allows you to handle multipart forms (file uploads) for your app.\n *\n * TODO: Update this comment\n * @see https://remix.run/utils/parse-multipart-form-data\n */\nasync function parseMultipartFormData(request, uploadHandler) {\n  let contentType = request.headers.get(\"Content-Type\") || \"\";\n  let [type, boundary] = contentType.split(/\\s*;\\s*boundary=/);\n  if (!request.body || !boundary || type !== \"multipart/form-data\") {\n    throw new TypeError(\"Could not parse content as FormData.\");\n  }\n  let formData = new FormData();\n  let parts = multipartParser.streamMultipart(request.body, boundary);\n  for await (let part of parts) {\n    if (part.done) break;\n    if (typeof part.filename === \"string\") {\n      // only pass basename as the multipart/form-data spec recommends\n      // https://datatracker.ietf.org/doc/html/rfc7578#section-4.2\n      part.filename = part.filename.split(/[/\\\\]/).pop();\n    }\n    let value = await uploadHandler(part);\n    if (typeof value !== \"undefined\" && value !== null) {\n      formData.append(part.name, value);\n    }\n  }\n  return formData;\n}\n\nexports.composeUploadHandlers = composeUploadHandlers;\nexports.parseMultipartFormData = parseMultipartFormData;\n", "////////////////////////////////////////////////////////////////////////////////\n//#region Types and Constants\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * Actions represent the type of change to a location value.\n */\nexport enum Action {\n  /**\n   * A POP indicates a change to an arbitrary index in the history stack, such\n   * as a back or forward navigation. It does not describe the direction of the\n   * navigation, only that the current index changed.\n   *\n   * Note: This is the default action for newly created history objects.\n   */\n  Pop = \"POP\",\n\n  /**\n   * A PUSH indicates a new entry being added to the history stack, such as when\n   * a link is clicked and a new page loads. When this happens, all subsequent\n   * entries in the stack are lost.\n   */\n  Push = \"PUSH\",\n\n  /**\n   * A REPLACE indicates the entry at the current index in the history stack\n   * being replaced by a new one.\n   */\n  Replace = \"REPLACE\",\n}\n\n/**\n * The pathname, search, and hash values of a URL.\n */\nexport interface Path {\n  /**\n   * A URL pathname, beginning with a /.\n   */\n  pathname: string;\n\n  /**\n   * A URL search string, beginning with a ?.\n   */\n  search: string;\n\n  /**\n   * A URL fragment identifier, beginning with a #.\n   */\n  hash: string;\n}\n\n// TODO: (v7) Change the Location generic default from `any` to `unknown` and\n// remove Remix `useLocation` wrapper.\n\n/**\n * An entry in a history stack. A location contains information about the\n * URL path, as well as possibly some arbitrary state and a key.\n */\nexport interface Location<State = any> extends Path {\n  /**\n   * A value of arbitrary data associated with this location.\n   */\n  state: State;\n\n  /**\n   * A unique string associated with this location. May be used to safely store\n   * and retrieve data in some other storage API, like `localStorage`.\n   *\n   * Note: This value is always \"default\" on the initial location.\n   */\n  key: string;\n}\n\n/**\n * A change to the current location.\n */\nexport interface Update {\n  /**\n   * The action that triggered the change.\n   */\n  action: Action;\n\n  /**\n   * The new location.\n   */\n  location: Location;\n\n  /**\n   * The delta between this location and the former location in the history stack\n   */\n  delta: number | null;\n}\n\n/**\n * A function that receives notifications about location changes.\n */\nexport interface Listener {\n  (update: Update): void;\n}\n\n/**\n * Describes a location that is the destination of some navigation, either via\n * `history.push` or `history.replace`. This may be either a URL or the pieces\n * of a URL path.\n */\nexport type To = string | Partial<Path>;\n\n/**\n * A history is an interface to the navigation stack. The history serves as the\n * source of truth for the current location, as well as provides a set of\n * methods that may be used to change it.\n *\n * It is similar to the DOM's `window.history` object, but with a smaller, more\n * focused API.\n */\nexport interface History {\n  /**\n   * The last action that modified the current location. This will always be\n   * Action.Pop when a history instance is first created. This value is mutable.\n   */\n  readonly action: Action;\n\n  /**\n   * The current location. This value is mutable.\n   */\n  readonly location: Location;\n\n  /**\n   * Returns a valid href for the given `to` value that may be used as\n   * the value of an <a href> attribute.\n   *\n   * @param to - The destination URL\n   */\n  createHref(to: To): string;\n\n  /**\n   * Returns a URL for the given `to` value\n   *\n   * @param to - The destination URL\n   */\n  createURL(to: To): URL;\n\n  /**\n   * Encode a location the same way window.history would do (no-op for memory\n   * history) so we ensure our PUSH/REPLACE navigations for data routers\n   * behave the same as POP\n   *\n   * @param to Unencoded path\n   */\n  encodeLocation(to: To): Path;\n\n  /**\n   * Pushes a new location onto the history stack, increasing its length by one.\n   * If there were any entries in the stack after the current one, they are\n   * lost.\n   *\n   * @param to - The new URL\n   * @param state - Data to associate with the new location\n   */\n  push(to: To, state?: any): void;\n\n  /**\n   * Replaces the current location in the history stack with a new one.  The\n   * location that was replaced will no longer be available.\n   *\n   * @param to - The new URL\n   * @param state - Data to associate with the new location\n   */\n  replace(to: To, state?: any): void;\n\n  /**\n   * Navigates `n` entries backward/forward in the history stack relative to the\n   * current index. For example, a \"back\" navigation would use go(-1).\n   *\n   * @param delta - The delta in the stack index\n   */\n  go(delta: number): void;\n\n  /**\n   * Sets up a listener that will be called whenever the current location\n   * changes.\n   *\n   * @param listener - A function that will be called when the location changes\n   * @returns unlisten - A function that may be used to stop listening\n   */\n  listen(listener: Listener): () => void;\n}\n\ntype HistoryState = {\n  usr: any;\n  key?: string;\n  idx: number;\n};\n\nconst PopStateEventType = \"popstate\";\n//#endregion\n\n////////////////////////////////////////////////////////////////////////////////\n//#region Memory History\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * A user-supplied object that describes a location. Used when providing\n * entries to `createMemoryHistory` via its `initialEntries` option.\n */\nexport type InitialEntry = string | Partial<Location>;\n\nexport type MemoryHistoryOptions = {\n  initialEntries?: InitialEntry[];\n  initialIndex?: number;\n  v5Compat?: boolean;\n};\n\n/**\n * A memory history stores locations in memory. This is useful in stateful\n * environments where there is no web browser, such as node tests or React\n * Native.\n */\nexport interface MemoryHistory extends History {\n  /**\n   * The current index in the history stack.\n   */\n  readonly index: number;\n}\n\n/**\n * Memory history stores the current location in memory. It is designed for use\n * in stateful non-browser environments like tests and React Native.\n */\nexport function createMemoryHistory(\n  options: MemoryHistoryOptions = {}\n): MemoryHistory {\n  let { initialEntries = [\"/\"], initialIndex, v5Compat = false } = options;\n  let entries: Location[]; // Declare so we can access from createMemoryLocation\n  entries = initialEntries.map((entry, index) =>\n    createMemoryLocation(\n      entry,\n      typeof entry === \"string\" ? null : entry.state,\n      index === 0 ? \"default\" : undefined\n    )\n  );\n  let index = clampIndex(\n    initialIndex == null ? entries.length - 1 : initialIndex\n  );\n  let action = Action.Pop;\n  let listener: Listener | null = null;\n\n  function clampIndex(n: number): number {\n    return Math.min(Math.max(n, 0), entries.length - 1);\n  }\n  function getCurrentLocation(): Location {\n    return entries[index];\n  }\n  function createMemoryLocation(\n    to: To,\n    state: any = null,\n    key?: string\n  ): Location {\n    let location = createLocation(\n      entries ? getCurrentLocation().pathname : \"/\",\n      to,\n      state,\n      key\n    );\n    warning(\n      location.pathname.charAt(0) === \"/\",\n      `relative pathnames are not supported in memory history: ${JSON.stringify(\n        to\n      )}`\n    );\n    return location;\n  }\n\n  function createHref(to: To) {\n    return typeof to === \"string\" ? to : createPath(to);\n  }\n\n  let history: MemoryHistory = {\n    get index() {\n      return index;\n    },\n    get action() {\n      return action;\n    },\n    get location() {\n      return getCurrentLocation();\n    },\n    createHref,\n    createURL(to) {\n      return new URL(createHref(to), \"http://localhost\");\n    },\n    encodeLocation(to: To) {\n      let path = typeof to === \"string\" ? parsePath(to) : to;\n      return {\n        pathname: path.pathname || \"\",\n        search: path.search || \"\",\n        hash: path.hash || \"\",\n      };\n    },\n    push(to, state) {\n      action = Action.Push;\n      let nextLocation = createMemoryLocation(to, state);\n      index += 1;\n      entries.splice(index, entries.length, nextLocation);\n      if (v5Compat && listener) {\n        listener({ action, location: nextLocation, delta: 1 });\n      }\n    },\n    replace(to, state) {\n      action = Action.Replace;\n      let nextLocation = createMemoryLocation(to, state);\n      entries[index] = nextLocation;\n      if (v5Compat && listener) {\n        listener({ action, location: nextLocation, delta: 0 });\n      }\n    },\n    go(delta) {\n      action = Action.Pop;\n      let nextIndex = clampIndex(index + delta);\n      let nextLocation = entries[nextIndex];\n      index = nextIndex;\n      if (listener) {\n        listener({ action, location: nextLocation, delta });\n      }\n    },\n    listen(fn: Listener) {\n      listener = fn;\n      return () => {\n        listener = null;\n      };\n    },\n  };\n\n  return history;\n}\n//#endregion\n\n////////////////////////////////////////////////////////////////////////////////\n//#region Browser History\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * A browser history stores the current location in regular URLs in a web\n * browser environment. This is the standard for most web apps and provides the\n * cleanest URLs the browser's address bar.\n *\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#browserhistory\n */\nexport interface BrowserHistory extends UrlHistory {}\n\nexport type BrowserHistoryOptions = UrlHistoryOptions;\n\n/**\n * Browser history stores the location in regular URLs. This is the standard for\n * most web apps, but it requires some configuration on the server to ensure you\n * serve the same app at multiple URLs.\n *\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createbrowserhistory\n */\nexport function createBrowserHistory(\n  options: BrowserHistoryOptions = {}\n): BrowserHistory {\n  function createBrowserLocation(\n    window: Window,\n    globalHistory: Window[\"history\"]\n  ) {\n    let { pathname, search, hash } = window.location;\n    return createLocation(\n      \"\",\n      { pathname, search, hash },\n      // state defaults to `null` because `window.history.state` does\n      (globalHistory.state && globalHistory.state.usr) || null,\n      (globalHistory.state && globalHistory.state.key) || \"default\"\n    );\n  }\n\n  function createBrowserHref(window: Window, to: To) {\n    return typeof to === \"string\" ? to : createPath(to);\n  }\n\n  return getUrlBasedHistory(\n    createBrowserLocation,\n    createBrowserHref,\n    null,\n    options\n  );\n}\n//#endregion\n\n////////////////////////////////////////////////////////////////////////////////\n//#region Hash History\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * A hash history stores the current location in the fragment identifier portion\n * of the URL in a web browser environment.\n *\n * This is ideal for apps that do not control the server for some reason\n * (because the fragment identifier is never sent to the server), including some\n * shared hosting environments that do not provide fine-grained controls over\n * which pages are served at which URLs.\n *\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#hashhistory\n */\nexport interface HashHistory extends UrlHistory {}\n\nexport type HashHistoryOptions = UrlHistoryOptions;\n\n/**\n * Hash history stores the location in window.location.hash. This makes it ideal\n * for situations where you don't want to send the location to the server for\n * some reason, either because you do cannot configure it or the URL space is\n * reserved for something else.\n *\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createhashhistory\n */\nexport function createHashHistory(\n  options: HashHistoryOptions = {}\n): HashHistory {\n  function createHashLocation(\n    window: Window,\n    globalHistory: Window[\"history\"]\n  ) {\n    let {\n      pathname = \"/\",\n      search = \"\",\n      hash = \"\",\n    } = parsePath(window.location.hash.substr(1));\n\n    // Hash URL should always have a leading / just like window.location.pathname\n    // does, so if an app ends up at a route like /#something then we add a\n    // leading slash so all of our path-matching behaves the same as if it would\n    // in a browser router.  This is particularly important when there exists a\n    // root splat route (<Route path=\"*\">) since that matches internally against\n    // \"/*\" and we'd expect /#something to 404 in a hash router app.\n    if (!pathname.startsWith(\"/\") && !pathname.startsWith(\".\")) {\n      pathname = \"/\" + pathname;\n    }\n\n    return createLocation(\n      \"\",\n      { pathname, search, hash },\n      // state defaults to `null` because `window.history.state` does\n      (globalHistory.state && globalHistory.state.usr) || null,\n      (globalHistory.state && globalHistory.state.key) || \"default\"\n    );\n  }\n\n  function createHashHref(window: Window, to: To) {\n    let base = window.document.querySelector(\"base\");\n    let href = \"\";\n\n    if (base && base.getAttribute(\"href\")) {\n      let url = window.location.href;\n      let hashIndex = url.indexOf(\"#\");\n      href = hashIndex === -1 ? url : url.slice(0, hashIndex);\n    }\n\n    return href + \"#\" + (typeof to === \"string\" ? to : createPath(to));\n  }\n\n  function validateHashLocation(location: Location, to: To) {\n    warning(\n      location.pathname.charAt(0) === \"/\",\n      `relative pathnames are not supported in hash history.push(${JSON.stringify(\n        to\n      )})`\n    );\n  }\n\n  return getUrlBasedHistory(\n    createHashLocation,\n    createHashHref,\n    validateHashLocation,\n    options\n  );\n}\n//#endregion\n\n////////////////////////////////////////////////////////////////////////////////\n//#region UTILS\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * @private\n */\nexport function invariant(value: boolean, message?: string): asserts value;\nexport function invariant<T>(\n  value: T | null | undefined,\n  message?: string\n): asserts value is T;\nexport function invariant(value: any, message?: string) {\n  if (value === false || value === null || typeof value === \"undefined\") {\n    throw new Error(message);\n  }\n}\n\nexport function warning(cond: any, message: string) {\n  if (!cond) {\n    // eslint-disable-next-line no-console\n    if (typeof console !== \"undefined\") console.warn(message);\n\n    try {\n      // Welcome to debugging history!\n      //\n      // This error is thrown as a convenience, so you can more easily\n      // find the source for a warning that appears in the console by\n      // enabling \"pause on exceptions\" in your JavaScript debugger.\n      throw new Error(message);\n      // eslint-disable-next-line no-empty\n    } catch (e) {}\n  }\n}\n\nfunction createKey() {\n  return Math.random().toString(36).substr(2, 8);\n}\n\n/**\n * For browser-based histories, we combine the state and key into an object\n */\nfunction getHistoryState(location: Location, index: number): HistoryState {\n  return {\n    usr: location.state,\n    key: location.key,\n    idx: index,\n  };\n}\n\n/**\n * Creates a Location object with a unique key from the given Path\n */\nexport function createLocation(\n  current: string | Location,\n  to: To,\n  state: any = null,\n  key?: string\n): Readonly<Location> {\n  let location: Readonly<Location> = {\n    pathname: typeof current === \"string\" ? current : current.pathname,\n    search: \"\",\n    hash: \"\",\n    ...(typeof to === \"string\" ? parsePath(to) : to),\n    state,\n    // TODO: This could be cleaned up.  push/replace should probably just take\n    // full Locations now and avoid the need to run through this flow at all\n    // But that's a pretty big refactor to the current test suite so going to\n    // keep as is for the time being and just let any incoming keys take precedence\n    key: (to && (to as Location).key) || key || createKey(),\n  };\n  return location;\n}\n\n/**\n * Creates a string URL path from the given pathname, search, and hash components.\n */\nexport function createPath({\n  pathname = \"/\",\n  search = \"\",\n  hash = \"\",\n}: Partial<Path>) {\n  if (search && search !== \"?\")\n    pathname += search.charAt(0) === \"?\" ? search : \"?\" + search;\n  if (hash && hash !== \"#\")\n    pathname += hash.charAt(0) === \"#\" ? hash : \"#\" + hash;\n  return pathname;\n}\n\n/**\n * Parses a string URL path into its separate pathname, search, and hash components.\n */\nexport function parsePath(path: string): Partial<Path> {\n  let parsedPath: Partial<Path> = {};\n\n  if (path) {\n    let hashIndex = path.indexOf(\"#\");\n    if (hashIndex >= 0) {\n      parsedPath.hash = path.substr(hashIndex);\n      path = path.substr(0, hashIndex);\n    }\n\n    let searchIndex = path.indexOf(\"?\");\n    if (searchIndex >= 0) {\n      parsedPath.search = path.substr(searchIndex);\n      path = path.substr(0, searchIndex);\n    }\n\n    if (path) {\n      parsedPath.pathname = path;\n    }\n  }\n\n  return parsedPath;\n}\n\nexport interface UrlHistory extends History {}\n\nexport type UrlHistoryOptions = {\n  window?: Window;\n  v5Compat?: boolean;\n};\n\nfunction getUrlBasedHistory(\n  getLocation: (window: Window, globalHistory: Window[\"history\"]) => Location,\n  createHref: (window: Window, to: To) => string,\n  validateLocation: ((location: Location, to: To) => void) | null,\n  options: UrlHistoryOptions = {}\n): UrlHistory {\n  let { window = document.defaultView!, v5Compat = false } = options;\n  let globalHistory = window.history;\n  let action = Action.Pop;\n  let listener: Listener | null = null;\n\n  let index = getIndex()!;\n  // Index should only be null when we initialize. If not, it's because the\n  // user called history.pushState or history.replaceState directly, in which\n  // case we should log a warning as it will result in bugs.\n  if (index == null) {\n    index = 0;\n    globalHistory.replaceState({ ...globalHistory.state, idx: index }, \"\");\n  }\n\n  function getIndex(): number {\n    let state = globalHistory.state || { idx: null };\n    return state.idx;\n  }\n\n  function handlePop() {\n    action = Action.Pop;\n    let nextIndex = getIndex();\n    let delta = nextIndex == null ? null : nextIndex - index;\n    index = nextIndex;\n    if (listener) {\n      listener({ action, location: history.location, delta });\n    }\n  }\n\n  function push(to: To, state?: any) {\n    action = Action.Push;\n    let location = createLocation(history.location, to, state);\n    if (validateLocation) validateLocation(location, to);\n\n    index = getIndex() + 1;\n    let historyState = getHistoryState(location, index);\n    let url = history.createHref(location);\n\n    // try...catch because iOS limits us to 100 pushState calls :/\n    try {\n      globalHistory.pushState(historyState, \"\", url);\n    } catch (error) {\n      // If the exception is because `state` can't be serialized, let that throw\n      // outwards just like a replace call would so the dev knows the cause\n      // https://html.spec.whatwg.org/multipage/nav-history-apis.html#shared-history-push/replace-state-steps\n      // https://html.spec.whatwg.org/multipage/structured-data.html#structuredserializeinternal\n      if (error instanceof DOMException && error.name === \"DataCloneError\") {\n        throw error;\n      }\n      // They are going to lose state here, but there is no real\n      // way to warn them about it since the page will refresh...\n      window.location.assign(url);\n    }\n\n    if (v5Compat && listener) {\n      listener({ action, location: history.location, delta: 1 });\n    }\n  }\n\n  function replace(to: To, state?: any) {\n    action = Action.Replace;\n    let location = createLocation(history.location, to, state);\n    if (validateLocation) validateLocation(location, to);\n\n    index = getIndex();\n    let historyState = getHistoryState(location, index);\n    let url = history.createHref(location);\n    globalHistory.replaceState(historyState, \"\", url);\n\n    if (v5Compat && listener) {\n      listener({ action, location: history.location, delta: 0 });\n    }\n  }\n\n  function createURL(to: To): URL {\n    // window.location.origin is \"null\" (the literal string value) in Firefox\n    // under certain conditions, notably when serving from a local HTML file\n    // See https://bugzilla.mozilla.org/show_bug.cgi?id=878297\n    let base =\n      window.location.origin !== \"null\"\n        ? window.location.origin\n        : window.location.href;\n\n    let href = typeof to === \"string\" ? to : createPath(to);\n    invariant(\n      base,\n      `No window.location.(origin|href) available to create URL for href: ${href}`\n    );\n    return new URL(href, base);\n  }\n\n  let history: History = {\n    get action() {\n      return action;\n    },\n    get location() {\n      return getLocation(window, globalHistory);\n    },\n    listen(fn: Listener) {\n      if (listener) {\n        throw new Error(\"A history only accepts one active listener\");\n      }\n      window.addEventListener(PopStateEventType, handlePop);\n      listener = fn;\n\n      return () => {\n        window.removeEventListener(PopStateEventType, handlePop);\n        listener = null;\n      };\n    },\n    createHref(to) {\n      return createHref(window, to);\n    },\n    createURL,\n    encodeLocation(to) {\n      // Encode a Location the same way window.location would\n      let url = createURL(to);\n      return {\n        pathname: url.pathname,\n        search: url.search,\n        hash: url.hash,\n      };\n    },\n    push,\n    replace,\n    go(n) {\n      return globalHistory.go(n);\n    },\n  };\n\n  return history;\n}\n\n//#endregion\n", "import type { Location, Path, To } from \"./history\";\nimport { invariant, parsePath, warning } from \"./history\";\n\n/**\n * Map of routeId -> data returned from a loader/action/error\n */\nexport interface RouteData {\n  [routeId: string]: any;\n}\n\nexport enum ResultType {\n  data = \"data\",\n  deferred = \"deferred\",\n  redirect = \"redirect\",\n  error = \"error\",\n}\n\n/**\n * Successful result from a loader or action\n */\nexport interface SuccessResult {\n  type: ResultType.data;\n  data: any;\n  statusCode?: number;\n  headers?: Headers;\n}\n\n/**\n * Successful defer() result from a loader or action\n */\nexport interface DeferredResult {\n  type: ResultType.deferred;\n  deferredData: DeferredData;\n  statusCode?: number;\n  headers?: Headers;\n}\n\n/**\n * Redirect result from a loader or action\n */\nexport interface RedirectResult {\n  type: ResultType.redirect;\n  status: number;\n  location: string;\n  revalidate: boolean;\n  reloadDocument?: boolean;\n}\n\n/**\n * Unsuccessful result from a loader or action\n */\nexport interface ErrorResult {\n  type: ResultType.error;\n  error: any;\n  headers?: Headers;\n}\n\n/**\n * Result from a loader or action - potentially successful or unsuccessful\n */\nexport type DataResult =\n  | SuccessResult\n  | DeferredResult\n  | RedirectResult\n  | ErrorResult;\n\ntype LowerCaseFormMethod = \"get\" | \"post\" | \"put\" | \"patch\" | \"delete\";\ntype UpperCaseFormMethod = Uppercase<LowerCaseFormMethod>;\n\n/**\n * Users can specify either lowercase or uppercase form methods on `<Form>`,\n * useSubmit(), `<fetcher.Form>`, etc.\n */\nexport type HTMLFormMethod = LowerCaseFormMethod | UpperCaseFormMethod;\n\n/**\n * Active navigation/fetcher form methods are exposed in lowercase on the\n * RouterState\n */\nexport type FormMethod = LowerCaseFormMethod;\nexport type MutationFormMethod = Exclude<FormMethod, \"get\">;\n\n/**\n * In v7, active navigation/fetcher form methods are exposed in uppercase on the\n * RouterState.  This is to align with the normalization done via fetch().\n */\nexport type V7_FormMethod = UpperCaseFormMethod;\nexport type V7_MutationFormMethod = Exclude<V7_FormMethod, \"GET\">;\n\nexport type FormEncType =\n  | \"application/x-www-form-urlencoded\"\n  | \"multipart/form-data\"\n  | \"application/json\"\n  | \"text/plain\";\n\n// Thanks https://github.com/sindresorhus/type-fest!\ntype JsonObject = { [Key in string]: JsonValue } & {\n  [Key in string]?: JsonValue | undefined;\n};\ntype JsonArray = JsonValue[] | readonly JsonValue[];\ntype JsonPrimitive = string | number | boolean | null;\ntype JsonValue = JsonPrimitive | JsonObject | JsonArray;\n\n/**\n * @private\n * Internal interface to pass around for action submissions, not intended for\n * external consumption\n */\nexport type Submission =\n  | {\n      formMethod: FormMethod | V7_FormMethod;\n      formAction: string;\n      formEncType: FormEncType;\n      formData: FormData;\n      json: undefined;\n      text: undefined;\n    }\n  | {\n      formMethod: FormMethod | V7_FormMethod;\n      formAction: string;\n      formEncType: FormEncType;\n      formData: undefined;\n      json: JsonValue;\n      text: undefined;\n    }\n  | {\n      formMethod: FormMethod | V7_FormMethod;\n      formAction: string;\n      formEncType: FormEncType;\n      formData: undefined;\n      json: undefined;\n      text: string;\n    };\n\n/**\n * @private\n * Arguments passed to route loader/action functions.  Same for now but we keep\n * this as a private implementation detail in case they diverge in the future.\n */\ninterface DataFunctionArgs<Context> {\n  request: Request;\n  params: Params;\n  context?: Context;\n}\n\n// TODO: (v7) Change the defaults from any to unknown in and remove Remix wrappers:\n//   ActionFunction, ActionFunctionArgs, LoaderFunction, LoaderFunctionArgs\n//   Also, make them a type alias instead of an interface\n\n/**\n * Arguments passed to loader functions\n */\nexport interface LoaderFunctionArgs<Context = any>\n  extends DataFunctionArgs<Context> {}\n\n/**\n * Arguments passed to action functions\n */\nexport interface ActionFunctionArgs<Context = any>\n  extends DataFunctionArgs<Context> {}\n\n/**\n * Loaders and actions can return anything except `undefined` (`null` is a\n * valid return value if there is no data to return).  Responses are preferred\n * and will ease any future migration to Remix\n */\ntype DataFunctionValue = Response | NonNullable<unknown> | null;\n\n/**\n * Route loader function signature\n */\nexport type LoaderFunction<Context = any> = {\n  (args: LoaderFunctionArgs<Context>):\n    | Promise<DataFunctionValue>\n    | DataFunctionValue;\n} & { hydrate?: boolean };\n\n/**\n * Route action function signature\n */\nexport interface ActionFunction<Context = any> {\n  (args: ActionFunctionArgs<Context>):\n    | Promise<DataFunctionValue>\n    | DataFunctionValue;\n}\n\n/**\n * Arguments passed to shouldRevalidate function\n */\nexport interface ShouldRevalidateFunctionArgs {\n  currentUrl: URL;\n  currentParams: AgnosticDataRouteMatch[\"params\"];\n  nextUrl: URL;\n  nextParams: AgnosticDataRouteMatch[\"params\"];\n  formMethod?: Submission[\"formMethod\"];\n  formAction?: Submission[\"formAction\"];\n  formEncType?: Submission[\"formEncType\"];\n  text?: Submission[\"text\"];\n  formData?: Submission[\"formData\"];\n  json?: Submission[\"json\"];\n  actionResult?: any;\n  defaultShouldRevalidate: boolean;\n}\n\n/**\n * Route shouldRevalidate function signature.  This runs after any submission\n * (navigation or fetcher), so we flatten the navigation/fetcher submission\n * onto the arguments.  It shouldn't matter whether it came from a navigation\n * or a fetcher, what really matters is the URLs and the formData since loaders\n * have to re-run based on the data models that were potentially mutated.\n */\nexport interface ShouldRevalidateFunction {\n  (args: ShouldRevalidateFunctionArgs): boolean;\n}\n\n/**\n * Function provided by the framework-aware layers to set `hasErrorBoundary`\n * from the framework-aware `errorElement` prop\n *\n * @deprecated Use `mapRouteProperties` instead\n */\nexport interface DetectErrorBoundaryFunction {\n  (route: AgnosticRouteObject): boolean;\n}\n\n/**\n * Function provided by the framework-aware layers to set any framework-specific\n * properties from framework-agnostic properties\n */\nexport interface MapRoutePropertiesFunction {\n  (route: AgnosticRouteObject): {\n    hasErrorBoundary: boolean;\n  } & Record<string, any>;\n}\n\n/**\n * Keys we cannot change from within a lazy() function. We spread all other keys\n * onto the route. Either they're meaningful to the router, or they'll get\n * ignored.\n */\nexport type ImmutableRouteKey =\n  | \"lazy\"\n  | \"caseSensitive\"\n  | \"path\"\n  | \"id\"\n  | \"index\"\n  | \"children\";\n\nexport const immutableRouteKeys = new Set<ImmutableRouteKey>([\n  \"lazy\",\n  \"caseSensitive\",\n  \"path\",\n  \"id\",\n  \"index\",\n  \"children\",\n]);\n\ntype RequireOne<T, Key = keyof T> = Exclude<\n  {\n    [K in keyof T]: K extends Key ? Omit<T, K> & Required<Pick<T, K>> : never;\n  }[keyof T],\n  undefined\n>;\n\n/**\n * lazy() function to load a route definition, which can add non-matching\n * related properties to a route\n */\nexport interface LazyRouteFunction<R extends AgnosticRouteObject> {\n  (): Promise<RequireOne<Omit<R, ImmutableRouteKey>>>;\n}\n\n/**\n * Base RouteObject with common props shared by all types of routes\n */\ntype AgnosticBaseRouteObject = {\n  caseSensitive?: boolean;\n  path?: string;\n  id?: string;\n  loader?: LoaderFunction;\n  action?: ActionFunction;\n  hasErrorBoundary?: boolean;\n  shouldRevalidate?: ShouldRevalidateFunction;\n  handle?: any;\n  lazy?: LazyRouteFunction<AgnosticBaseRouteObject>;\n};\n\n/**\n * Index routes must not have children\n */\nexport type AgnosticIndexRouteObject = AgnosticBaseRouteObject & {\n  children?: undefined;\n  index: true;\n};\n\n/**\n * Non-index routes may have children, but cannot have index\n */\nexport type AgnosticNonIndexRouteObject = AgnosticBaseRouteObject & {\n  children?: AgnosticRouteObject[];\n  index?: false;\n};\n\n/**\n * A route object represents a logical route, with (optionally) its child\n * routes organized in a tree-like structure.\n */\nexport type AgnosticRouteObject =\n  | AgnosticIndexRouteObject\n  | AgnosticNonIndexRouteObject;\n\nexport type AgnosticDataIndexRouteObject = AgnosticIndexRouteObject & {\n  id: string;\n};\n\nexport type AgnosticDataNonIndexRouteObject = AgnosticNonIndexRouteObject & {\n  children?: AgnosticDataRouteObject[];\n  id: string;\n};\n\n/**\n * A data route object, which is just a RouteObject with a required unique ID\n */\nexport type AgnosticDataRouteObject =\n  | AgnosticDataIndexRouteObject\n  | AgnosticDataNonIndexRouteObject;\n\nexport type RouteManifest = Record<string, AgnosticDataRouteObject | undefined>;\n\n// Recursive helper for finding path parameters in the absence of wildcards\ntype _PathParam<Path extends string> =\n  // split path into individual path segments\n  Path extends `${infer L}/${infer R}`\n    ? _PathParam<L> | _PathParam<R>\n    : // find params after `:`\n    Path extends `:${infer Param}`\n    ? Param extends `${infer Optional}?`\n      ? Optional\n      : Param\n    : // otherwise, there aren't any params present\n      never;\n\n/**\n * Examples:\n * \"/a/b/*\" -> \"*\"\n * \":a\" -> \"a\"\n * \"/a/:b\" -> \"b\"\n * \"/a/blahblahblah:b\" -> \"b\"\n * \"/:a/:b\" -> \"a\" | \"b\"\n * \"/:a/b/:c/*\" -> \"a\" | \"c\" | \"*\"\n */\nexport type PathParam<Path extends string> =\n  // check if path is just a wildcard\n  Path extends \"*\" | \"/*\"\n    ? \"*\"\n    : // look for wildcard at the end of the path\n    Path extends `${infer Rest}/*`\n    ? \"*\" | _PathParam<Rest>\n    : // look for params in the absence of wildcards\n      _PathParam<Path>;\n\n// Attempt to parse the given string segment. If it fails, then just return the\n// plain string type as a default fallback. Otherwise, return the union of the\n// parsed string literals that were referenced as dynamic segments in the route.\nexport type ParamParseKey<Segment extends string> =\n  // if you could not find path params, fallback to `string`\n  [PathParam<Segment>] extends [never] ? string : PathParam<Segment>;\n\n/**\n * The parameters that were parsed from the URL path.\n */\nexport type Params<Key extends string = string> = {\n  readonly [key in Key]: string | undefined;\n};\n\n/**\n * A RouteMatch contains info about how a route matched a URL.\n */\nexport interface AgnosticRouteMatch<\n  ParamKey extends string = string,\n  RouteObjectType extends AgnosticRouteObject = AgnosticRouteObject\n> {\n  /**\n   * The names and values of dynamic parameters in the URL.\n   */\n  params: Params<ParamKey>;\n  /**\n   * The portion of the URL pathname that was matched.\n   */\n  pathname: string;\n  /**\n   * The portion of the URL pathname that was matched before child routes.\n   */\n  pathnameBase: string;\n  /**\n   * The route object that was used to match.\n   */\n  route: RouteObjectType;\n}\n\nexport interface AgnosticDataRouteMatch\n  extends AgnosticRouteMatch<string, AgnosticDataRouteObject> {}\n\nfunction isIndexRoute(\n  route: AgnosticRouteObject\n): route is AgnosticIndexRouteObject {\n  return route.index === true;\n}\n\n// Walk the route tree generating unique IDs where necessary, so we are working\n// solely with AgnosticDataRouteObject's within the Router\nexport function convertRoutesToDataRoutes(\n  routes: AgnosticRouteObject[],\n  mapRouteProperties: MapRoutePropertiesFunction,\n  parentPath: number[] = [],\n  manifest: RouteManifest = {}\n): AgnosticDataRouteObject[] {\n  return routes.map((route, index) => {\n    let treePath = [...parentPath, index];\n    let id = typeof route.id === \"string\" ? route.id : treePath.join(\"-\");\n    invariant(\n      route.index !== true || !route.children,\n      `Cannot specify children on an index route`\n    );\n    invariant(\n      !manifest[id],\n      `Found a route id collision on id \"${id}\".  Route ` +\n        \"id's must be globally unique within Data Router usages\"\n    );\n\n    if (isIndexRoute(route)) {\n      let indexRoute: AgnosticDataIndexRouteObject = {\n        ...route,\n        ...mapRouteProperties(route),\n        id,\n      };\n      manifest[id] = indexRoute;\n      return indexRoute;\n    } else {\n      let pathOrLayoutRoute: AgnosticDataNonIndexRouteObject = {\n        ...route,\n        ...mapRouteProperties(route),\n        id,\n        children: undefined,\n      };\n      manifest[id] = pathOrLayoutRoute;\n\n      if (route.children) {\n        pathOrLayoutRoute.children = convertRoutesToDataRoutes(\n          route.children,\n          mapRouteProperties,\n          treePath,\n          manifest\n        );\n      }\n\n      return pathOrLayoutRoute;\n    }\n  });\n}\n\n/**\n * Matches the given routes to a location and returns the match data.\n *\n * @see https://reactrouter.com/utils/match-routes\n */\nexport function matchRoutes<\n  RouteObjectType extends AgnosticRouteObject = AgnosticRouteObject\n>(\n  routes: RouteObjectType[],\n  locationArg: Partial<Location> | string,\n  basename = \"/\"\n): AgnosticRouteMatch<string, RouteObjectType>[] | null {\n  let location =\n    typeof locationArg === \"string\" ? parsePath(locationArg) : locationArg;\n\n  let pathname = stripBasename(location.pathname || \"/\", basename);\n\n  if (pathname == null) {\n    return null;\n  }\n\n  let branches = flattenRoutes(routes);\n  rankRouteBranches(branches);\n\n  let matches = null;\n  for (let i = 0; matches == null && i < branches.length; ++i) {\n    matches = matchRouteBranch<string, RouteObjectType>(\n      branches[i],\n      // Incoming pathnames are generally encoded from either window.location\n      // or from router.navigate, but we want to match against the unencoded\n      // paths in the route definitions.  Memory router locations won't be\n      // encoded here but there also shouldn't be anything to decode so this\n      // should be a safe operation.  This avoids needing matchRoutes to be\n      // history-aware.\n      safelyDecodeURI(pathname)\n    );\n  }\n\n  return matches;\n}\n\nexport interface UIMatch<Data = unknown, Handle = unknown> {\n  id: string;\n  pathname: string;\n  params: AgnosticRouteMatch[\"params\"];\n  data: Data;\n  handle: Handle;\n}\n\nexport function convertRouteMatchToUiMatch(\n  match: AgnosticDataRouteMatch,\n  loaderData: RouteData\n): UIMatch {\n  let { route, pathname, params } = match;\n  return {\n    id: route.id,\n    pathname,\n    params,\n    data: loaderData[route.id],\n    handle: route.handle,\n  };\n}\n\ninterface RouteMeta<\n  RouteObjectType extends AgnosticRouteObject = AgnosticRouteObject\n> {\n  relativePath: string;\n  caseSensitive: boolean;\n  childrenIndex: number;\n  route: RouteObjectType;\n}\n\ninterface RouteBranch<\n  RouteObjectType extends AgnosticRouteObject = AgnosticRouteObject\n> {\n  path: string;\n  score: number;\n  routesMeta: RouteMeta<RouteObjectType>[];\n}\n\nfunction flattenRoutes<\n  RouteObjectType extends AgnosticRouteObject = AgnosticRouteObject\n>(\n  routes: RouteObjectType[],\n  branches: RouteBranch<RouteObjectType>[] = [],\n  parentsMeta: RouteMeta<RouteObjectType>[] = [],\n  parentPath = \"\"\n): RouteBranch<RouteObjectType>[] {\n  let flattenRoute = (\n    route: RouteObjectType,\n    index: number,\n    relativePath?: string\n  ) => {\n    let meta: RouteMeta<RouteObjectType> = {\n      relativePath:\n        relativePath === undefined ? route.path || \"\" : relativePath,\n      caseSensitive: route.caseSensitive === true,\n      childrenIndex: index,\n      route,\n    };\n\n    if (meta.relativePath.startsWith(\"/\")) {\n      invariant(\n        meta.relativePath.startsWith(parentPath),\n        `Absolute route path \"${meta.relativePath}\" nested under path ` +\n          `\"${parentPath}\" is not valid. An absolute child route path ` +\n          `must start with the combined path of all its parent routes.`\n      );\n\n      meta.relativePath = meta.relativePath.slice(parentPath.length);\n    }\n\n    let path = joinPaths([parentPath, meta.relativePath]);\n    let routesMeta = parentsMeta.concat(meta);\n\n    // Add the children before adding this route to the array, so we traverse the\n    // route tree depth-first and child routes appear before their parents in\n    // the \"flattened\" version.\n    if (route.children && route.children.length > 0) {\n      invariant(\n        // Our types know better, but runtime JS may not!\n        // @ts-expect-error\n        route.index !== true,\n        `Index routes must not have child routes. Please remove ` +\n          `all child routes from route path \"${path}\".`\n      );\n\n      flattenRoutes(route.children, branches, routesMeta, path);\n    }\n\n    // Routes without a path shouldn't ever match by themselves unless they are\n    // index routes, so don't add them to the list of possible branches.\n    if (route.path == null && !route.index) {\n      return;\n    }\n\n    branches.push({\n      path,\n      score: computeScore(path, route.index),\n      routesMeta,\n    });\n  };\n  routes.forEach((route, index) => {\n    // coarse-grain check for optional params\n    if (route.path === \"\" || !route.path?.includes(\"?\")) {\n      flattenRoute(route, index);\n    } else {\n      for (let exploded of explodeOptionalSegments(route.path)) {\n        flattenRoute(route, index, exploded);\n      }\n    }\n  });\n\n  return branches;\n}\n\n/**\n * Computes all combinations of optional path segments for a given path,\n * excluding combinations that are ambiguous and of lower priority.\n *\n * For example, `/one/:two?/three/:four?/:five?` explodes to:\n * - `/one/three`\n * - `/one/:two/three`\n * - `/one/three/:four`\n * - `/one/three/:five`\n * - `/one/:two/three/:four`\n * - `/one/:two/three/:five`\n * - `/one/three/:four/:five`\n * - `/one/:two/three/:four/:five`\n */\nfunction explodeOptionalSegments(path: string): string[] {\n  let segments = path.split(\"/\");\n  if (segments.length === 0) return [];\n\n  let [first, ...rest] = segments;\n\n  // Optional path segments are denoted by a trailing `?`\n  let isOptional = first.endsWith(\"?\");\n  // Compute the corresponding required segment: `foo?` -> `foo`\n  let required = first.replace(/\\?$/, \"\");\n\n  if (rest.length === 0) {\n    // Intepret empty string as omitting an optional segment\n    // `[\"one\", \"\", \"three\"]` corresponds to omitting `:two` from `/one/:two?/three` -> `/one/three`\n    return isOptional ? [required, \"\"] : [required];\n  }\n\n  let restExploded = explodeOptionalSegments(rest.join(\"/\"));\n\n  let result: string[] = [];\n\n  // All child paths with the prefix.  Do this for all children before the\n  // optional version for all children, so we get consistent ordering where the\n  // parent optional aspect is preferred as required.  Otherwise, we can get\n  // child sections interspersed where deeper optional segments are higher than\n  // parent optional segments, where for example, /:two would explode _earlier_\n  // then /:one.  By always including the parent as required _for all children_\n  // first, we avoid this issue\n  result.push(\n    ...restExploded.map((subpath) =>\n      subpath === \"\" ? required : [required, subpath].join(\"/\")\n    )\n  );\n\n  // Then, if this is an optional value, add all child versions without\n  if (isOptional) {\n    result.push(...restExploded);\n  }\n\n  // for absolute paths, ensure `/` instead of empty segment\n  return result.map((exploded) =>\n    path.startsWith(\"/\") && exploded === \"\" ? \"/\" : exploded\n  );\n}\n\nfunction rankRouteBranches(branches: RouteBranch[]): void {\n  branches.sort((a, b) =>\n    a.score !== b.score\n      ? b.score - a.score // Higher score first\n      : compareIndexes(\n          a.routesMeta.map((meta) => meta.childrenIndex),\n          b.routesMeta.map((meta) => meta.childrenIndex)\n        )\n  );\n}\n\nconst paramRe = /^:\\w+$/;\nconst dynamicSegmentValue = 3;\nconst indexRouteValue = 2;\nconst emptySegmentValue = 1;\nconst staticSegmentValue = 10;\nconst splatPenalty = -2;\nconst isSplat = (s: string) => s === \"*\";\n\nfunction computeScore(path: string, index: boolean | undefined): number {\n  let segments = path.split(\"/\");\n  let initialScore = segments.length;\n  if (segments.some(isSplat)) {\n    initialScore += splatPenalty;\n  }\n\n  if (index) {\n    initialScore += indexRouteValue;\n  }\n\n  return segments\n    .filter((s) => !isSplat(s))\n    .reduce(\n      (score, segment) =>\n        score +\n        (paramRe.test(segment)\n          ? dynamicSegmentValue\n          : segment === \"\"\n          ? emptySegmentValue\n          : staticSegmentValue),\n      initialScore\n    );\n}\n\nfunction compareIndexes(a: number[], b: number[]): number {\n  let siblings =\n    a.length === b.length && a.slice(0, -1).every((n, i) => n === b[i]);\n\n  return siblings\n    ? // If two routes are siblings, we should try to match the earlier sibling\n      // first. This allows people to have fine-grained control over the matching\n      // behavior by simply putting routes with identical paths in the order they\n      // want them tried.\n      a[a.length - 1] - b[b.length - 1]\n    : // Otherwise, it doesn't really make sense to rank non-siblings by index,\n      // so they sort equally.\n      0;\n}\n\nfunction matchRouteBranch<\n  ParamKey extends string = string,\n  RouteObjectType extends AgnosticRouteObject = AgnosticRouteObject\n>(\n  branch: RouteBranch<RouteObjectType>,\n  pathname: string\n): AgnosticRouteMatch<ParamKey, RouteObjectType>[] | null {\n  let { routesMeta } = branch;\n\n  let matchedParams = {};\n  let matchedPathname = \"/\";\n  let matches: AgnosticRouteMatch<ParamKey, RouteObjectType>[] = [];\n  for (let i = 0; i < routesMeta.length; ++i) {\n    let meta = routesMeta[i];\n    let end = i === routesMeta.length - 1;\n    let remainingPathname =\n      matchedPathname === \"/\"\n        ? pathname\n        : pathname.slice(matchedPathname.length) || \"/\";\n    let match = matchPath(\n      { path: meta.relativePath, caseSensitive: meta.caseSensitive, end },\n      remainingPathname\n    );\n\n    if (!match) return null;\n\n    Object.assign(matchedParams, match.params);\n\n    let route = meta.route;\n\n    matches.push({\n      // TODO: Can this as be avoided?\n      params: matchedParams as Params<ParamKey>,\n      pathname: joinPaths([matchedPathname, match.pathname]),\n      pathnameBase: normalizePathname(\n        joinPaths([matchedPathname, match.pathnameBase])\n      ),\n      route,\n    });\n\n    if (match.pathnameBase !== \"/\") {\n      matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);\n    }\n  }\n\n  return matches;\n}\n\n/**\n * Returns a path with params interpolated.\n *\n * @see https://reactrouter.com/utils/generate-path\n */\nexport function generatePath<Path extends string>(\n  originalPath: Path,\n  params: {\n    [key in PathParam<Path>]: string | null;\n  } = {} as any\n): string {\n  let path: string = originalPath;\n  if (path.endsWith(\"*\") && path !== \"*\" && !path.endsWith(\"/*\")) {\n    warning(\n      false,\n      `Route path \"${path}\" will be treated as if it were ` +\n        `\"${path.replace(/\\*$/, \"/*\")}\" because the \\`*\\` character must ` +\n        `always follow a \\`/\\` in the pattern. To get rid of this warning, ` +\n        `please change the route path to \"${path.replace(/\\*$/, \"/*\")}\".`\n    );\n    path = path.replace(/\\*$/, \"/*\") as Path;\n  }\n\n  // ensure `/` is added at the beginning if the path is absolute\n  const prefix = path.startsWith(\"/\") ? \"/\" : \"\";\n\n  const stringify = (p: any) =>\n    p == null ? \"\" : typeof p === \"string\" ? p : String(p);\n\n  const segments = path\n    .split(/\\/+/)\n    .map((segment, index, array) => {\n      const isLastSegment = index === array.length - 1;\n\n      // only apply the splat if it's the last segment\n      if (isLastSegment && segment === \"*\") {\n        const star = \"*\" as PathParam<Path>;\n        // Apply the splat\n        return stringify(params[star]);\n      }\n\n      const keyMatch = segment.match(/^:(\\w+)(\\??)$/);\n      if (keyMatch) {\n        const [, key, optional] = keyMatch;\n        let param = params[key as PathParam<Path>];\n        invariant(optional === \"?\" || param != null, `Missing \":${key}\" param`);\n        return stringify(param);\n      }\n\n      // Remove any optional markers from optional static segments\n      return segment.replace(/\\?$/g, \"\");\n    })\n    // Remove empty segments\n    .filter((segment) => !!segment);\n\n  return prefix + segments.join(\"/\");\n}\n\n/**\n * A PathPattern is used to match on some portion of a URL pathname.\n */\nexport interface PathPattern<Path extends string = string> {\n  /**\n   * A string to match against a URL pathname. May contain `:id`-style segments\n   * to indicate placeholders for dynamic parameters. May also end with `/*` to\n   * indicate matching the rest of the URL pathname.\n   */\n  path: Path;\n  /**\n   * Should be `true` if the static portions of the `path` should be matched in\n   * the same case.\n   */\n  caseSensitive?: boolean;\n  /**\n   * Should be `true` if this pattern should match the entire URL pathname.\n   */\n  end?: boolean;\n}\n\n/**\n * A PathMatch contains info about how a PathPattern matched on a URL pathname.\n */\nexport interface PathMatch<ParamKey extends string = string> {\n  /**\n   * The names and values of dynamic parameters in the URL.\n   */\n  params: Params<ParamKey>;\n  /**\n   * The portion of the URL pathname that was matched.\n   */\n  pathname: string;\n  /**\n   * The portion of the URL pathname that was matched before child routes.\n   */\n  pathnameBase: string;\n  /**\n   * The pattern that was used to match.\n   */\n  pattern: PathPattern;\n}\n\ntype Mutable<T> = {\n  -readonly [P in keyof T]: T[P];\n};\n\n/**\n * Performs pattern matching on a URL pathname and returns information about\n * the match.\n *\n * @see https://reactrouter.com/utils/match-path\n */\nexport function matchPath<\n  ParamKey extends ParamParseKey<Path>,\n  Path extends string\n>(\n  pattern: PathPattern<Path> | Path,\n  pathname: string\n): PathMatch<ParamKey> | null {\n  if (typeof pattern === \"string\") {\n    pattern = { path: pattern, caseSensitive: false, end: true };\n  }\n\n  let [matcher, compiledParams] = compilePath(\n    pattern.path,\n    pattern.caseSensitive,\n    pattern.end\n  );\n\n  let match = pathname.match(matcher);\n  if (!match) return null;\n\n  let matchedPathname = match[0];\n  let pathnameBase = matchedPathname.replace(/(.)\\/+$/, \"$1\");\n  let captureGroups = match.slice(1);\n  let params: Params = compiledParams.reduce<Mutable<Params>>(\n    (memo, { paramName, isOptional }, index) => {\n      // We need to compute the pathnameBase here using the raw splat value\n      // instead of using params[\"*\"] later because it will be decoded then\n      if (paramName === \"*\") {\n        let splatValue = captureGroups[index] || \"\";\n        pathnameBase = matchedPathname\n          .slice(0, matchedPathname.length - splatValue.length)\n          .replace(/(.)\\/+$/, \"$1\");\n      }\n\n      const value = captureGroups[index];\n      if (isOptional && !value) {\n        memo[paramName] = undefined;\n      } else {\n        memo[paramName] = safelyDecodeURIComponent(value || \"\", paramName);\n      }\n      return memo;\n    },\n    {}\n  );\n\n  return {\n    params,\n    pathname: matchedPathname,\n    pathnameBase,\n    pattern,\n  };\n}\n\ntype CompiledPathParam = { paramName: string; isOptional?: boolean };\n\nfunction compilePath(\n  path: string,\n  caseSensitive = false,\n  end = true\n): [RegExp, CompiledPathParam[]] {\n  warning(\n    path === \"*\" || !path.endsWith(\"*\") || path.endsWith(\"/*\"),\n    `Route path \"${path}\" will be treated as if it were ` +\n      `\"${path.replace(/\\*$/, \"/*\")}\" because the \\`*\\` character must ` +\n      `always follow a \\`/\\` in the pattern. To get rid of this warning, ` +\n      `please change the route path to \"${path.replace(/\\*$/, \"/*\")}\".`\n  );\n\n  let params: CompiledPathParam[] = [];\n  let regexpSource =\n    \"^\" +\n    path\n      .replace(/\\/*\\*?$/, \"\") // Ignore trailing / and /*, we'll handle it below\n      .replace(/^\\/*/, \"/\") // Make sure it has a leading /\n      .replace(/[\\\\.*+^${}|()[\\]]/g, \"\\\\$&\") // Escape special regex chars\n      .replace(/\\/:(\\w+)(\\?)?/g, (_: string, paramName: string, isOptional) => {\n        params.push({ paramName, isOptional: isOptional != null });\n        return isOptional ? \"/?([^\\\\/]+)?\" : \"/([^\\\\/]+)\";\n      });\n\n  if (path.endsWith(\"*\")) {\n    params.push({ paramName: \"*\" });\n    regexpSource +=\n      path === \"*\" || path === \"/*\"\n        ? \"(.*)$\" // Already matched the initial /, just match the rest\n        : \"(?:\\\\/(.+)|\\\\/*)$\"; // Don't include the / in params[\"*\"]\n  } else if (end) {\n    // When matching to the end, ignore trailing slashes\n    regexpSource += \"\\\\/*$\";\n  } else if (path !== \"\" && path !== \"/\") {\n    // If our path is non-empty and contains anything beyond an initial slash,\n    // then we have _some_ form of path in our regex, so we should expect to\n    // match only if we find the end of this path segment.  Look for an optional\n    // non-captured trailing slash (to match a portion of the URL) or the end\n    // of the path (if we've matched to the end).  We used to do this with a\n    // word boundary but that gives false positives on routes like\n    // /user-preferences since `-` counts as a word boundary.\n    regexpSource += \"(?:(?=\\\\/|$))\";\n  } else {\n    // Nothing to match for \"\" or \"/\"\n  }\n\n  let matcher = new RegExp(regexpSource, caseSensitive ? undefined : \"i\");\n\n  return [matcher, params];\n}\n\nfunction safelyDecodeURI(value: string) {\n  try {\n    return decodeURI(value);\n  } catch (error) {\n    warning(\n      false,\n      `The URL path \"${value}\" could not be decoded because it is is a ` +\n        `malformed URL segment. This is probably due to a bad percent ` +\n        `encoding (${error}).`\n    );\n\n    return value;\n  }\n}\n\nfunction safelyDecodeURIComponent(value: string, paramName: string) {\n  try {\n    return decodeURIComponent(value);\n  } catch (error) {\n    warning(\n      false,\n      `The value for the URL param \"${paramName}\" will not be decoded because` +\n        ` the string \"${value}\" is a malformed URL segment. This is probably` +\n        ` due to a bad percent encoding (${error}).`\n    );\n\n    return value;\n  }\n}\n\n/**\n * @private\n */\nexport function stripBasename(\n  pathname: string,\n  basename: string\n): string | null {\n  if (basename === \"/\") return pathname;\n\n  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {\n    return null;\n  }\n\n  // We want to leave trailing slash behavior in the user's control, so if they\n  // specify a basename with a trailing slash, we should support it\n  let startIndex = basename.endsWith(\"/\")\n    ? basename.length - 1\n    : basename.length;\n  let nextChar = pathname.charAt(startIndex);\n  if (nextChar && nextChar !== \"/\") {\n    // pathname does not start with basename/\n    return null;\n  }\n\n  return pathname.slice(startIndex) || \"/\";\n}\n\n/**\n * Returns a resolved path object relative to the given pathname.\n *\n * @see https://reactrouter.com/utils/resolve-path\n */\nexport function resolvePath(to: To, fromPathname = \"/\"): Path {\n  let {\n    pathname: toPathname,\n    search = \"\",\n    hash = \"\",\n  } = typeof to === \"string\" ? parsePath(to) : to;\n\n  let pathname = toPathname\n    ? toPathname.startsWith(\"/\")\n      ? toPathname\n      : resolvePathname(toPathname, fromPathname)\n    : fromPathname;\n\n  return {\n    pathname,\n    search: normalizeSearch(search),\n    hash: normalizeHash(hash),\n  };\n}\n\nfunction resolvePathname(relativePath: string, fromPathname: string): string {\n  let segments = fromPathname.replace(/\\/+$/, \"\").split(\"/\");\n  let relativeSegments = relativePath.split(\"/\");\n\n  relativeSegments.forEach((segment) => {\n    if (segment === \"..\") {\n      // Keep the root \"\" segment so the pathname starts at /\n      if (segments.length > 1) segments.pop();\n    } else if (segment !== \".\") {\n      segments.push(segment);\n    }\n  });\n\n  return segments.length > 1 ? segments.join(\"/\") : \"/\";\n}\n\nfunction getInvalidPathError(\n  char: string,\n  field: string,\n  dest: string,\n  path: Partial<Path>\n) {\n  return (\n    `Cannot include a '${char}' character in a manually specified ` +\n    `\\`to.${field}\\` field [${JSON.stringify(\n      path\n    )}].  Please separate it out to the ` +\n    `\\`to.${dest}\\` field. Alternatively you may provide the full path as ` +\n    `a string in <Link to=\"...\"> and the router will parse it for you.`\n  );\n}\n\n/**\n * @private\n *\n * When processing relative navigation we want to ignore ancestor routes that\n * do not contribute to the path, such that index/pathless layout routes don't\n * interfere.\n *\n * For example, when moving a route element into an index route and/or a\n * pathless layout route, relative link behavior contained within should stay\n * the same.  Both of the following examples should link back to the root:\n *\n *   <Route path=\"/\">\n *     <Route path=\"accounts\" element={<Link to=\"..\"}>\n *   </Route>\n *\n *   <Route path=\"/\">\n *     <Route path=\"accounts\">\n *       <Route element={<AccountsLayout />}>       // <-- Does not contribute\n *         <Route index element={<Link to=\"..\"} />  // <-- Does not contribute\n *       </Route\n *     </Route>\n *   </Route>\n */\nexport function getPathContributingMatches<\n  T extends AgnosticRouteMatch = AgnosticRouteMatch\n>(matches: T[]) {\n  return matches.filter(\n    (match, index) =>\n      index === 0 || (match.route.path && match.route.path.length > 0)\n  );\n}\n\n// Return the array of pathnames for the current route matches - used to\n// generate the routePathnames input for resolveTo()\nexport function getResolveToMatches<\n  T extends AgnosticRouteMatch = AgnosticRouteMatch\n>(matches: T[], v7_relativeSplatPath: boolean) {\n  let pathMatches = getPathContributingMatches(matches);\n\n  // When v7_relativeSplatPath is enabled, use the full pathname for the leaf\n  // match so we include splat values for \".\" links.  See:\n  // https://github.com/remix-run/react-router/issues/11052#issuecomment-1836589329\n  if (v7_relativeSplatPath) {\n    return pathMatches.map((match, idx) =>\n      idx === matches.length - 1 ? match.pathname : match.pathnameBase\n    );\n  }\n\n  return pathMatches.map((match) => match.pathnameBase);\n}\n\n/**\n * @private\n */\nexport function resolveTo(\n  toArg: To,\n  routePathnames: string[],\n  locationPathname: string,\n  isPathRelative = false\n): Path {\n  let to: Partial<Path>;\n  if (typeof toArg === \"string\") {\n    to = parsePath(toArg);\n  } else {\n    to = { ...toArg };\n\n    invariant(\n      !to.pathname || !to.pathname.includes(\"?\"),\n      getInvalidPathError(\"?\", \"pathname\", \"search\", to)\n    );\n    invariant(\n      !to.pathname || !to.pathname.includes(\"#\"),\n      getInvalidPathError(\"#\", \"pathname\", \"hash\", to)\n    );\n    invariant(\n      !to.search || !to.search.includes(\"#\"),\n      getInvalidPathError(\"#\", \"search\", \"hash\", to)\n    );\n  }\n\n  let isEmptyPath = toArg === \"\" || to.pathname === \"\";\n  let toPathname = isEmptyPath ? \"/\" : to.pathname;\n\n  let from: string;\n\n  // Routing is relative to the current pathname if explicitly requested.\n  //\n  // If a pathname is explicitly provided in `to`, it should be relative to the\n  // route context. This is explained in `Note on `<Link to>` values` in our\n  // migration guide from v5 as a means of disambiguation between `to` values\n  // that begin with `/` and those that do not. However, this is problematic for\n  // `to` values that do not provide a pathname. `to` can simply be a search or\n  // hash string, in which case we should assume that the navigation is relative\n  // to the current location's pathname and *not* the route pathname.\n  if (toPathname == null) {\n    from = locationPathname;\n  } else {\n    let routePathnameIndex = routePathnames.length - 1;\n\n    // With relative=\"route\" (the default), each leading .. segment means\n    // \"go up one route\" instead of \"go up one URL segment\".  This is a key\n    // difference from how <a href> works and a major reason we call this a\n    // \"to\" value instead of a \"href\".\n    if (!isPathRelative && toPathname.startsWith(\"..\")) {\n      let toSegments = toPathname.split(\"/\");\n\n      while (toSegments[0] === \"..\") {\n        toSegments.shift();\n        routePathnameIndex -= 1;\n      }\n\n      to.pathname = toSegments.join(\"/\");\n    }\n\n    from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : \"/\";\n  }\n\n  let path = resolvePath(to, from);\n\n  // Ensure the pathname has a trailing slash if the original \"to\" had one\n  let hasExplicitTrailingSlash =\n    toPathname && toPathname !== \"/\" && toPathname.endsWith(\"/\");\n  // Or if this was a link to the current path which has a trailing slash\n  let hasCurrentTrailingSlash =\n    (isEmptyPath || toPathname === \".\") && locationPathname.endsWith(\"/\");\n  if (\n    !path.pathname.endsWith(\"/\") &&\n    (hasExplicitTrailingSlash || hasCurrentTrailingSlash)\n  ) {\n    path.pathname += \"/\";\n  }\n\n  return path;\n}\n\n/**\n * @private\n */\nexport function getToPathname(to: To): string | undefined {\n  // Empty strings should be treated the same as / paths\n  return to === \"\" || (to as Path).pathname === \"\"\n    ? \"/\"\n    : typeof to === \"string\"\n    ? parsePath(to).pathname\n    : to.pathname;\n}\n\n/**\n * @private\n */\nexport const joinPaths = (paths: string[]): string =>\n  paths.join(\"/\").replace(/\\/\\/+/g, \"/\");\n\n/**\n * @private\n */\nexport const normalizePathname = (pathname: string): string =>\n  pathname.replace(/\\/+$/, \"\").replace(/^\\/*/, \"/\");\n\n/**\n * @private\n */\nexport const normalizeSearch = (search: string): string =>\n  !search || search === \"?\"\n    ? \"\"\n    : search.startsWith(\"?\")\n    ? search\n    : \"?\" + search;\n\n/**\n * @private\n */\nexport const normalizeHash = (hash: string): string =>\n  !hash || hash === \"#\" ? \"\" : hash.startsWith(\"#\") ? hash : \"#\" + hash;\n\nexport type JsonFunction = <Data>(\n  data: Data,\n  init?: number | ResponseInit\n) => Response;\n\n/**\n * This is a shortcut for creating `application/json` responses. Converts `data`\n * to JSON and sets the `Content-Type` header.\n */\nexport const json: JsonFunction = (data, init = {}) => {\n  let responseInit = typeof init === \"number\" ? { status: init } : init;\n\n  let headers = new Headers(responseInit.headers);\n  if (!headers.has(\"Content-Type\")) {\n    headers.set(\"Content-Type\", \"application/json; charset=utf-8\");\n  }\n\n  return new Response(JSON.stringify(data), {\n    ...responseInit,\n    headers,\n  });\n};\n\nexport interface TrackedPromise extends Promise<any> {\n  _tracked?: boolean;\n  _data?: any;\n  _error?: any;\n}\n\nexport class AbortedDeferredError extends Error {}\n\nexport class DeferredData {\n  private pendingKeysSet: Set<string> = new Set<string>();\n  private controller: AbortController;\n  private abortPromise: Promise<void>;\n  private unlistenAbortSignal: () => void;\n  private subscribers: Set<(aborted: boolean, settledKey?: string) => void> =\n    new Set();\n  data: Record<string, unknown>;\n  init?: ResponseInit;\n  deferredKeys: string[] = [];\n\n  constructor(data: Record<string, unknown>, responseInit?: ResponseInit) {\n    invariant(\n      data && typeof data === \"object\" && !Array.isArray(data),\n      \"defer() only accepts plain objects\"\n    );\n\n    // Set up an AbortController + Promise we can race against to exit early\n    // cancellation\n    let reject: (e: AbortedDeferredError) => void;\n    this.abortPromise = new Promise((_, r) => (reject = r));\n    this.controller = new AbortController();\n    let onAbort = () =>\n      reject(new AbortedDeferredError(\"Deferred data aborted\"));\n    this.unlistenAbortSignal = () =>\n      this.controller.signal.removeEventListener(\"abort\", onAbort);\n    this.controller.signal.addEventListener(\"abort\", onAbort);\n\n    this.data = Object.entries(data).reduce(\n      (acc, [key, value]) =>\n        Object.assign(acc, {\n          [key]: this.trackPromise(key, value),\n        }),\n      {}\n    );\n\n    if (this.done) {\n      // All incoming values were resolved\n      this.unlistenAbortSignal();\n    }\n\n    this.init = responseInit;\n  }\n\n  private trackPromise(\n    key: string,\n    value: Promise<unknown> | unknown\n  ): TrackedPromise | unknown {\n    if (!(value instanceof Promise)) {\n      return value;\n    }\n\n    this.deferredKeys.push(key);\n    this.pendingKeysSet.add(key);\n\n    // We store a little wrapper promise that will be extended with\n    // _data/_error props upon resolve/reject\n    let promise: TrackedPromise = Promise.race([value, this.abortPromise]).then(\n      (data) => this.onSettle(promise, key, undefined, data as unknown),\n      (error) => this.onSettle(promise, key, error as unknown)\n    );\n\n    // Register rejection listeners to avoid uncaught promise rejections on\n    // errors or aborted deferred values\n    promise.catch(() => {});\n\n    Object.defineProperty(promise, \"_tracked\", { get: () => true });\n    return promise;\n  }\n\n  private onSettle(\n    promise: TrackedPromise,\n    key: string,\n    error: unknown,\n    data?: unknown\n  ): unknown {\n    if (\n      this.controller.signal.aborted &&\n      error instanceof AbortedDeferredError\n    ) {\n      this.unlistenAbortSignal();\n      Object.defineProperty(promise, \"_error\", { get: () => error });\n      return Promise.reject(error);\n    }\n\n    this.pendingKeysSet.delete(key);\n\n    if (this.done) {\n      // Nothing left to abort!\n      this.unlistenAbortSignal();\n    }\n\n    // If the promise was resolved/rejected with undefined, we'll throw an error as you\n    // should always resolve with a value or null\n    if (error === undefined && data === undefined) {\n      let undefinedError = new Error(\n        `Deferred data for key \"${key}\" resolved/rejected with \\`undefined\\`, ` +\n          `you must resolve/reject with a value or \\`null\\`.`\n      );\n      Object.defineProperty(promise, \"_error\", { get: () => undefinedError });\n      this.emit(false, key);\n      return Promise.reject(undefinedError);\n    }\n\n    if (data === undefined) {\n      Object.defineProperty(promise, \"_error\", { get: () => error });\n      this.emit(false, key);\n      return Promise.reject(error);\n    }\n\n    Object.defineProperty(promise, \"_data\", { get: () => data });\n    this.emit(false, key);\n    return data;\n  }\n\n  private emit(aborted: boolean, settledKey?: string) {\n    this.subscribers.forEach((subscriber) => subscriber(aborted, settledKey));\n  }\n\n  subscribe(fn: (aborted: boolean, settledKey?: string) => void) {\n    this.subscribers.add(fn);\n    return () => this.subscribers.delete(fn);\n  }\n\n  cancel() {\n    this.controller.abort();\n    this.pendingKeysSet.forEach((v, k) => this.pendingKeysSet.delete(k));\n    this.emit(true);\n  }\n\n  async resolveData(signal: AbortSignal) {\n    let aborted = false;\n    if (!this.done) {\n      let onAbort = () => this.cancel();\n      signal.addEventListener(\"abort\", onAbort);\n      aborted = await new Promise((resolve) => {\n        this.subscribe((aborted) => {\n          signal.removeEventListener(\"abort\", onAbort);\n          if (aborted || this.done) {\n            resolve(aborted);\n          }\n        });\n      });\n    }\n    return aborted;\n  }\n\n  get done() {\n    return this.pendingKeysSet.size === 0;\n  }\n\n  get unwrappedData() {\n    invariant(\n      this.data !== null && this.done,\n      \"Can only unwrap data on initialized and settled deferreds\"\n    );\n\n    return Object.entries(this.data).reduce(\n      (acc, [key, value]) =>\n        Object.assign(acc, {\n          [key]: unwrapTrackedPromise(value),\n        }),\n      {}\n    );\n  }\n\n  get pendingKeys() {\n    return Array.from(this.pendingKeysSet);\n  }\n}\n\nfunction isTrackedPromise(value: any): value is TrackedPromise {\n  return (\n    value instanceof Promise && (value as TrackedPromise)._tracked === true\n  );\n}\n\nfunction unwrapTrackedPromise(value: any) {\n  if (!isTrackedPromise(value)) {\n    return value;\n  }\n\n  if (value._error) {\n    throw value._error;\n  }\n  return value._data;\n}\n\nexport type DeferFunction = (\n  data: Record<string, unknown>,\n  init?: number | ResponseInit\n) => DeferredData;\n\nexport const defer: DeferFunction = (data, init = {}) => {\n  let responseInit = typeof init === \"number\" ? { status: init } : init;\n\n  return new DeferredData(data, responseInit);\n};\n\nexport type RedirectFunction = (\n  url: string,\n  init?: number | ResponseInit\n) => Response;\n\n/**\n * A redirect response. Sets the status code and the `Location` header.\n * Defaults to \"302 Found\".\n */\nexport const redirect: RedirectFunction = (url, init = 302) => {\n  let responseInit = init;\n  if (typeof responseInit === \"number\") {\n    responseInit = { status: responseInit };\n  } else if (typeof responseInit.status === \"undefined\") {\n    responseInit.status = 302;\n  }\n\n  let headers = new Headers(responseInit.headers);\n  headers.set(\"Location\", url);\n\n  return new Response(null, {\n    ...responseInit,\n    headers,\n  });\n};\n\n/**\n * A redirect response that will force a document reload to the new location.\n * Sets the status code and the `Location` header.\n * Defaults to \"302 Found\".\n */\nexport const redirectDocument: RedirectFunction = (url, init) => {\n  let response = redirect(url, init);\n  response.headers.set(\"X-Remix-Reload-Document\", \"true\");\n  return response;\n};\n\nexport type ErrorResponse = {\n  status: number;\n  statusText: string;\n  data: any;\n};\n\n/**\n * @private\n * Utility class we use to hold auto-unwrapped 4xx/5xx Response bodies\n *\n * We don't export the class for public use since it's an implementation\n * detail, but we export the interface above so folks can build their own\n * abstractions around instances via isRouteErrorResponse()\n */\nexport class ErrorResponseImpl implements ErrorResponse {\n  status: number;\n  statusText: string;\n  data: any;\n  private error?: Error;\n  private internal: boolean;\n\n  constructor(\n    status: number,\n    statusText: string | undefined,\n    data: any,\n    internal = false\n  ) {\n    this.status = status;\n    this.statusText = statusText || \"\";\n    this.internal = internal;\n    if (data instanceof Error) {\n      this.data = data.toString();\n      this.error = data;\n    } else {\n      this.data = data;\n    }\n  }\n}\n\n/**\n * Check if the given error is an ErrorResponse generated from a 4xx/5xx\n * Response thrown from an action/loader\n */\nexport function isRouteErrorResponse(error: any): error is ErrorResponse {\n  return (\n    error != null &&\n    typeof error.status === \"number\" &&\n    typeof error.statusText === \"string\" &&\n    typeof error.internal === \"boolean\" &&\n    \"data\" in error\n  );\n}\n", "import type { History, Location, Path, To } from \"./history\";\nimport {\n  Action as HistoryAction,\n  createLocation,\n  createPath,\n  invariant,\n  parsePath,\n  warning,\n} from \"./history\";\nimport type {\n  ActionFunction,\n  AgnosticDataRouteMatch,\n  AgnosticDataRouteObject,\n  AgnosticRouteObject,\n  DataResult,\n  DeferredData,\n  DeferredResult,\n  DetectErrorBoundaryFunction,\n  ErrorResult,\n  FormEncType,\n  FormMethod,\n  HTMLFormMethod,\n  ImmutableRouteKey,\n  LoaderFunction,\n  MapRoutePropertiesFunction,\n  MutationFormMethod,\n  RedirectResult,\n  RouteData,\n  RouteManifest,\n  ShouldRevalidateFunctionArgs,\n  Submission,\n  SuccessResult,\n  UIMatch,\n  V7_FormMethod,\n  V7_MutationFormMethod,\n} from \"./utils\";\nimport {\n  ErrorResponseImpl,\n  ResultType,\n  convertRouteMatchToUiMatch,\n  convertRoutesToDataRoutes,\n  getPathContributingMatches,\n  getResolveToMatches,\n  immutableRouteKeys,\n  isRouteErrorResponse,\n  joinPaths,\n  matchRoutes,\n  resolveTo,\n  stripBasename,\n} from \"./utils\";\n\n////////////////////////////////////////////////////////////////////////////////\n//#region Types and Constants\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * A Router instance manages all navigation and data loading/mutations\n */\nexport interface Router {\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Return the basename for the router\n   */\n  get basename(): RouterInit[\"basename\"];\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Return the future config for the router\n   */\n  get future(): FutureConfig;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Return the current state of the router\n   */\n  get state(): RouterState;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Return the routes for this router instance\n   */\n  get routes(): AgnosticDataRouteObject[];\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Return the window associated with the router\n   */\n  get window(): RouterInit[\"window\"];\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Initialize the router, including adding history listeners and kicking off\n   * initial data fetches.  Returns a function to cleanup listeners and abort\n   * any in-progress loads\n   */\n  initialize(): Router;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Subscribe to router.state updates\n   *\n   * @param fn function to call with the new state\n   */\n  subscribe(fn: RouterSubscriber): () => void;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Enable scroll restoration behavior in the router\n   *\n   * @param savedScrollPositions Object that will manage positions, in case\n   *                             it's being restored from sessionStorage\n   * @param getScrollPosition    Function to get the active Y scroll position\n   * @param getKey               Function to get the key to use for restoration\n   */\n  enableScrollRestoration(\n    savedScrollPositions: Record<string, number>,\n    getScrollPosition: GetScrollPositionFunction,\n    getKey?: GetScrollRestorationKeyFunction\n  ): () => void;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Navigate forward/backward in the history stack\n   * @param to Delta to move in the history stack\n   */\n  navigate(to: number): Promise<void>;\n\n  /**\n   * Navigate to the given path\n   * @param to Path to navigate to\n   * @param opts Navigation options (method, submission, etc.)\n   */\n  navigate(to: To | null, opts?: RouterNavigateOptions): Promise<void>;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Trigger a fetcher load/submission\n   *\n   * @param key     Fetcher key\n   * @param routeId Route that owns the fetcher\n   * @param href    href to fetch\n   * @param opts    Fetcher options, (method, submission, etc.)\n   */\n  fetch(\n    key: string,\n    routeId: string,\n    href: string | null,\n    opts?: RouterFetchOptions\n  ): void;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Trigger a revalidation of all current route loaders and fetcher loads\n   */\n  revalidate(): void;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Utility function to create an href for the given location\n   * @param location\n   */\n  createHref(location: Location | URL): string;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Utility function to URL encode a destination path according to the internal\n   * history implementation\n   * @param to\n   */\n  encodeLocation(to: To): Path;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Get/create a fetcher for the given key\n   * @param key\n   */\n  getFetcher<TData = any>(key: string): Fetcher<TData>;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Delete the fetcher for a given key\n   * @param key\n   */\n  deleteFetcher(key: string): void;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Cleanup listeners and abort any in-progress loads\n   */\n  dispose(): void;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Get a navigation blocker\n   * @param key The identifier for the blocker\n   * @param fn The blocker function implementation\n   */\n  getBlocker(key: string, fn: BlockerFunction): Blocker;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Delete a navigation blocker\n   * @param key The identifier for the blocker\n   */\n  deleteBlocker(key: string): void;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * HMR needs to pass in-flight route updates to React Router\n   * TODO: Replace this with granular route update APIs (addRoute, updateRoute, deleteRoute)\n   */\n  _internalSetRoutes(routes: AgnosticRouteObject[]): void;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Internal fetch AbortControllers accessed by unit tests\n   */\n  _internalFetchControllers: Map<string, AbortController>;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Internal pending DeferredData instances accessed by unit tests\n   */\n  _internalActiveDeferreds: Map<string, DeferredData>;\n}\n\n/**\n * State maintained internally by the router.  During a navigation, all states\n * reflect the the \"old\" location unless otherwise noted.\n */\nexport interface RouterState {\n  /**\n   * The action of the most recent navigation\n   */\n  historyAction: HistoryAction;\n\n  /**\n   * The current location reflected by the router\n   */\n  location: Location;\n\n  /**\n   * The current set of route matches\n   */\n  matches: AgnosticDataRouteMatch[];\n\n  /**\n   * Tracks whether we've completed our initial data load\n   */\n  initialized: boolean;\n\n  /**\n   * Current scroll position we should start at for a new view\n   *  - number -> scroll position to restore to\n   *  - false -> do not restore scroll at all (used during submissions)\n   *  - null -> don't have a saved position, scroll to hash or top of page\n   */\n  restoreScrollPosition: number | false | null;\n\n  /**\n   * Indicate whether this navigation should skip resetting the scroll position\n   * if we are unable to restore the scroll position\n   */\n  preventScrollReset: boolean;\n\n  /**\n   * Tracks the state of the current navigation\n   */\n  navigation: Navigation;\n\n  /**\n   * Tracks any in-progress revalidations\n   */\n  revalidation: RevalidationState;\n\n  /**\n   * Data from the loaders for the current matches\n   */\n  loaderData: RouteData;\n\n  /**\n   * Data from the action for the current matches\n   */\n  actionData: RouteData | null;\n\n  /**\n   * Errors caught from loaders for the current matches\n   */\n  errors: RouteData | null;\n\n  /**\n   * Map of current fetchers\n   */\n  fetchers: Map<string, Fetcher>;\n\n  /**\n   * Map of current blockers\n   */\n  blockers: Map<string, Blocker>;\n}\n\n/**\n * Data that can be passed into hydrate a Router from SSR\n */\nexport type HydrationState = Partial<\n  Pick<RouterState, \"loaderData\" | \"actionData\" | \"errors\">\n>;\n\n/**\n * Future flags to toggle new feature behavior\n */\nexport interface FutureConfig {\n  v7_fetcherPersist: boolean;\n  v7_normalizeFormMethod: boolean;\n  v7_partialHydration: boolean;\n  v7_prependBasename: boolean;\n  v7_relativeSplatPath: boolean;\n}\n\n/**\n * Initialization options for createRouter\n */\nexport interface RouterInit {\n  routes: AgnosticRouteObject[];\n  history: History;\n  basename?: string;\n  /**\n   * @deprecated Use `mapRouteProperties` instead\n   */\n  detectErrorBoundary?: DetectErrorBoundaryFunction;\n  mapRouteProperties?: MapRoutePropertiesFunction;\n  future?: Partial<FutureConfig>;\n  hydrationData?: HydrationState;\n  window?: Window;\n}\n\n/**\n * State returned from a server-side query() call\n */\nexport interface StaticHandlerContext {\n  basename: Router[\"basename\"];\n  location: RouterState[\"location\"];\n  matches: RouterState[\"matches\"];\n  loaderData: RouterState[\"loaderData\"];\n  actionData: RouterState[\"actionData\"];\n  errors: RouterState[\"errors\"];\n  statusCode: number;\n  loaderHeaders: Record<string, Headers>;\n  actionHeaders: Record<string, Headers>;\n  activeDeferreds: Record<string, DeferredData> | null;\n  _deepestRenderedBoundaryId?: string | null;\n}\n\n/**\n * A StaticHandler instance manages a singular SSR navigation/fetch event\n */\nexport interface StaticHandler {\n  dataRoutes: AgnosticDataRouteObject[];\n  query(\n    request: Request,\n    opts?: { requestContext?: unknown }\n  ): Promise<StaticHandlerContext | Response>;\n  queryRoute(\n    request: Request,\n    opts?: { routeId?: string; requestContext?: unknown }\n  ): Promise<any>;\n}\n\ntype ViewTransitionOpts = {\n  currentLocation: Location;\n  nextLocation: Location;\n};\n\n/**\n * Subscriber function signature for changes to router state\n */\nexport interface RouterSubscriber {\n  (\n    state: RouterState,\n    opts: {\n      deletedFetchers: string[];\n      unstable_viewTransitionOpts?: ViewTransitionOpts;\n      unstable_flushSync: boolean;\n    }\n  ): void;\n}\n\n/**\n * Function signature for determining the key to be used in scroll restoration\n * for a given location\n */\nexport interface GetScrollRestorationKeyFunction {\n  (location: Location, matches: UIMatch[]): string | null;\n}\n\n/**\n * Function signature for determining the current scroll position\n */\nexport interface GetScrollPositionFunction {\n  (): number;\n}\n\nexport type RelativeRoutingType = \"route\" | \"path\";\n\n// Allowed for any navigation or fetch\ntype BaseNavigateOrFetchOptions = {\n  preventScrollReset?: boolean;\n  relative?: RelativeRoutingType;\n  unstable_flushSync?: boolean;\n};\n\n// Only allowed for navigations\ntype BaseNavigateOptions = BaseNavigateOrFetchOptions & {\n  replace?: boolean;\n  state?: any;\n  fromRouteId?: string;\n  unstable_viewTransition?: boolean;\n};\n\n// Only allowed for submission navigations\ntype BaseSubmissionOptions = {\n  formMethod?: HTMLFormMethod;\n  formEncType?: FormEncType;\n} & (\n  | { formData: FormData; body?: undefined }\n  | { formData?: undefined; body: any }\n);\n\n/**\n * Options for a navigate() call for a normal (non-submission) navigation\n */\ntype LinkNavigateOptions = BaseNavigateOptions;\n\n/**\n * Options for a navigate() call for a submission navigation\n */\ntype SubmissionNavigateOptions = BaseNavigateOptions & BaseSubmissionOptions;\n\n/**\n * Options to pass to navigate() for a navigation\n */\nexport type RouterNavigateOptions =\n  | LinkNavigateOptions\n  | SubmissionNavigateOptions;\n\n/**\n * Options for a fetch() load\n */\ntype LoadFetchOptions = BaseNavigateOrFetchOptions;\n\n/**\n * Options for a fetch() submission\n */\ntype SubmitFetchOptions = BaseNavigateOrFetchOptions & BaseSubmissionOptions;\n\n/**\n * Options to pass to fetch()\n */\nexport type RouterFetchOptions = LoadFetchOptions | SubmitFetchOptions;\n\n/**\n * Potential states for state.navigation\n */\nexport type NavigationStates = {\n  Idle: {\n    state: \"idle\";\n    location: undefined;\n    formMethod: undefined;\n    formAction: undefined;\n    formEncType: undefined;\n    formData: undefined;\n    json: undefined;\n    text: undefined;\n  };\n  Loading: {\n    state: \"loading\";\n    location: Location;\n    formMethod: Submission[\"formMethod\"] | undefined;\n    formAction: Submission[\"formAction\"] | undefined;\n    formEncType: Submission[\"formEncType\"] | undefined;\n    formData: Submission[\"formData\"] | undefined;\n    json: Submission[\"json\"] | undefined;\n    text: Submission[\"text\"] | undefined;\n  };\n  Submitting: {\n    state: \"submitting\";\n    location: Location;\n    formMethod: Submission[\"formMethod\"];\n    formAction: Submission[\"formAction\"];\n    formEncType: Submission[\"formEncType\"];\n    formData: Submission[\"formData\"];\n    json: Submission[\"json\"];\n    text: Submission[\"text\"];\n  };\n};\n\nexport type Navigation = NavigationStates[keyof NavigationStates];\n\nexport type RevalidationState = \"idle\" | \"loading\";\n\n/**\n * Potential states for fetchers\n */\ntype FetcherStates<TData = any> = {\n  Idle: {\n    state: \"idle\";\n    formMethod: undefined;\n    formAction: undefined;\n    formEncType: undefined;\n    text: undefined;\n    formData: undefined;\n    json: undefined;\n    data: TData | undefined;\n  };\n  Loading: {\n    state: \"loading\";\n    formMethod: Submission[\"formMethod\"] | undefined;\n    formAction: Submission[\"formAction\"] | undefined;\n    formEncType: Submission[\"formEncType\"] | undefined;\n    text: Submission[\"text\"] | undefined;\n    formData: Submission[\"formData\"] | undefined;\n    json: Submission[\"json\"] | undefined;\n    data: TData | undefined;\n  };\n  Submitting: {\n    state: \"submitting\";\n    formMethod: Submission[\"formMethod\"];\n    formAction: Submission[\"formAction\"];\n    formEncType: Submission[\"formEncType\"];\n    text: Submission[\"text\"];\n    formData: Submission[\"formData\"];\n    json: Submission[\"json\"];\n    data: TData | undefined;\n  };\n};\n\nexport type Fetcher<TData = any> =\n  FetcherStates<TData>[keyof FetcherStates<TData>];\n\ninterface BlockerBlocked {\n  state: \"blocked\";\n  reset(): void;\n  proceed(): void;\n  location: Location;\n}\n\ninterface BlockerUnblocked {\n  state: \"unblocked\";\n  reset: undefined;\n  proceed: undefined;\n  location: undefined;\n}\n\ninterface BlockerProceeding {\n  state: \"proceeding\";\n  reset: undefined;\n  proceed: undefined;\n  location: Location;\n}\n\nexport type Blocker = BlockerUnblocked | BlockerBlocked | BlockerProceeding;\n\nexport type BlockerFunction = (args: {\n  currentLocation: Location;\n  nextLocation: Location;\n  historyAction: HistoryAction;\n}) => boolean;\n\ninterface ShortCircuitable {\n  /**\n   * startNavigation does not need to complete the navigation because we\n   * redirected or got interrupted\n   */\n  shortCircuited?: boolean;\n}\n\ninterface HandleActionResult extends ShortCircuitable {\n  /**\n   * Error thrown from the current action, keyed by the route containing the\n   * error boundary to render the error.  To be committed to the state after\n   * loaders have completed\n   */\n  pendingActionError?: RouteData;\n  /**\n   * Data returned from the current action, keyed by the route owning the action.\n   * To be committed to the state after loaders have completed\n   */\n  pendingActionData?: RouteData;\n}\n\ninterface HandleLoadersResult extends ShortCircuitable {\n  /**\n   * loaderData returned from the current set of loaders\n   */\n  loaderData?: RouterState[\"loaderData\"];\n  /**\n   * errors thrown from the current set of loaders\n   */\n  errors?: RouterState[\"errors\"];\n}\n\n/**\n * Cached info for active fetcher.load() instances so they can participate\n * in revalidation\n */\ninterface FetchLoadMatch {\n  routeId: string;\n  path: string;\n}\n\n/**\n * Identified fetcher.load() calls that need to be revalidated\n */\ninterface RevalidatingFetcher extends FetchLoadMatch {\n  key: string;\n  match: AgnosticDataRouteMatch | null;\n  matches: AgnosticDataRouteMatch[] | null;\n  controller: AbortController | null;\n}\n\n/**\n * Wrapper object to allow us to throw any response out from callLoaderOrAction\n * for queryRouter while preserving whether or not it was thrown or returned\n * from the loader/action\n */\ninterface QueryRouteResponse {\n  type: ResultType.data | ResultType.error;\n  response: Response;\n}\n\nconst validMutationMethodsArr: MutationFormMethod[] = [\n  \"post\",\n  \"put\",\n  \"patch\",\n  \"delete\",\n];\nconst validMutationMethods = new Set<MutationFormMethod>(\n  validMutationMethodsArr\n);\n\nconst validRequestMethodsArr: FormMethod[] = [\n  \"get\",\n  ...validMutationMethodsArr,\n];\nconst validRequestMethods = new Set<FormMethod>(validRequestMethodsArr);\n\nconst redirectStatusCodes = new Set([301, 302, 303, 307, 308]);\nconst redirectPreserveMethodStatusCodes = new Set([307, 308]);\n\nexport const IDLE_NAVIGATION: NavigationStates[\"Idle\"] = {\n  state: \"idle\",\n  location: undefined,\n  formMethod: undefined,\n  formAction: undefined,\n  formEncType: undefined,\n  formData: undefined,\n  json: undefined,\n  text: undefined,\n};\n\nexport const IDLE_FETCHER: FetcherStates[\"Idle\"] = {\n  state: \"idle\",\n  data: undefined,\n  formMethod: undefined,\n  formAction: undefined,\n  formEncType: undefined,\n  formData: undefined,\n  json: undefined,\n  text: undefined,\n};\n\nexport const IDLE_BLOCKER: BlockerUnblocked = {\n  state: \"unblocked\",\n  proceed: undefined,\n  reset: undefined,\n  location: undefined,\n};\n\nconst ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\\/\\/)/i;\n\nconst defaultMapRouteProperties: MapRoutePropertiesFunction = (route) => ({\n  hasErrorBoundary: Boolean(route.hasErrorBoundary),\n});\n\nconst TRANSITIONS_STORAGE_KEY = \"remix-router-transitions\";\n\n//#endregion\n\n////////////////////////////////////////////////////////////////////////////////\n//#region createRouter\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * Create a router and listen to history POP navigations\n */\nexport function createRouter(init: RouterInit): Router {\n  const routerWindow = init.window\n    ? init.window\n    : typeof window !== \"undefined\"\n    ? window\n    : undefined;\n  const isBrowser =\n    typeof routerWindow !== \"undefined\" &&\n    typeof routerWindow.document !== \"undefined\" &&\n    typeof routerWindow.document.createElement !== \"undefined\";\n  const isServer = !isBrowser;\n\n  invariant(\n    init.routes.length > 0,\n    \"You must provide a non-empty routes array to createRouter\"\n  );\n\n  let mapRouteProperties: MapRoutePropertiesFunction;\n  if (init.mapRouteProperties) {\n    mapRouteProperties = init.mapRouteProperties;\n  } else if (init.detectErrorBoundary) {\n    // If they are still using the deprecated version, wrap it with the new API\n    let detectErrorBoundary = init.detectErrorBoundary;\n    mapRouteProperties = (route) => ({\n      hasErrorBoundary: detectErrorBoundary(route),\n    });\n  } else {\n    mapRouteProperties = defaultMapRouteProperties;\n  }\n\n  // Routes keyed by ID\n  let manifest: RouteManifest = {};\n  // Routes in tree format for matching\n  let dataRoutes = convertRoutesToDataRoutes(\n    init.routes,\n    mapRouteProperties,\n    undefined,\n    manifest\n  );\n  let inFlightDataRoutes: AgnosticDataRouteObject[] | undefined;\n  let basename = init.basename || \"/\";\n  // Config driven behavior flags\n  let future: FutureConfig = {\n    v7_fetcherPersist: false,\n    v7_normalizeFormMethod: false,\n    v7_partialHydration: false,\n    v7_prependBasename: false,\n    v7_relativeSplatPath: false,\n    ...init.future,\n  };\n  // Cleanup function for history\n  let unlistenHistory: (() => void) | null = null;\n  // Externally-provided functions to call on all state changes\n  let subscribers = new Set<RouterSubscriber>();\n  // Externally-provided object to hold scroll restoration locations during routing\n  let savedScrollPositions: Record<string, number> | null = null;\n  // Externally-provided function to get scroll restoration keys\n  let getScrollRestorationKey: GetScrollRestorationKeyFunction | null = null;\n  // Externally-provided function to get current scroll position\n  let getScrollPosition: GetScrollPositionFunction | null = null;\n  // One-time flag to control the initial hydration scroll restoration.  Because\n  // we don't get the saved positions from <ScrollRestoration /> until _after_\n  // the initial render, we need to manually trigger a separate updateState to\n  // send along the restoreScrollPosition\n  // Set to true if we have `hydrationData` since we assume we were SSR'd and that\n  // SSR did the initial scroll restoration.\n  let initialScrollRestored = init.hydrationData != null;\n\n  let initialMatches = matchRoutes(dataRoutes, init.history.location, basename);\n  let initialErrors: RouteData | null = null;\n\n  if (initialMatches == null) {\n    // If we do not match a user-provided-route, fall back to the root\n    // to allow the error boundary to take over\n    let error = getInternalRouterError(404, {\n      pathname: init.history.location.pathname,\n    });\n    let { matches, route } = getShortCircuitMatches(dataRoutes);\n    initialMatches = matches;\n    initialErrors = { [route.id]: error };\n  }\n\n  let initialized: boolean;\n  let hasLazyRoutes = initialMatches.some((m) => m.route.lazy);\n  let hasLoaders = initialMatches.some((m) => m.route.loader);\n  if (hasLazyRoutes) {\n    // All initialMatches need to be loaded before we're ready.  If we have lazy\n    // functions around still then we'll need to run them in initialize()\n    initialized = false;\n  } else if (!hasLoaders) {\n    // If we've got no loaders to run, then we're good to go\n    initialized = true;\n  } else if (future.v7_partialHydration) {\n    // If partial hydration is enabled, we're initialized so long as we were\n    // provided with hydrationData for every route with a loader, and no loaders\n    // were marked for explicit hydration\n    let loaderData = init.hydrationData ? init.hydrationData.loaderData : null;\n    let errors = init.hydrationData ? init.hydrationData.errors : null;\n    initialized = initialMatches.every(\n      (m) =>\n        m.route.loader &&\n        m.route.loader.hydrate !== true &&\n        ((loaderData && loaderData[m.route.id] !== undefined) ||\n          (errors && errors[m.route.id] !== undefined))\n    );\n  } else {\n    // Without partial hydration - we're initialized if we were provided any\n    // hydrationData - which is expected to be complete\n    initialized = init.hydrationData != null;\n  }\n\n  let router: Router;\n  let state: RouterState = {\n    historyAction: init.history.action,\n    location: init.history.location,\n    matches: initialMatches,\n    initialized,\n    navigation: IDLE_NAVIGATION,\n    // Don't restore on initial updateState() if we were SSR'd\n    restoreScrollPosition: init.hydrationData != null ? false : null,\n    preventScrollReset: false,\n    revalidation: \"idle\",\n    loaderData: (init.hydrationData && init.hydrationData.loaderData) || {},\n    actionData: (init.hydrationData && init.hydrationData.actionData) || null,\n    errors: (init.hydrationData && init.hydrationData.errors) || initialErrors,\n    fetchers: new Map(),\n    blockers: new Map(),\n  };\n\n  // -- Stateful internal variables to manage navigations --\n  // Current navigation in progress (to be committed in completeNavigation)\n  let pendingAction: HistoryAction = HistoryAction.Pop;\n\n  // Should the current navigation prevent the scroll reset if scroll cannot\n  // be restored?\n  let pendingPreventScrollReset = false;\n\n  // AbortController for the active navigation\n  let pendingNavigationController: AbortController | null;\n\n  // Should the current navigation enable document.startViewTransition?\n  let pendingViewTransitionEnabled = false;\n\n  // Store applied view transitions so we can apply them on POP\n  let appliedViewTransitions: Map<string, Set<string>> = new Map<\n    string,\n    Set<string>\n  >();\n\n  // Cleanup function for persisting applied transitions to sessionStorage\n  let removePageHideEventListener: (() => void) | null = null;\n\n  // We use this to avoid touching history in completeNavigation if a\n  // revalidation is entirely uninterrupted\n  let isUninterruptedRevalidation = false;\n\n  // Use this internal flag to force revalidation of all loaders:\n  //  - submissions (completed or interrupted)\n  //  - useRevalidator()\n  //  - X-Remix-Revalidate (from redirect)\n  let isRevalidationRequired = false;\n\n  // Use this internal array to capture routes that require revalidation due\n  // to a cancelled deferred on action submission\n  let cancelledDeferredRoutes: string[] = [];\n\n  // Use this internal array to capture fetcher loads that were cancelled by an\n  // action navigation and require revalidation\n  let cancelledFetcherLoads: string[] = [];\n\n  // AbortControllers for any in-flight fetchers\n  let fetchControllers = new Map<string, AbortController>();\n\n  // Track loads based on the order in which they started\n  let incrementingLoadId = 0;\n\n  // Track the outstanding pending navigation data load to be compared against\n  // the globally incrementing load when a fetcher load lands after a completed\n  // navigation\n  let pendingNavigationLoadId = -1;\n\n  // Fetchers that triggered data reloads as a result of their actions\n  let fetchReloadIds = new Map<string, number>();\n\n  // Fetchers that triggered redirect navigations\n  let fetchRedirectIds = new Set<string>();\n\n  // Most recent href/match for fetcher.load calls for fetchers\n  let fetchLoadMatches = new Map<string, FetchLoadMatch>();\n\n  // Ref-count mounted fetchers so we know when it's ok to clean them up\n  let activeFetchers = new Map<string, number>();\n\n  // Fetchers that have requested a delete when using v7_fetcherPersist,\n  // they'll be officially removed after they return to idle\n  let deletedFetchers = new Set<string>();\n\n  // Store DeferredData instances for active route matches.  When a\n  // route loader returns defer() we stick one in here.  Then, when a nested\n  // promise resolves we update loaderData.  If a new navigation starts we\n  // cancel active deferreds for eliminated routes.\n  let activeDeferreds = new Map<string, DeferredData>();\n\n  // Store blocker functions in a separate Map outside of router state since\n  // we don't need to update UI state if they change\n  let blockerFunctions = new Map<string, BlockerFunction>();\n\n  // Flag to ignore the next history update, so we can revert the URL change on\n  // a POP navigation that was blocked by the user without touching router state\n  let ignoreNextHistoryUpdate = false;\n\n  // Initialize the router, all side effects should be kicked off from here.\n  // Implemented as a Fluent API for ease of:\n  //   let router = createRouter(init).initialize();\n  function initialize() {\n    // If history informs us of a POP navigation, start the navigation but do not update\n    // state.  We'll update our own state once the navigation completes\n    unlistenHistory = init.history.listen(\n      ({ action: historyAction, location, delta }) => {\n        // Ignore this event if it was just us resetting the URL from a\n        // blocked POP navigation\n        if (ignoreNextHistoryUpdate) {\n          ignoreNextHistoryUpdate = false;\n          return;\n        }\n\n        warning(\n          blockerFunctions.size === 0 || delta != null,\n          \"You are trying to use a blocker on a POP navigation to a location \" +\n            \"that was not created by @remix-run/router. This will fail silently in \" +\n            \"production. This can happen if you are navigating outside the router \" +\n            \"via `window.history.pushState`/`window.location.hash` instead of using \" +\n            \"router navigation APIs.  This can also happen if you are using \" +\n            \"createHashRouter and the user manually changes the URL.\"\n        );\n\n        let blockerKey = shouldBlockNavigation({\n          currentLocation: state.location,\n          nextLocation: location,\n          historyAction,\n        });\n\n        if (blockerKey && delta != null) {\n          // Restore the URL to match the current UI, but don't update router state\n          ignoreNextHistoryUpdate = true;\n          init.history.go(delta * -1);\n\n          // Put the blocker into a blocked state\n          updateBlocker(blockerKey, {\n            state: \"blocked\",\n            location,\n            proceed() {\n              updateBlocker(blockerKey!, {\n                state: \"proceeding\",\n                proceed: undefined,\n                reset: undefined,\n                location,\n              });\n              // Re-do the same POP navigation we just blocked\n              init.history.go(delta);\n            },\n            reset() {\n              let blockers = new Map(state.blockers);\n              blockers.set(blockerKey!, IDLE_BLOCKER);\n              updateState({ blockers });\n            },\n          });\n          return;\n        }\n\n        return startNavigation(historyAction, location);\n      }\n    );\n\n    if (isBrowser) {\n      // FIXME: This feels gross.  How can we cleanup the lines between\n      // scrollRestoration/appliedTransitions persistance?\n      restoreAppliedTransitions(routerWindow, appliedViewTransitions);\n      let _saveAppliedTransitions = () =>\n        persistAppliedTransitions(routerWindow, appliedViewTransitions);\n      routerWindow.addEventListener(\"pagehide\", _saveAppliedTransitions);\n      removePageHideEventListener = () =>\n        routerWindow.removeEventListener(\"pagehide\", _saveAppliedTransitions);\n    }\n\n    // Kick off initial data load if needed.  Use Pop to avoid modifying history\n    // Note we don't do any handling of lazy here.  For SPA's it'll get handled\n    // in the normal navigation flow.  For SSR it's expected that lazy modules are\n    // resolved prior to router creation since we can't go into a fallbackElement\n    // UI for SSR'd apps\n    if (!state.initialized) {\n      startNavigation(HistoryAction.Pop, state.location, {\n        initialHydration: true,\n      });\n    }\n\n    return router;\n  }\n\n  // Clean up a router and it's side effects\n  function dispose() {\n    if (unlistenHistory) {\n      unlistenHistory();\n    }\n    if (removePageHideEventListener) {\n      removePageHideEventListener();\n    }\n    subscribers.clear();\n    pendingNavigationController && pendingNavigationController.abort();\n    state.fetchers.forEach((_, key) => deleteFetcher(key));\n    state.blockers.forEach((_, key) => deleteBlocker(key));\n  }\n\n  // Subscribe to state updates for the router\n  function subscribe(fn: RouterSubscriber) {\n    subscribers.add(fn);\n    return () => subscribers.delete(fn);\n  }\n\n  // Update our state and notify the calling context of the change\n  function updateState(\n    newState: Partial<RouterState>,\n    opts: {\n      flushSync?: boolean;\n      viewTransitionOpts?: ViewTransitionOpts;\n    } = {}\n  ): void {\n    state = {\n      ...state,\n      ...newState,\n    };\n\n    // Prep fetcher cleanup so we can tell the UI which fetcher data entries\n    // can be removed\n    let completedFetchers: string[] = [];\n    let deletedFetchersKeys: string[] = [];\n\n    if (future.v7_fetcherPersist) {\n      state.fetchers.forEach((fetcher, key) => {\n        if (fetcher.state === \"idle\") {\n          if (deletedFetchers.has(key)) {\n            // Unmounted from the UI and can be totally removed\n            deletedFetchersKeys.push(key);\n          } else {\n            // Returned to idle but still mounted in the UI, so semi-remains for\n            // revalidations and such\n            completedFetchers.push(key);\n          }\n        }\n      });\n    }\n\n    // Iterate over a local copy so that if flushSync is used and we end up\n    // removing and adding a new subscriber due to the useCallback dependencies,\n    // we don't get ourselves into a loop calling the new subscriber immediately\n    [...subscribers].forEach((subscriber) =>\n      subscriber(state, {\n        deletedFetchers: deletedFetchersKeys,\n        unstable_viewTransitionOpts: opts.viewTransitionOpts,\n        unstable_flushSync: opts.flushSync === true,\n      })\n    );\n\n    // Remove idle fetchers from state since we only care about in-flight fetchers.\n    if (future.v7_fetcherPersist) {\n      completedFetchers.forEach((key) => state.fetchers.delete(key));\n      deletedFetchersKeys.forEach((key) => deleteFetcher(key));\n    }\n  }\n\n  // Complete a navigation returning the state.navigation back to the IDLE_NAVIGATION\n  // and setting state.[historyAction/location/matches] to the new route.\n  // - Location is a required param\n  // - Navigation will always be set to IDLE_NAVIGATION\n  // - Can pass any other state in newState\n  function completeNavigation(\n    location: Location,\n    newState: Partial<Omit<RouterState, \"action\" | \"location\" | \"navigation\">>,\n    { flushSync }: { flushSync?: boolean } = {}\n  ): void {\n    // Deduce if we're in a loading/actionReload state:\n    // - We have committed actionData in the store\n    // - The current navigation was a mutation submission\n    // - We're past the submitting state and into the loading state\n    // - The location being loaded is not the result of a redirect\n    let isActionReload =\n      state.actionData != null &&\n      state.navigation.formMethod != null &&\n      isMutationMethod(state.navigation.formMethod) &&\n      state.navigation.state === \"loading\" &&\n      location.state?._isRedirect !== true;\n\n    let actionData: RouteData | null;\n    if (newState.actionData) {\n      if (Object.keys(newState.actionData).length > 0) {\n        actionData = newState.actionData;\n      } else {\n        // Empty actionData -> clear prior actionData due to an action error\n        actionData = null;\n      }\n    } else if (isActionReload) {\n      // Keep the current data if we're wrapping up the action reload\n      actionData = state.actionData;\n    } else {\n      // Clear actionData on any other completed navigations\n      actionData = null;\n    }\n\n    // Always preserve any existing loaderData from re-used routes\n    let loaderData = newState.loaderData\n      ? mergeLoaderData(\n          state.loaderData,\n          newState.loaderData,\n          newState.matches || [],\n          newState.errors\n        )\n      : state.loaderData;\n\n    // On a successful navigation we can assume we got through all blockers\n    // so we can start fresh\n    let blockers = state.blockers;\n    if (blockers.size > 0) {\n      blockers = new Map(blockers);\n      blockers.forEach((_, k) => blockers.set(k, IDLE_BLOCKER));\n    }\n\n    // Always respect the user flag.  Otherwise don't reset on mutation\n    // submission navigations unless they redirect\n    let preventScrollReset =\n      pendingPreventScrollReset === true ||\n      (state.navigation.formMethod != null &&\n        isMutationMethod(state.navigation.formMethod) &&\n        location.state?._isRedirect !== true);\n\n    if (inFlightDataRoutes) {\n      dataRoutes = inFlightDataRoutes;\n      inFlightDataRoutes = undefined;\n    }\n\n    if (isUninterruptedRevalidation) {\n      // If this was an uninterrupted revalidation then do not touch history\n    } else if (pendingAction === HistoryAction.Pop) {\n      // Do nothing for POP - URL has already been updated\n    } else if (pendingAction === HistoryAction.Push) {\n      init.history.push(location, location.state);\n    } else if (pendingAction === HistoryAction.Replace) {\n      init.history.replace(location, location.state);\n    }\n\n    let viewTransitionOpts: ViewTransitionOpts | undefined;\n\n    // On POP, enable transitions if they were enabled on the original navigation\n    if (pendingAction === HistoryAction.Pop) {\n      // Forward takes precedence so they behave like the original navigation\n      let priorPaths = appliedViewTransitions.get(state.location.pathname);\n      if (priorPaths && priorPaths.has(location.pathname)) {\n        viewTransitionOpts = {\n          currentLocation: state.location,\n          nextLocation: location,\n        };\n      } else if (appliedViewTransitions.has(location.pathname)) {\n        // If we don't have a previous forward nav, assume we're popping back to\n        // the new location and enable if that location previously enabled\n        viewTransitionOpts = {\n          currentLocation: location,\n          nextLocation: state.location,\n        };\n      }\n    } else if (pendingViewTransitionEnabled) {\n      // Store the applied transition on PUSH/REPLACE\n      let toPaths = appliedViewTransitions.get(state.location.pathname);\n      if (toPaths) {\n        toPaths.add(location.pathname);\n      } else {\n        toPaths = new Set<string>([location.pathname]);\n        appliedViewTransitions.set(state.location.pathname, toPaths);\n      }\n      viewTransitionOpts = {\n        currentLocation: state.location,\n        nextLocation: location,\n      };\n    }\n\n    updateState(\n      {\n        ...newState, // matches, errors, fetchers go through as-is\n        actionData,\n        loaderData,\n        historyAction: pendingAction,\n        location,\n        initialized: true,\n        navigation: IDLE_NAVIGATION,\n        revalidation: \"idle\",\n        restoreScrollPosition: getSavedScrollPosition(\n          location,\n          newState.matches || state.matches\n        ),\n        preventScrollReset,\n        blockers,\n      },\n      {\n        viewTransitionOpts,\n        flushSync: flushSync === true,\n      }\n    );\n\n    // Reset stateful navigation vars\n    pendingAction = HistoryAction.Pop;\n    pendingPreventScrollReset = false;\n    pendingViewTransitionEnabled = false;\n    isUninterruptedRevalidation = false;\n    isRevalidationRequired = false;\n    cancelledDeferredRoutes = [];\n    cancelledFetcherLoads = [];\n  }\n\n  // Trigger a navigation event, which can either be a numerical POP or a PUSH\n  // replace with an optional submission\n  async function navigate(\n    to: number | To | null,\n    opts?: RouterNavigateOptions\n  ): Promise<void> {\n    if (typeof to === \"number\") {\n      init.history.go(to);\n      return;\n    }\n\n    let normalizedPath = normalizeTo(\n      state.location,\n      state.matches,\n      basename,\n      future.v7_prependBasename,\n      to,\n      future.v7_relativeSplatPath,\n      opts?.fromRouteId,\n      opts?.relative\n    );\n    let { path, submission, error } = normalizeNavigateOptions(\n      future.v7_normalizeFormMethod,\n      false,\n      normalizedPath,\n      opts\n    );\n\n    let currentLocation = state.location;\n    let nextLocation = createLocation(state.location, path, opts && opts.state);\n\n    // When using navigate as a PUSH/REPLACE we aren't reading an already-encoded\n    // URL from window.location, so we need to encode it here so the behavior\n    // remains the same as POP and non-data-router usages.  new URL() does all\n    // the same encoding we'd get from a history.pushState/window.location read\n    // without having to touch history\n    nextLocation = {\n      ...nextLocation,\n      ...init.history.encodeLocation(nextLocation),\n    };\n\n    let userReplace = opts && opts.replace != null ? opts.replace : undefined;\n\n    let historyAction = HistoryAction.Push;\n\n    if (userReplace === true) {\n      historyAction = HistoryAction.Replace;\n    } else if (userReplace === false) {\n      // no-op\n    } else if (\n      submission != null &&\n      isMutationMethod(submission.formMethod) &&\n      submission.formAction === state.location.pathname + state.location.search\n    ) {\n      // By default on submissions to the current location we REPLACE so that\n      // users don't have to double-click the back button to get to the prior\n      // location.  If the user redirects to a different location from the\n      // action/loader this will be ignored and the redirect will be a PUSH\n      historyAction = HistoryAction.Replace;\n    }\n\n    let preventScrollReset =\n      opts && \"preventScrollReset\" in opts\n        ? opts.preventScrollReset === true\n        : undefined;\n\n    let flushSync = (opts && opts.unstable_flushSync) === true;\n\n    let blockerKey = shouldBlockNavigation({\n      currentLocation,\n      nextLocation,\n      historyAction,\n    });\n\n    if (blockerKey) {\n      // Put the blocker into a blocked state\n      updateBlocker(blockerKey, {\n        state: \"blocked\",\n        location: nextLocation,\n        proceed() {\n          updateBlocker(blockerKey!, {\n            state: \"proceeding\",\n            proceed: undefined,\n            reset: undefined,\n            location: nextLocation,\n          });\n          // Send the same navigation through\n          navigate(to, opts);\n        },\n        reset() {\n          let blockers = new Map(state.blockers);\n          blockers.set(blockerKey!, IDLE_BLOCKER);\n          updateState({ blockers });\n        },\n      });\n      return;\n    }\n\n    return await startNavigation(historyAction, nextLocation, {\n      submission,\n      // Send through the formData serialization error if we have one so we can\n      // render at the right error boundary after we match routes\n      pendingError: error,\n      preventScrollReset,\n      replace: opts && opts.replace,\n      enableViewTransition: opts && opts.unstable_viewTransition,\n      flushSync,\n    });\n  }\n\n  // Revalidate all current loaders.  If a navigation is in progress or if this\n  // is interrupted by a navigation, allow this to \"succeed\" by calling all\n  // loaders during the next loader round\n  function revalidate() {\n    interruptActiveLoads();\n    updateState({ revalidation: \"loading\" });\n\n    // If we're currently submitting an action, we don't need to start a new\n    // navigation, we'll just let the follow up loader execution call all loaders\n    if (state.navigation.state === \"submitting\") {\n      return;\n    }\n\n    // If we're currently in an idle state, start a new navigation for the current\n    // action/location and mark it as uninterrupted, which will skip the history\n    // update in completeNavigation\n    if (state.navigation.state === \"idle\") {\n      startNavigation(state.historyAction, state.location, {\n        startUninterruptedRevalidation: true,\n      });\n      return;\n    }\n\n    // Otherwise, if we're currently in a loading state, just start a new\n    // navigation to the navigation.location but do not trigger an uninterrupted\n    // revalidation so that history correctly updates once the navigation completes\n    startNavigation(\n      pendingAction || state.historyAction,\n      state.navigation.location,\n      { overrideNavigation: state.navigation }\n    );\n  }\n\n  // Start a navigation to the given action/location.  Can optionally provide a\n  // overrideNavigation which will override the normalLoad in the case of a redirect\n  // navigation\n  async function startNavigation(\n    historyAction: HistoryAction,\n    location: Location,\n    opts?: {\n      initialHydration?: boolean;\n      submission?: Submission;\n      fetcherSubmission?: Submission;\n      overrideNavigation?: Navigation;\n      pendingError?: ErrorResponseImpl;\n      startUninterruptedRevalidation?: boolean;\n      preventScrollReset?: boolean;\n      replace?: boolean;\n      enableViewTransition?: boolean;\n      flushSync?: boolean;\n    }\n  ): Promise<void> {\n    // Abort any in-progress navigations and start a new one. Unset any ongoing\n    // uninterrupted revalidations unless told otherwise, since we want this\n    // new navigation to update history normally\n    pendingNavigationController && pendingNavigationController.abort();\n    pendingNavigationController = null;\n    pendingAction = historyAction;\n    isUninterruptedRevalidation =\n      (opts && opts.startUninterruptedRevalidation) === true;\n\n    // Save the current scroll position every time we start a new navigation,\n    // and track whether we should reset scroll on completion\n    saveScrollPosition(state.location, state.matches);\n    pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;\n\n    pendingViewTransitionEnabled = (opts && opts.enableViewTransition) === true;\n\n    let routesToUse = inFlightDataRoutes || dataRoutes;\n    let loadingNavigation = opts && opts.overrideNavigation;\n    let matches = matchRoutes(routesToUse, location, basename);\n    let flushSync = (opts && opts.flushSync) === true;\n\n    // Short circuit with a 404 on the root error boundary if we match nothing\n    if (!matches) {\n      let error = getInternalRouterError(404, { pathname: location.pathname });\n      let { matches: notFoundMatches, route } =\n        getShortCircuitMatches(routesToUse);\n      // Cancel all pending deferred on 404s since we don't keep any routes\n      cancelActiveDeferreds();\n      completeNavigation(\n        location,\n        {\n          matches: notFoundMatches,\n          loaderData: {},\n          errors: {\n            [route.id]: error,\n          },\n        },\n        { flushSync }\n      );\n      return;\n    }\n\n    // Short circuit if it's only a hash change and not a revalidation or\n    // mutation submission.\n    //\n    // Ignore on initial page loads because since the initial load will always\n    // be \"same hash\".  For example, on /page#hash and submit a <Form method=\"post\">\n    // which will default to a navigation to /page\n    if (\n      state.initialized &&\n      !isRevalidationRequired &&\n      isHashChangeOnly(state.location, location) &&\n      !(opts && opts.submission && isMutationMethod(opts.submission.formMethod))\n    ) {\n      completeNavigation(location, { matches }, { flushSync });\n      return;\n    }\n\n    // Create a controller/Request for this navigation\n    pendingNavigationController = new AbortController();\n    let request = createClientSideRequest(\n      init.history,\n      location,\n      pendingNavigationController.signal,\n      opts && opts.submission\n    );\n    let pendingActionData: RouteData | undefined;\n    let pendingError: RouteData | undefined;\n\n    if (opts && opts.pendingError) {\n      // If we have a pendingError, it means the user attempted a GET submission\n      // with binary FormData so assign here and skip to handleLoaders.  That\n      // way we handle calling loaders above the boundary etc.  It's not really\n      // different from an actionError in that sense.\n      pendingError = {\n        [findNearestBoundary(matches).route.id]: opts.pendingError,\n      };\n    } else if (\n      opts &&\n      opts.submission &&\n      isMutationMethod(opts.submission.formMethod)\n    ) {\n      // Call action if we received an action submission\n      let actionOutput = await handleAction(\n        request,\n        location,\n        opts.submission,\n        matches,\n        { replace: opts.replace, flushSync }\n      );\n\n      if (actionOutput.shortCircuited) {\n        return;\n      }\n\n      pendingActionData = actionOutput.pendingActionData;\n      pendingError = actionOutput.pendingActionError;\n      loadingNavigation = getLoadingNavigation(location, opts.submission);\n      flushSync = false;\n\n      // Create a GET request for the loaders\n      request = new Request(request.url, { signal: request.signal });\n    }\n\n    // Call loaders\n    let { shortCircuited, loaderData, errors } = await handleLoaders(\n      request,\n      location,\n      matches,\n      loadingNavigation,\n      opts && opts.submission,\n      opts && opts.fetcherSubmission,\n      opts && opts.replace,\n      opts && opts.initialHydration === true,\n      flushSync,\n      pendingActionData,\n      pendingError\n    );\n\n    if (shortCircuited) {\n      return;\n    }\n\n    // Clean up now that the action/loaders have completed.  Don't clean up if\n    // we short circuited because pendingNavigationController will have already\n    // been assigned to a new controller for the next navigation\n    pendingNavigationController = null;\n\n    completeNavigation(location, {\n      matches,\n      ...(pendingActionData ? { actionData: pendingActionData } : {}),\n      loaderData,\n      errors,\n    });\n  }\n\n  // Call the action matched by the leaf route for this navigation and handle\n  // redirects/errors\n  async function handleAction(\n    request: Request,\n    location: Location,\n    submission: Submission,\n    matches: AgnosticDataRouteMatch[],\n    opts: { replace?: boolean; flushSync?: boolean } = {}\n  ): Promise<HandleActionResult> {\n    interruptActiveLoads();\n\n    // Put us in a submitting state\n    let navigation = getSubmittingNavigation(location, submission);\n    updateState({ navigation }, { flushSync: opts.flushSync === true });\n\n    // Call our action and get the result\n    let result: DataResult;\n    let actionMatch = getTargetMatch(matches, location);\n\n    if (!actionMatch.route.action && !actionMatch.route.lazy) {\n      result = {\n        type: ResultType.error,\n        error: getInternalRouterError(405, {\n          method: request.method,\n          pathname: location.pathname,\n          routeId: actionMatch.route.id,\n        }),\n      };\n    } else {\n      result = await callLoaderOrAction(\n        \"action\",\n        request,\n        actionMatch,\n        matches,\n        manifest,\n        mapRouteProperties,\n        basename,\n        future.v7_relativeSplatPath\n      );\n\n      if (request.signal.aborted) {\n        return { shortCircuited: true };\n      }\n    }\n\n    if (isRedirectResult(result)) {\n      let replace: boolean;\n      if (opts && opts.replace != null) {\n        replace = opts.replace;\n      } else {\n        // If the user didn't explicity indicate replace behavior, replace if\n        // we redirected to the exact same location we're currently at to avoid\n        // double back-buttons\n        replace =\n          result.location === state.location.pathname + state.location.search;\n      }\n      await startRedirectNavigation(state, result, { submission, replace });\n      return { shortCircuited: true };\n    }\n\n    if (isErrorResult(result)) {\n      // Store off the pending error - we use it to determine which loaders\n      // to call and will commit it when we complete the navigation\n      let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id);\n\n      // By default, all submissions are REPLACE navigations, but if the\n      // action threw an error that'll be rendered in an errorElement, we fall\n      // back to PUSH so that the user can use the back button to get back to\n      // the pre-submission form location to try again\n      if ((opts && opts.replace) !== true) {\n        pendingAction = HistoryAction.Push;\n      }\n\n      return {\n        // Send back an empty object we can use to clear out any prior actionData\n        pendingActionData: {},\n        pendingActionError: { [boundaryMatch.route.id]: result.error },\n      };\n    }\n\n    if (isDeferredResult(result)) {\n      throw getInternalRouterError(400, { type: \"defer-action\" });\n    }\n\n    return {\n      pendingActionData: { [actionMatch.route.id]: result.data },\n    };\n  }\n\n  // Call all applicable loaders for the given matches, handling redirects,\n  // errors, etc.\n  async function handleLoaders(\n    request: Request,\n    location: Location,\n    matches: AgnosticDataRouteMatch[],\n    overrideNavigation?: Navigation,\n    submission?: Submission,\n    fetcherSubmission?: Submission,\n    replace?: boolean,\n    initialHydration?: boolean,\n    flushSync?: boolean,\n    pendingActionData?: RouteData,\n    pendingError?: RouteData\n  ): Promise<HandleLoadersResult> {\n    // Figure out the right navigation we want to use for data loading\n    let loadingNavigation =\n      overrideNavigation || getLoadingNavigation(location, submission);\n\n    // If this was a redirect from an action we don't have a \"submission\" but\n    // we have it on the loading navigation so use that if available\n    let activeSubmission =\n      submission ||\n      fetcherSubmission ||\n      getSubmissionFromNavigation(loadingNavigation);\n\n    let routesToUse = inFlightDataRoutes || dataRoutes;\n    let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(\n      init.history,\n      state,\n      matches,\n      activeSubmission,\n      location,\n      future.v7_partialHydration && initialHydration === true,\n      isRevalidationRequired,\n      cancelledDeferredRoutes,\n      cancelledFetcherLoads,\n      deletedFetchers,\n      fetchLoadMatches,\n      fetchRedirectIds,\n      routesToUse,\n      basename,\n      pendingActionData,\n      pendingError\n    );\n\n    // Cancel pending deferreds for no-longer-matched routes or routes we're\n    // about to reload.  Note that if this is an action reload we would have\n    // already cancelled all pending deferreds so this would be a no-op\n    cancelActiveDeferreds(\n      (routeId) =>\n        !(matches && matches.some((m) => m.route.id === routeId)) ||\n        (matchesToLoad && matchesToLoad.some((m) => m.route.id === routeId))\n    );\n\n    pendingNavigationLoadId = ++incrementingLoadId;\n\n    // Short circuit if we have no loaders to run\n    if (matchesToLoad.length === 0 && revalidatingFetchers.length === 0) {\n      let updatedFetchers = markFetchRedirectsDone();\n      completeNavigation(\n        location,\n        {\n          matches,\n          loaderData: {},\n          // Commit pending error if we're short circuiting\n          errors: pendingError || null,\n          ...(pendingActionData ? { actionData: pendingActionData } : {}),\n          ...(updatedFetchers ? { fetchers: new Map(state.fetchers) } : {}),\n        },\n        { flushSync }\n      );\n      return { shortCircuited: true };\n    }\n\n    // If this is an uninterrupted revalidation, we remain in our current idle\n    // state.  If not, we need to switch to our loading state and load data,\n    // preserving any new action data or existing action data (in the case of\n    // a revalidation interrupting an actionReload)\n    // If we have partialHydration enabled, then don't update the state for the\n    // initial data load since iot's not a \"navigation\"\n    if (\n      !isUninterruptedRevalidation &&\n      (!future.v7_partialHydration || !initialHydration)\n    ) {\n      revalidatingFetchers.forEach((rf) => {\n        let fetcher = state.fetchers.get(rf.key);\n        let revalidatingFetcher = getLoadingFetcher(\n          undefined,\n          fetcher ? fetcher.data : undefined\n        );\n        state.fetchers.set(rf.key, revalidatingFetcher);\n      });\n      let actionData = pendingActionData || state.actionData;\n      updateState(\n        {\n          navigation: loadingNavigation,\n          ...(actionData\n            ? Object.keys(actionData).length === 0\n              ? { actionData: null }\n              : { actionData }\n            : {}),\n          ...(revalidatingFetchers.length > 0\n            ? { fetchers: new Map(state.fetchers) }\n            : {}),\n        },\n        {\n          flushSync,\n        }\n      );\n    }\n\n    revalidatingFetchers.forEach((rf) => {\n      if (fetchControllers.has(rf.key)) {\n        abortFetcher(rf.key);\n      }\n      if (rf.controller) {\n        // Fetchers use an independent AbortController so that aborting a fetcher\n        // (via deleteFetcher) does not abort the triggering navigation that\n        // triggered the revalidation\n        fetchControllers.set(rf.key, rf.controller);\n      }\n    });\n\n    // Proxy navigation abort through to revalidation fetchers\n    let abortPendingFetchRevalidations = () =>\n      revalidatingFetchers.forEach((f) => abortFetcher(f.key));\n    if (pendingNavigationController) {\n      pendingNavigationController.signal.addEventListener(\n        \"abort\",\n        abortPendingFetchRevalidations\n      );\n    }\n\n    let { results, loaderResults, fetcherResults } =\n      await callLoadersAndMaybeResolveData(\n        state.matches,\n        matches,\n        matchesToLoad,\n        revalidatingFetchers,\n        request\n      );\n\n    if (request.signal.aborted) {\n      return { shortCircuited: true };\n    }\n\n    // Clean up _after_ loaders have completed.  Don't clean up if we short\n    // circuited because fetchControllers would have been aborted and\n    // reassigned to new controllers for the next navigation\n    if (pendingNavigationController) {\n      pendingNavigationController.signal.removeEventListener(\n        \"abort\",\n        abortPendingFetchRevalidations\n      );\n    }\n    revalidatingFetchers.forEach((rf) => fetchControllers.delete(rf.key));\n\n    // If any loaders returned a redirect Response, start a new REPLACE navigation\n    let redirect = findRedirect(results);\n    if (redirect) {\n      if (redirect.idx >= matchesToLoad.length) {\n        // If this redirect came from a fetcher make sure we mark it in\n        // fetchRedirectIds so it doesn't get revalidated on the next set of\n        // loader executions\n        let fetcherKey =\n          revalidatingFetchers[redirect.idx - matchesToLoad.length].key;\n        fetchRedirectIds.add(fetcherKey);\n      }\n      await startRedirectNavigation(state, redirect.result, { replace });\n      return { shortCircuited: true };\n    }\n\n    // Process and commit output from loaders\n    let { loaderData, errors } = processLoaderData(\n      state,\n      matches,\n      matchesToLoad,\n      loaderResults,\n      pendingError,\n      revalidatingFetchers,\n      fetcherResults,\n      activeDeferreds\n    );\n\n    // Wire up subscribers to update loaderData as promises settle\n    activeDeferreds.forEach((deferredData, routeId) => {\n      deferredData.subscribe((aborted) => {\n        // Note: No need to updateState here since the TrackedPromise on\n        // loaderData is stable across resolve/reject\n        // Remove this instance if we were aborted or if promises have settled\n        if (aborted || deferredData.done) {\n          activeDeferreds.delete(routeId);\n        }\n      });\n    });\n\n    let updatedFetchers = markFetchRedirectsDone();\n    let didAbortFetchLoads = abortStaleFetchLoads(pendingNavigationLoadId);\n    let shouldUpdateFetchers =\n      updatedFetchers || didAbortFetchLoads || revalidatingFetchers.length > 0;\n\n    return {\n      loaderData,\n      errors,\n      ...(shouldUpdateFetchers ? { fetchers: new Map(state.fetchers) } : {}),\n    };\n  }\n\n  // Trigger a fetcher load/submit for the given fetcher key\n  function fetch(\n    key: string,\n    routeId: string,\n    href: string | null,\n    opts?: RouterFetchOptions\n  ) {\n    if (isServer) {\n      throw new Error(\n        \"router.fetch() was called during the server render, but it shouldn't be. \" +\n          \"You are likely calling a useFetcher() method in the body of your component. \" +\n          \"Try moving it to a useEffect or a callback.\"\n      );\n    }\n\n    if (fetchControllers.has(key)) abortFetcher(key);\n    let flushSync = (opts && opts.unstable_flushSync) === true;\n\n    let routesToUse = inFlightDataRoutes || dataRoutes;\n    let normalizedPath = normalizeTo(\n      state.location,\n      state.matches,\n      basename,\n      future.v7_prependBasename,\n      href,\n      future.v7_relativeSplatPath,\n      routeId,\n      opts?.relative\n    );\n    let matches = matchRoutes(routesToUse, normalizedPath, basename);\n\n    if (!matches) {\n      setFetcherError(\n        key,\n        routeId,\n        getInternalRouterError(404, { pathname: normalizedPath }),\n        { flushSync }\n      );\n      return;\n    }\n\n    let { path, submission, error } = normalizeNavigateOptions(\n      future.v7_normalizeFormMethod,\n      true,\n      normalizedPath,\n      opts\n    );\n\n    if (error) {\n      setFetcherError(key, routeId, error, { flushSync });\n      return;\n    }\n\n    let match = getTargetMatch(matches, path);\n\n    pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;\n\n    if (submission && isMutationMethod(submission.formMethod)) {\n      handleFetcherAction(\n        key,\n        routeId,\n        path,\n        match,\n        matches,\n        flushSync,\n        submission\n      );\n      return;\n    }\n\n    // Store off the match so we can call it's shouldRevalidate on subsequent\n    // revalidations\n    fetchLoadMatches.set(key, { routeId, path });\n    handleFetcherLoader(\n      key,\n      routeId,\n      path,\n      match,\n      matches,\n      flushSync,\n      submission\n    );\n  }\n\n  // Call the action for the matched fetcher.submit(), and then handle redirects,\n  // errors, and revalidation\n  async function handleFetcherAction(\n    key: string,\n    routeId: string,\n    path: string,\n    match: AgnosticDataRouteMatch,\n    requestMatches: AgnosticDataRouteMatch[],\n    flushSync: boolean,\n    submission: Submission\n  ) {\n    interruptActiveLoads();\n    fetchLoadMatches.delete(key);\n\n    if (!match.route.action && !match.route.lazy) {\n      let error = getInternalRouterError(405, {\n        method: submission.formMethod,\n        pathname: path,\n        routeId: routeId,\n      });\n      setFetcherError(key, routeId, error, { flushSync });\n      return;\n    }\n\n    // Put this fetcher into it's submitting state\n    let existingFetcher = state.fetchers.get(key);\n    updateFetcherState(key, getSubmittingFetcher(submission, existingFetcher), {\n      flushSync,\n    });\n\n    // Call the action for the fetcher\n    let abortController = new AbortController();\n    let fetchRequest = createClientSideRequest(\n      init.history,\n      path,\n      abortController.signal,\n      submission\n    );\n    fetchControllers.set(key, abortController);\n\n    let originatingLoadId = incrementingLoadId;\n    let actionResult = await callLoaderOrAction(\n      \"action\",\n      fetchRequest,\n      match,\n      requestMatches,\n      manifest,\n      mapRouteProperties,\n      basename,\n      future.v7_relativeSplatPath\n    );\n\n    if (fetchRequest.signal.aborted) {\n      // We can delete this so long as we weren't aborted by our own fetcher\n      // re-submit which would have put _new_ controller is in fetchControllers\n      if (fetchControllers.get(key) === abortController) {\n        fetchControllers.delete(key);\n      }\n      return;\n    }\n\n    // When using v7_fetcherPersist, we don't want errors bubbling up to the UI\n    // or redirects processed for unmounted fetchers so we just revert them to\n    // idle\n    if (future.v7_fetcherPersist && deletedFetchers.has(key)) {\n      if (isRedirectResult(actionResult) || isErrorResult(actionResult)) {\n        updateFetcherState(key, getDoneFetcher(undefined));\n        return;\n      }\n      // Let SuccessResult's fall through for revalidation\n    } else {\n      if (isRedirectResult(actionResult)) {\n        fetchControllers.delete(key);\n        if (pendingNavigationLoadId > originatingLoadId) {\n          // A new navigation was kicked off after our action started, so that\n          // should take precedence over this redirect navigation.  We already\n          // set isRevalidationRequired so all loaders for the new route should\n          // fire unless opted out via shouldRevalidate\n          updateFetcherState(key, getDoneFetcher(undefined));\n          return;\n        } else {\n          fetchRedirectIds.add(key);\n          updateFetcherState(key, getLoadingFetcher(submission));\n          return startRedirectNavigation(state, actionResult, {\n            fetcherSubmission: submission,\n          });\n        }\n      }\n\n      // Process any non-redirect errors thrown\n      if (isErrorResult(actionResult)) {\n        setFetcherError(key, routeId, actionResult.error);\n        return;\n      }\n    }\n\n    if (isDeferredResult(actionResult)) {\n      throw getInternalRouterError(400, { type: \"defer-action\" });\n    }\n\n    // Start the data load for current matches, or the next location if we're\n    // in the middle of a navigation\n    let nextLocation = state.navigation.location || state.location;\n    let revalidationRequest = createClientSideRequest(\n      init.history,\n      nextLocation,\n      abortController.signal\n    );\n    let routesToUse = inFlightDataRoutes || dataRoutes;\n    let matches =\n      state.navigation.state !== \"idle\"\n        ? matchRoutes(routesToUse, state.navigation.location, basename)\n        : state.matches;\n\n    invariant(matches, \"Didn't find any matches after fetcher action\");\n\n    let loadId = ++incrementingLoadId;\n    fetchReloadIds.set(key, loadId);\n\n    let loadFetcher = getLoadingFetcher(submission, actionResult.data);\n    state.fetchers.set(key, loadFetcher);\n\n    let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(\n      init.history,\n      state,\n      matches,\n      submission,\n      nextLocation,\n      false,\n      isRevalidationRequired,\n      cancelledDeferredRoutes,\n      cancelledFetcherLoads,\n      deletedFetchers,\n      fetchLoadMatches,\n      fetchRedirectIds,\n      routesToUse,\n      basename,\n      { [match.route.id]: actionResult.data },\n      undefined // No need to send through errors since we short circuit above\n    );\n\n    // Put all revalidating fetchers into the loading state, except for the\n    // current fetcher which we want to keep in it's current loading state which\n    // contains it's action submission info + action data\n    revalidatingFetchers\n      .filter((rf) => rf.key !== key)\n      .forEach((rf) => {\n        let staleKey = rf.key;\n        let existingFetcher = state.fetchers.get(staleKey);\n        let revalidatingFetcher = getLoadingFetcher(\n          undefined,\n          existingFetcher ? existingFetcher.data : undefined\n        );\n        state.fetchers.set(staleKey, revalidatingFetcher);\n        if (fetchControllers.has(staleKey)) {\n          abortFetcher(staleKey);\n        }\n        if (rf.controller) {\n          fetchControllers.set(staleKey, rf.controller);\n        }\n      });\n\n    updateState({ fetchers: new Map(state.fetchers) });\n\n    let abortPendingFetchRevalidations = () =>\n      revalidatingFetchers.forEach((rf) => abortFetcher(rf.key));\n\n    abortController.signal.addEventListener(\n      \"abort\",\n      abortPendingFetchRevalidations\n    );\n\n    let { results, loaderResults, fetcherResults } =\n      await callLoadersAndMaybeResolveData(\n        state.matches,\n        matches,\n        matchesToLoad,\n        revalidatingFetchers,\n        revalidationRequest\n      );\n\n    if (abortController.signal.aborted) {\n      return;\n    }\n\n    abortController.signal.removeEventListener(\n      \"abort\",\n      abortPendingFetchRevalidations\n    );\n\n    fetchReloadIds.delete(key);\n    fetchControllers.delete(key);\n    revalidatingFetchers.forEach((r) => fetchControllers.delete(r.key));\n\n    let redirect = findRedirect(results);\n    if (redirect) {\n      if (redirect.idx >= matchesToLoad.length) {\n        // If this redirect came from a fetcher make sure we mark it in\n        // fetchRedirectIds so it doesn't get revalidated on the next set of\n        // loader executions\n        let fetcherKey =\n          revalidatingFetchers[redirect.idx - matchesToLoad.length].key;\n        fetchRedirectIds.add(fetcherKey);\n      }\n      return startRedirectNavigation(state, redirect.result);\n    }\n\n    // Process and commit output from loaders\n    let { loaderData, errors } = processLoaderData(\n      state,\n      state.matches,\n      matchesToLoad,\n      loaderResults,\n      undefined,\n      revalidatingFetchers,\n      fetcherResults,\n      activeDeferreds\n    );\n\n    // Since we let revalidations complete even if the submitting fetcher was\n    // deleted, only put it back to idle if it hasn't been deleted\n    if (state.fetchers.has(key)) {\n      let doneFetcher = getDoneFetcher(actionResult.data);\n      state.fetchers.set(key, doneFetcher);\n    }\n\n    abortStaleFetchLoads(loadId);\n\n    // If we are currently in a navigation loading state and this fetcher is\n    // more recent than the navigation, we want the newer data so abort the\n    // navigation and complete it with the fetcher data\n    if (\n      state.navigation.state === \"loading\" &&\n      loadId > pendingNavigationLoadId\n    ) {\n      invariant(pendingAction, \"Expected pending action\");\n      pendingNavigationController && pendingNavigationController.abort();\n\n      completeNavigation(state.navigation.location, {\n        matches,\n        loaderData,\n        errors,\n        fetchers: new Map(state.fetchers),\n      });\n    } else {\n      // otherwise just update with the fetcher data, preserving any existing\n      // loaderData for loaders that did not need to reload.  We have to\n      // manually merge here since we aren't going through completeNavigation\n      updateState({\n        errors,\n        loaderData: mergeLoaderData(\n          state.loaderData,\n          loaderData,\n          matches,\n          errors\n        ),\n        fetchers: new Map(state.fetchers),\n      });\n      isRevalidationRequired = false;\n    }\n  }\n\n  // Call the matched loader for fetcher.load(), handling redirects, errors, etc.\n  async function handleFetcherLoader(\n    key: string,\n    routeId: string,\n    path: string,\n    match: AgnosticDataRouteMatch,\n    matches: AgnosticDataRouteMatch[],\n    flushSync: boolean,\n    submission?: Submission\n  ) {\n    let existingFetcher = state.fetchers.get(key);\n    updateFetcherState(\n      key,\n      getLoadingFetcher(\n        submission,\n        existingFetcher ? existingFetcher.data : undefined\n      ),\n      { flushSync }\n    );\n\n    // Call the loader for this fetcher route match\n    let abortController = new AbortController();\n    let fetchRequest = createClientSideRequest(\n      init.history,\n      path,\n      abortController.signal\n    );\n    fetchControllers.set(key, abortController);\n\n    let originatingLoadId = incrementingLoadId;\n    let result: DataResult = await callLoaderOrAction(\n      \"loader\",\n      fetchRequest,\n      match,\n      matches,\n      manifest,\n      mapRouteProperties,\n      basename,\n      future.v7_relativeSplatPath\n    );\n\n    // Deferred isn't supported for fetcher loads, await everything and treat it\n    // as a normal load.  resolveDeferredData will return undefined if this\n    // fetcher gets aborted, so we just leave result untouched and short circuit\n    // below if that happens\n    if (isDeferredResult(result)) {\n      result =\n        (await resolveDeferredData(result, fetchRequest.signal, true)) ||\n        result;\n    }\n\n    // We can delete this so long as we weren't aborted by our our own fetcher\n    // re-load which would have put _new_ controller is in fetchControllers\n    if (fetchControllers.get(key) === abortController) {\n      fetchControllers.delete(key);\n    }\n\n    if (fetchRequest.signal.aborted) {\n      return;\n    }\n\n    // We don't want errors bubbling up or redirects followed for unmounted\n    // fetchers, so short circuit here if it was removed from the UI\n    if (deletedFetchers.has(key)) {\n      updateFetcherState(key, getDoneFetcher(undefined));\n      return;\n    }\n\n    // If the loader threw a redirect Response, start a new REPLACE navigation\n    if (isRedirectResult(result)) {\n      if (pendingNavigationLoadId > originatingLoadId) {\n        // A new navigation was kicked off after our loader started, so that\n        // should take precedence over this redirect navigation\n        updateFetcherState(key, getDoneFetcher(undefined));\n        return;\n      } else {\n        fetchRedirectIds.add(key);\n        await startRedirectNavigation(state, result);\n        return;\n      }\n    }\n\n    // Process any non-redirect errors thrown\n    if (isErrorResult(result)) {\n      setFetcherError(key, routeId, result.error);\n      return;\n    }\n\n    invariant(!isDeferredResult(result), \"Unhandled fetcher deferred data\");\n\n    // Put the fetcher back into an idle state\n    updateFetcherState(key, getDoneFetcher(result.data));\n  }\n\n  /**\n   * Utility function to handle redirects returned from an action or loader.\n   * Normally, a redirect \"replaces\" the navigation that triggered it.  So, for\n   * example:\n   *\n   *  - user is on /a\n   *  - user clicks a link to /b\n   *  - loader for /b redirects to /c\n   *\n   * In a non-JS app the browser would track the in-flight navigation to /b and\n   * then replace it with /c when it encountered the redirect response.  In\n   * the end it would only ever update the URL bar with /c.\n   *\n   * In client-side routing using pushState/replaceState, we aim to emulate\n   * this behavior and we also do not update history until the end of the\n   * navigation (including processed redirects).  This means that we never\n   * actually touch history until we've processed redirects, so we just use\n   * the history action from the original navigation (PUSH or REPLACE).\n   */\n  async function startRedirectNavigation(\n    state: RouterState,\n    redirect: RedirectResult,\n    {\n      submission,\n      fetcherSubmission,\n      replace,\n    }: {\n      submission?: Submission;\n      fetcherSubmission?: Submission;\n      replace?: boolean;\n    } = {}\n  ) {\n    if (redirect.revalidate) {\n      isRevalidationRequired = true;\n    }\n\n    let redirectLocation = createLocation(state.location, redirect.location, {\n      _isRedirect: true,\n    });\n    invariant(\n      redirectLocation,\n      \"Expected a location on the redirect navigation\"\n    );\n\n    if (isBrowser) {\n      let isDocumentReload = false;\n\n      if (redirect.reloadDocument) {\n        // Hard reload if the response contained X-Remix-Reload-Document\n        isDocumentReload = true;\n      } else if (ABSOLUTE_URL_REGEX.test(redirect.location)) {\n        const url = init.history.createURL(redirect.location);\n        isDocumentReload =\n          // Hard reload if it's an absolute URL to a new origin\n          url.origin !== routerWindow.location.origin ||\n          // Hard reload if it's an absolute URL that does not match our basename\n          stripBasename(url.pathname, basename) == null;\n      }\n\n      if (isDocumentReload) {\n        if (replace) {\n          routerWindow.location.replace(redirect.location);\n        } else {\n          routerWindow.location.assign(redirect.location);\n        }\n        return;\n      }\n    }\n\n    // There's no need to abort on redirects, since we don't detect the\n    // redirect until the action/loaders have settled\n    pendingNavigationController = null;\n\n    let redirectHistoryAction =\n      replace === true ? HistoryAction.Replace : HistoryAction.Push;\n\n    // Use the incoming submission if provided, fallback on the active one in\n    // state.navigation\n    let { formMethod, formAction, formEncType } = state.navigation;\n    if (\n      !submission &&\n      !fetcherSubmission &&\n      formMethod &&\n      formAction &&\n      formEncType\n    ) {\n      submission = getSubmissionFromNavigation(state.navigation);\n    }\n\n    // If this was a 307/308 submission we want to preserve the HTTP method and\n    // re-submit the GET/POST/PUT/PATCH/DELETE as a submission navigation to the\n    // redirected location\n    let activeSubmission = submission || fetcherSubmission;\n    if (\n      redirectPreserveMethodStatusCodes.has(redirect.status) &&\n      activeSubmission &&\n      isMutationMethod(activeSubmission.formMethod)\n    ) {\n      await startNavigation(redirectHistoryAction, redirectLocation, {\n        submission: {\n          ...activeSubmission,\n          formAction: redirect.location,\n        },\n        // Preserve this flag across redirects\n        preventScrollReset: pendingPreventScrollReset,\n      });\n    } else {\n      // If we have a navigation submission, we will preserve it through the\n      // redirect navigation\n      let overrideNavigation = getLoadingNavigation(\n        redirectLocation,\n        submission\n      );\n      await startNavigation(redirectHistoryAction, redirectLocation, {\n        overrideNavigation,\n        // Send fetcher submissions through for shouldRevalidate\n        fetcherSubmission,\n        // Preserve this flag across redirects\n        preventScrollReset: pendingPreventScrollReset,\n      });\n    }\n  }\n\n  async function callLoadersAndMaybeResolveData(\n    currentMatches: AgnosticDataRouteMatch[],\n    matches: AgnosticDataRouteMatch[],\n    matchesToLoad: AgnosticDataRouteMatch[],\n    fetchersToLoad: RevalidatingFetcher[],\n    request: Request\n  ) {\n    // Call all navigation loaders and revalidating fetcher loaders in parallel,\n    // then slice off the results into separate arrays so we can handle them\n    // accordingly\n    let results = await Promise.all([\n      ...matchesToLoad.map((match) =>\n        callLoaderOrAction(\n          \"loader\",\n          request,\n          match,\n          matches,\n          manifest,\n          mapRouteProperties,\n          basename,\n          future.v7_relativeSplatPath\n        )\n      ),\n      ...fetchersToLoad.map((f) => {\n        if (f.matches && f.match && f.controller) {\n          return callLoaderOrAction(\n            \"loader\",\n            createClientSideRequest(init.history, f.path, f.controller.signal),\n            f.match,\n            f.matches,\n            manifest,\n            mapRouteProperties,\n            basename,\n            future.v7_relativeSplatPath\n          );\n        } else {\n          let error: ErrorResult = {\n            type: ResultType.error,\n            error: getInternalRouterError(404, { pathname: f.path }),\n          };\n          return error;\n        }\n      }),\n    ]);\n    let loaderResults = results.slice(0, matchesToLoad.length);\n    let fetcherResults = results.slice(matchesToLoad.length);\n\n    await Promise.all([\n      resolveDeferredResults(\n        currentMatches,\n        matchesToLoad,\n        loaderResults,\n        loaderResults.map(() => request.signal),\n        false,\n        state.loaderData\n      ),\n      resolveDeferredResults(\n        currentMatches,\n        fetchersToLoad.map((f) => f.match),\n        fetcherResults,\n        fetchersToLoad.map((f) => (f.controller ? f.controller.signal : null)),\n        true\n      ),\n    ]);\n\n    return { results, loaderResults, fetcherResults };\n  }\n\n  function interruptActiveLoads() {\n    // Every interruption triggers a revalidation\n    isRevalidationRequired = true;\n\n    // Cancel pending route-level deferreds and mark cancelled routes for\n    // revalidation\n    cancelledDeferredRoutes.push(...cancelActiveDeferreds());\n\n    // Abort in-flight fetcher loads\n    fetchLoadMatches.forEach((_, key) => {\n      if (fetchControllers.has(key)) {\n        cancelledFetcherLoads.push(key);\n        abortFetcher(key);\n      }\n    });\n  }\n\n  function updateFetcherState(\n    key: string,\n    fetcher: Fetcher,\n    opts: { flushSync?: boolean } = {}\n  ) {\n    state.fetchers.set(key, fetcher);\n    updateState(\n      { fetchers: new Map(state.fetchers) },\n      { flushSync: (opts && opts.flushSync) === true }\n    );\n  }\n\n  function setFetcherError(\n    key: string,\n    routeId: string,\n    error: any,\n    opts: { flushSync?: boolean } = {}\n  ) {\n    let boundaryMatch = findNearestBoundary(state.matches, routeId);\n    deleteFetcher(key);\n    updateState(\n      {\n        errors: {\n          [boundaryMatch.route.id]: error,\n        },\n        fetchers: new Map(state.fetchers),\n      },\n      { flushSync: (opts && opts.flushSync) === true }\n    );\n  }\n\n  function getFetcher<TData = any>(key: string): Fetcher<TData> {\n    if (future.v7_fetcherPersist) {\n      activeFetchers.set(key, (activeFetchers.get(key) || 0) + 1);\n      // If this fetcher was previously marked for deletion, unmark it since we\n      // have a new instance\n      if (deletedFetchers.has(key)) {\n        deletedFetchers.delete(key);\n      }\n    }\n    return state.fetchers.get(key) || IDLE_FETCHER;\n  }\n\n  function deleteFetcher(key: string): void {\n    let fetcher = state.fetchers.get(key);\n    // Don't abort the controller if this is a deletion of a fetcher.submit()\n    // in it's loading phase since - we don't want to abort the corresponding\n    // revalidation and want them to complete and land\n    if (\n      fetchControllers.has(key) &&\n      !(fetcher && fetcher.state === \"loading\" && fetchReloadIds.has(key))\n    ) {\n      abortFetcher(key);\n    }\n    fetchLoadMatches.delete(key);\n    fetchReloadIds.delete(key);\n    fetchRedirectIds.delete(key);\n    deletedFetchers.delete(key);\n    state.fetchers.delete(key);\n  }\n\n  function deleteFetcherAndUpdateState(key: string): void {\n    if (future.v7_fetcherPersist) {\n      let count = (activeFetchers.get(key) || 0) - 1;\n      if (count <= 0) {\n        activeFetchers.delete(key);\n        deletedFetchers.add(key);\n      } else {\n        activeFetchers.set(key, count);\n      }\n    } else {\n      deleteFetcher(key);\n    }\n    updateState({ fetchers: new Map(state.fetchers) });\n  }\n\n  function abortFetcher(key: string) {\n    let controller = fetchControllers.get(key);\n    invariant(controller, `Expected fetch controller: ${key}`);\n    controller.abort();\n    fetchControllers.delete(key);\n  }\n\n  function markFetchersDone(keys: string[]) {\n    for (let key of keys) {\n      let fetcher = getFetcher(key);\n      let doneFetcher = getDoneFetcher(fetcher.data);\n      state.fetchers.set(key, doneFetcher);\n    }\n  }\n\n  function markFetchRedirectsDone(): boolean {\n    let doneKeys = [];\n    let updatedFetchers = false;\n    for (let key of fetchRedirectIds) {\n      let fetcher = state.fetchers.get(key);\n      invariant(fetcher, `Expected fetcher: ${key}`);\n      if (fetcher.state === \"loading\") {\n        fetchRedirectIds.delete(key);\n        doneKeys.push(key);\n        updatedFetchers = true;\n      }\n    }\n    markFetchersDone(doneKeys);\n    return updatedFetchers;\n  }\n\n  function abortStaleFetchLoads(landedId: number): boolean {\n    let yeetedKeys = [];\n    for (let [key, id] of fetchReloadIds) {\n      if (id < landedId) {\n        let fetcher = state.fetchers.get(key);\n        invariant(fetcher, `Expected fetcher: ${key}`);\n        if (fetcher.state === \"loading\") {\n          abortFetcher(key);\n          fetchReloadIds.delete(key);\n          yeetedKeys.push(key);\n        }\n      }\n    }\n    markFetchersDone(yeetedKeys);\n    return yeetedKeys.length > 0;\n  }\n\n  function getBlocker(key: string, fn: BlockerFunction) {\n    let blocker: Blocker = state.blockers.get(key) || IDLE_BLOCKER;\n\n    if (blockerFunctions.get(key) !== fn) {\n      blockerFunctions.set(key, fn);\n    }\n\n    return blocker;\n  }\n\n  function deleteBlocker(key: string) {\n    state.blockers.delete(key);\n    blockerFunctions.delete(key);\n  }\n\n  // Utility function to update blockers, ensuring valid state transitions\n  function updateBlocker(key: string, newBlocker: Blocker) {\n    let blocker = state.blockers.get(key) || IDLE_BLOCKER;\n\n    // Poor mans state machine :)\n    // https://mermaid.live/edit#pako:eNqVkc9OwzAMxl8l8nnjAYrEtDIOHEBIgwvKJTReGy3_lDpIqO27k6awMG0XcrLlnz87nwdonESogKXXBuE79rq75XZO3-yHds0RJVuv70YrPlUrCEe2HfrORS3rubqZfuhtpg5C9wk5tZ4VKcRUq88q9Z8RS0-48cE1iHJkL0ugbHuFLus9L6spZy8nX9MP2CNdomVaposqu3fGayT8T8-jJQwhepo_UtpgBQaDEUom04dZhAN1aJBDlUKJBxE1ceB2Smj0Mln-IBW5AFU2dwUiktt_2Qaq2dBfaKdEup85UV7Yd-dKjlnkabl2Pvr0DTkTreM\n    invariant(\n      (blocker.state === \"unblocked\" && newBlocker.state === \"blocked\") ||\n        (blocker.state === \"blocked\" && newBlocker.state === \"blocked\") ||\n        (blocker.state === \"blocked\" && newBlocker.state === \"proceeding\") ||\n        (blocker.state === \"blocked\" && newBlocker.state === \"unblocked\") ||\n        (blocker.state === \"proceeding\" && newBlocker.state === \"unblocked\"),\n      `Invalid blocker state transition: ${blocker.state} -> ${newBlocker.state}`\n    );\n\n    let blockers = new Map(state.blockers);\n    blockers.set(key, newBlocker);\n    updateState({ blockers });\n  }\n\n  function shouldBlockNavigation({\n    currentLocation,\n    nextLocation,\n    historyAction,\n  }: {\n    currentLocation: Location;\n    nextLocation: Location;\n    historyAction: HistoryAction;\n  }): string | undefined {\n    if (blockerFunctions.size === 0) {\n      return;\n    }\n\n    // We ony support a single active blocker at the moment since we don't have\n    // any compelling use cases for multi-blocker yet\n    if (blockerFunctions.size > 1) {\n      warning(false, \"A router only supports one blocker at a time\");\n    }\n\n    let entries = Array.from(blockerFunctions.entries());\n    let [blockerKey, blockerFunction] = entries[entries.length - 1];\n    let blocker = state.blockers.get(blockerKey);\n\n    if (blocker && blocker.state === \"proceeding\") {\n      // If the blocker is currently proceeding, we don't need to re-check\n      // it and can let this navigation continue\n      return;\n    }\n\n    // At this point, we know we're unblocked/blocked so we need to check the\n    // user-provided blocker function\n    if (blockerFunction({ currentLocation, nextLocation, historyAction })) {\n      return blockerKey;\n    }\n  }\n\n  function cancelActiveDeferreds(\n    predicate?: (routeId: string) => boolean\n  ): string[] {\n    let cancelledRouteIds: string[] = [];\n    activeDeferreds.forEach((dfd, routeId) => {\n      if (!predicate || predicate(routeId)) {\n        // Cancel the deferred - but do not remove from activeDeferreds here -\n        // we rely on the subscribers to do that so our tests can assert proper\n        // cleanup via _internalActiveDeferreds\n        dfd.cancel();\n        cancelledRouteIds.push(routeId);\n        activeDeferreds.delete(routeId);\n      }\n    });\n    return cancelledRouteIds;\n  }\n\n  // Opt in to capturing and reporting scroll positions during navigations,\n  // used by the <ScrollRestoration> component\n  function enableScrollRestoration(\n    positions: Record<string, number>,\n    getPosition: GetScrollPositionFunction,\n    getKey?: GetScrollRestorationKeyFunction\n  ) {\n    savedScrollPositions = positions;\n    getScrollPosition = getPosition;\n    getScrollRestorationKey = getKey || null;\n\n    // Perform initial hydration scroll restoration, since we miss the boat on\n    // the initial updateState() because we've not yet rendered <ScrollRestoration/>\n    // and therefore have no savedScrollPositions available\n    if (!initialScrollRestored && state.navigation === IDLE_NAVIGATION) {\n      initialScrollRestored = true;\n      let y = getSavedScrollPosition(state.location, state.matches);\n      if (y != null) {\n        updateState({ restoreScrollPosition: y });\n      }\n    }\n\n    return () => {\n      savedScrollPositions = null;\n      getScrollPosition = null;\n      getScrollRestorationKey = null;\n    };\n  }\n\n  function getScrollKey(location: Location, matches: AgnosticDataRouteMatch[]) {\n    if (getScrollRestorationKey) {\n      let key = getScrollRestorationKey(\n        location,\n        matches.map((m) => convertRouteMatchToUiMatch(m, state.loaderData))\n      );\n      return key || location.key;\n    }\n    return location.key;\n  }\n\n  function saveScrollPosition(\n    location: Location,\n    matches: AgnosticDataRouteMatch[]\n  ): void {\n    if (savedScrollPositions && getScrollPosition) {\n      let key = getScrollKey(location, matches);\n      savedScrollPositions[key] = getScrollPosition();\n    }\n  }\n\n  function getSavedScrollPosition(\n    location: Location,\n    matches: AgnosticDataRouteMatch[]\n  ): number | null {\n    if (savedScrollPositions) {\n      let key = getScrollKey(location, matches);\n      let y = savedScrollPositions[key];\n      if (typeof y === \"number\") {\n        return y;\n      }\n    }\n    return null;\n  }\n\n  function _internalSetRoutes(newRoutes: AgnosticDataRouteObject[]) {\n    manifest = {};\n    inFlightDataRoutes = convertRoutesToDataRoutes(\n      newRoutes,\n      mapRouteProperties,\n      undefined,\n      manifest\n    );\n  }\n\n  router = {\n    get basename() {\n      return basename;\n    },\n    get future() {\n      return future;\n    },\n    get state() {\n      return state;\n    },\n    get routes() {\n      return dataRoutes;\n    },\n    get window() {\n      return routerWindow;\n    },\n    initialize,\n    subscribe,\n    enableScrollRestoration,\n    navigate,\n    fetch,\n    revalidate,\n    // Passthrough to history-aware createHref used by useHref so we get proper\n    // hash-aware URLs in DOM paths\n    createHref: (to: To) => init.history.createHref(to),\n    encodeLocation: (to: To) => init.history.encodeLocation(to),\n    getFetcher,\n    deleteFetcher: deleteFetcherAndUpdateState,\n    dispose,\n    getBlocker,\n    deleteBlocker,\n    _internalFetchControllers: fetchControllers,\n    _internalActiveDeferreds: activeDeferreds,\n    // TODO: Remove setRoutes, it's temporary to avoid dealing with\n    // updating the tree while validating the update algorithm.\n    _internalSetRoutes,\n  };\n\n  return router;\n}\n//#endregion\n\n////////////////////////////////////////////////////////////////////////////////\n//#region createStaticHandler\n////////////////////////////////////////////////////////////////////////////////\n\nexport const UNSAFE_DEFERRED_SYMBOL = Symbol(\"deferred\");\n\n/**\n * Future flags to toggle new feature behavior\n */\nexport interface StaticHandlerFutureConfig {\n  v7_relativeSplatPath: boolean;\n}\n\nexport interface CreateStaticHandlerOptions {\n  basename?: string;\n  /**\n   * @deprecated Use `mapRouteProperties` instead\n   */\n  detectErrorBoundary?: DetectErrorBoundaryFunction;\n  mapRouteProperties?: MapRoutePropertiesFunction;\n  future?: Partial<StaticHandlerFutureConfig>;\n}\n\nexport function createStaticHandler(\n  routes: AgnosticRouteObject[],\n  opts?: CreateStaticHandlerOptions\n): StaticHandler {\n  invariant(\n    routes.length > 0,\n    \"You must provide a non-empty routes array to createStaticHandler\"\n  );\n\n  let manifest: RouteManifest = {};\n  let basename = (opts ? opts.basename : null) || \"/\";\n  let mapRouteProperties: MapRoutePropertiesFunction;\n  if (opts?.mapRouteProperties) {\n    mapRouteProperties = opts.mapRouteProperties;\n  } else if (opts?.detectErrorBoundary) {\n    // If they are still using the deprecated version, wrap it with the new API\n    let detectErrorBoundary = opts.detectErrorBoundary;\n    mapRouteProperties = (route) => ({\n      hasErrorBoundary: detectErrorBoundary(route),\n    });\n  } else {\n    mapRouteProperties = defaultMapRouteProperties;\n  }\n  // Config driven behavior flags\n  let future: StaticHandlerFutureConfig = {\n    v7_relativeSplatPath: false,\n    ...(opts ? opts.future : null),\n  };\n\n  let dataRoutes = convertRoutesToDataRoutes(\n    routes,\n    mapRouteProperties,\n    undefined,\n    manifest\n  );\n\n  /**\n   * The query() method is intended for document requests, in which we want to\n   * call an optional action and potentially multiple loaders for all nested\n   * routes.  It returns a StaticHandlerContext object, which is very similar\n   * to the router state (location, loaderData, actionData, errors, etc.) and\n   * also adds SSR-specific information such as the statusCode and headers\n   * from action/loaders Responses.\n   *\n   * It _should_ never throw and should report all errors through the\n   * returned context.errors object, properly associating errors to their error\n   * boundary.  Additionally, it tracks _deepestRenderedBoundaryId which can be\n   * used to emulate React error boundaries during SSr by performing a second\n   * pass only down to the boundaryId.\n   *\n   * The one exception where we do not return a StaticHandlerContext is when a\n   * redirect response is returned or thrown from any action/loader.  We\n   * propagate that out and return the raw Response so the HTTP server can\n   * return it directly.\n   */\n  async function query(\n    request: Request,\n    { requestContext }: { requestContext?: unknown } = {}\n  ): Promise<StaticHandlerContext | Response> {\n    let url = new URL(request.url);\n    let method = request.method;\n    let location = createLocation(\"\", createPath(url), null, \"default\");\n    let matches = matchRoutes(dataRoutes, location, basename);\n\n    // SSR supports HEAD requests while SPA doesn't\n    if (!isValidMethod(method) && method !== \"HEAD\") {\n      let error = getInternalRouterError(405, { method });\n      let { matches: methodNotAllowedMatches, route } =\n        getShortCircuitMatches(dataRoutes);\n      return {\n        basename,\n        location,\n        matches: methodNotAllowedMatches,\n        loaderData: {},\n        actionData: null,\n        errors: {\n          [route.id]: error,\n        },\n        statusCode: error.status,\n        loaderHeaders: {},\n        actionHeaders: {},\n        activeDeferreds: null,\n      };\n    } else if (!matches) {\n      let error = getInternalRouterError(404, { pathname: location.pathname });\n      let { matches: notFoundMatches, route } =\n        getShortCircuitMatches(dataRoutes);\n      return {\n        basename,\n        location,\n        matches: notFoundMatches,\n        loaderData: {},\n        actionData: null,\n        errors: {\n          [route.id]: error,\n        },\n        statusCode: error.status,\n        loaderHeaders: {},\n        actionHeaders: {},\n        activeDeferreds: null,\n      };\n    }\n\n    let result = await queryImpl(request, location, matches, requestContext);\n    if (isResponse(result)) {\n      return result;\n    }\n\n    // When returning StaticHandlerContext, we patch back in the location here\n    // since we need it for React Context.  But this helps keep our submit and\n    // loadRouteData operating on a Request instead of a Location\n    return { location, basename, ...result };\n  }\n\n  /**\n   * The queryRoute() method is intended for targeted route requests, either\n   * for fetch ?_data requests or resource route requests.  In this case, we\n   * are only ever calling a single action or loader, and we are returning the\n   * returned value directly.  In most cases, this will be a Response returned\n   * from the action/loader, but it may be a primitive or other value as well -\n   * and in such cases the calling context should handle that accordingly.\n   *\n   * We do respect the throw/return differentiation, so if an action/loader\n   * throws, then this method will throw the value.  This is important so we\n   * can do proper boundary identification in Remix where a thrown Response\n   * must go to the Catch Boundary but a returned Response is happy-path.\n   *\n   * One thing to note is that any Router-initiated Errors that make sense\n   * to associate with a status code will be thrown as an ErrorResponse\n   * instance which include the raw Error, such that the calling context can\n   * serialize the error as they see fit while including the proper response\n   * code.  Examples here are 404 and 405 errors that occur prior to reaching\n   * any user-defined loaders.\n   */\n  async function queryRoute(\n    request: Request,\n    {\n      routeId,\n      requestContext,\n    }: { requestContext?: unknown; routeId?: string } = {}\n  ): Promise<any> {\n    let url = new URL(request.url);\n    let method = request.method;\n    let location = createLocation(\"\", createPath(url), null, \"default\");\n    let matches = matchRoutes(dataRoutes, location, basename);\n\n    // SSR supports HEAD requests while SPA doesn't\n    if (!isValidMethod(method) && method !== \"HEAD\" && method !== \"OPTIONS\") {\n      throw getInternalRouterError(405, { method });\n    } else if (!matches) {\n      throw getInternalRouterError(404, { pathname: location.pathname });\n    }\n\n    let match = routeId\n      ? matches.find((m) => m.route.id === routeId)\n      : getTargetMatch(matches, location);\n\n    if (routeId && !match) {\n      throw getInternalRouterError(403, {\n        pathname: location.pathname,\n        routeId,\n      });\n    } else if (!match) {\n      // This should never hit I don't think?\n      throw getInternalRouterError(404, { pathname: location.pathname });\n    }\n\n    let result = await queryImpl(\n      request,\n      location,\n      matches,\n      requestContext,\n      match\n    );\n    if (isResponse(result)) {\n      return result;\n    }\n\n    let error = result.errors ? Object.values(result.errors)[0] : undefined;\n    if (error !== undefined) {\n      // If we got back result.errors, that means the loader/action threw\n      // _something_ that wasn't a Response, but it's not guaranteed/required\n      // to be an `instanceof Error` either, so we have to use throw here to\n      // preserve the \"error\" state outside of queryImpl.\n      throw error;\n    }\n\n    // Pick off the right state value to return\n    if (result.actionData) {\n      return Object.values(result.actionData)[0];\n    }\n\n    if (result.loaderData) {\n      let data = Object.values(result.loaderData)[0];\n      if (result.activeDeferreds?.[match.route.id]) {\n        data[UNSAFE_DEFERRED_SYMBOL] = result.activeDeferreds[match.route.id];\n      }\n      return data;\n    }\n\n    return undefined;\n  }\n\n  async function queryImpl(\n    request: Request,\n    location: Location,\n    matches: AgnosticDataRouteMatch[],\n    requestContext: unknown,\n    routeMatch?: AgnosticDataRouteMatch\n  ): Promise<Omit<StaticHandlerContext, \"location\" | \"basename\"> | Response> {\n    invariant(\n      request.signal,\n      \"query()/queryRoute() requests must contain an AbortController signal\"\n    );\n\n    try {\n      if (isMutationMethod(request.method.toLowerCase())) {\n        let result = await submit(\n          request,\n          matches,\n          routeMatch || getTargetMatch(matches, location),\n          requestContext,\n          routeMatch != null\n        );\n        return result;\n      }\n\n      let result = await loadRouteData(\n        request,\n        matches,\n        requestContext,\n        routeMatch\n      );\n      return isResponse(result)\n        ? result\n        : {\n            ...result,\n            actionData: null,\n            actionHeaders: {},\n          };\n    } catch (e) {\n      // If the user threw/returned a Response in callLoaderOrAction, we throw\n      // it to bail out and then return or throw here based on whether the user\n      // returned or threw\n      if (isQueryRouteResponse(e)) {\n        if (e.type === ResultType.error) {\n          throw e.response;\n        }\n        return e.response;\n      }\n      // Redirects are always returned since they don't propagate to catch\n      // boundaries\n      if (isRedirectResponse(e)) {\n        return e;\n      }\n      throw e;\n    }\n  }\n\n  async function submit(\n    request: Request,\n    matches: AgnosticDataRouteMatch[],\n    actionMatch: AgnosticDataRouteMatch,\n    requestContext: unknown,\n    isRouteRequest: boolean\n  ): Promise<Omit<StaticHandlerContext, \"location\" | \"basename\"> | Response> {\n    let result: DataResult;\n\n    if (!actionMatch.route.action && !actionMatch.route.lazy) {\n      let error = getInternalRouterError(405, {\n        method: request.method,\n        pathname: new URL(request.url).pathname,\n        routeId: actionMatch.route.id,\n      });\n      if (isRouteRequest) {\n        throw error;\n      }\n      result = {\n        type: ResultType.error,\n        error,\n      };\n    } else {\n      result = await callLoaderOrAction(\n        \"action\",\n        request,\n        actionMatch,\n        matches,\n        manifest,\n        mapRouteProperties,\n        basename,\n        future.v7_relativeSplatPath,\n        { isStaticRequest: true, isRouteRequest, requestContext }\n      );\n\n      if (request.signal.aborted) {\n        let method = isRouteRequest ? \"queryRoute\" : \"query\";\n        throw new Error(\n          `${method}() call aborted: ${request.method} ${request.url}`\n        );\n      }\n    }\n\n    if (isRedirectResult(result)) {\n      // Uhhhh - this should never happen, we should always throw these from\n      // callLoaderOrAction, but the type narrowing here keeps TS happy and we\n      // can get back on the \"throw all redirect responses\" train here should\n      // this ever happen :/\n      throw new Response(null, {\n        status: result.status,\n        headers: {\n          Location: result.location,\n        },\n      });\n    }\n\n    if (isDeferredResult(result)) {\n      let error = getInternalRouterError(400, { type: \"defer-action\" });\n      if (isRouteRequest) {\n        throw error;\n      }\n      result = {\n        type: ResultType.error,\n        error,\n      };\n    }\n\n    if (isRouteRequest) {\n      // Note: This should only be non-Response values if we get here, since\n      // isRouteRequest should throw any Response received in callLoaderOrAction\n      if (isErrorResult(result)) {\n        throw result.error;\n      }\n\n      return {\n        matches: [actionMatch],\n        loaderData: {},\n        actionData: { [actionMatch.route.id]: result.data },\n        errors: null,\n        // Note: statusCode + headers are unused here since queryRoute will\n        // return the raw Response or value\n        statusCode: 200,\n        loaderHeaders: {},\n        actionHeaders: {},\n        activeDeferreds: null,\n      };\n    }\n\n    if (isErrorResult(result)) {\n      // Store off the pending error - we use it to determine which loaders\n      // to call and will commit it when we complete the navigation\n      let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id);\n      let context = await loadRouteData(\n        request,\n        matches,\n        requestContext,\n        undefined,\n        {\n          [boundaryMatch.route.id]: result.error,\n        }\n      );\n\n      // action status codes take precedence over loader status codes\n      return {\n        ...context,\n        statusCode: isRouteErrorResponse(result.error)\n          ? result.error.status\n          : 500,\n        actionData: null,\n        actionHeaders: {\n          ...(result.headers ? { [actionMatch.route.id]: result.headers } : {}),\n        },\n      };\n    }\n\n    // Create a GET request for the loaders\n    let loaderRequest = new Request(request.url, {\n      headers: request.headers,\n      redirect: request.redirect,\n      signal: request.signal,\n    });\n    let context = await loadRouteData(loaderRequest, matches, requestContext);\n\n    return {\n      ...context,\n      // action status codes take precedence over loader status codes\n      ...(result.statusCode ? { statusCode: result.statusCode } : {}),\n      actionData: {\n        [actionMatch.route.id]: result.data,\n      },\n      actionHeaders: {\n        ...(result.headers ? { [actionMatch.route.id]: result.headers } : {}),\n      },\n    };\n  }\n\n  async function loadRouteData(\n    request: Request,\n    matches: AgnosticDataRouteMatch[],\n    requestContext: unknown,\n    routeMatch?: AgnosticDataRouteMatch,\n    pendingActionError?: RouteData\n  ): Promise<\n    | Omit<\n        StaticHandlerContext,\n        \"location\" | \"basename\" | \"actionData\" | \"actionHeaders\"\n      >\n    | Response\n  > {\n    let isRouteRequest = routeMatch != null;\n\n    // Short circuit if we have no loaders to run (queryRoute())\n    if (\n      isRouteRequest &&\n      !routeMatch?.route.loader &&\n      !routeMatch?.route.lazy\n    ) {\n      throw getInternalRouterError(400, {\n        method: request.method,\n        pathname: new URL(request.url).pathname,\n        routeId: routeMatch?.route.id,\n      });\n    }\n\n    let requestMatches = routeMatch\n      ? [routeMatch]\n      : getLoaderMatchesUntilBoundary(\n          matches,\n          Object.keys(pendingActionError || {})[0]\n        );\n    let matchesToLoad = requestMatches.filter(\n      (m) => m.route.loader || m.route.lazy\n    );\n\n    // Short circuit if we have no loaders to run (query())\n    if (matchesToLoad.length === 0) {\n      return {\n        matches,\n        // Add a null for all matched routes for proper revalidation on the client\n        loaderData: matches.reduce(\n          (acc, m) => Object.assign(acc, { [m.route.id]: null }),\n          {}\n        ),\n        errors: pendingActionError || null,\n        statusCode: 200,\n        loaderHeaders: {},\n        activeDeferreds: null,\n      };\n    }\n\n    let results = await Promise.all([\n      ...matchesToLoad.map((match) =>\n        callLoaderOrAction(\n          \"loader\",\n          request,\n          match,\n          matches,\n          manifest,\n          mapRouteProperties,\n          basename,\n          future.v7_relativeSplatPath,\n          { isStaticRequest: true, isRouteRequest, requestContext }\n        )\n      ),\n    ]);\n\n    if (request.signal.aborted) {\n      let method = isRouteRequest ? \"queryRoute\" : \"query\";\n      throw new Error(\n        `${method}() call aborted: ${request.method} ${request.url}`\n      );\n    }\n\n    // Process and commit output from loaders\n    let activeDeferreds = new Map<string, DeferredData>();\n    let context = processRouteLoaderData(\n      matches,\n      matchesToLoad,\n      results,\n      pendingActionError,\n      activeDeferreds\n    );\n\n    // Add a null for any non-loader matches for proper revalidation on the client\n    let executedLoaders = new Set<string>(\n      matchesToLoad.map((match) => match.route.id)\n    );\n    matches.forEach((match) => {\n      if (!executedLoaders.has(match.route.id)) {\n        context.loaderData[match.route.id] = null;\n      }\n    });\n\n    return {\n      ...context,\n      matches,\n      activeDeferreds:\n        activeDeferreds.size > 0\n          ? Object.fromEntries(activeDeferreds.entries())\n          : null,\n    };\n  }\n\n  return {\n    dataRoutes,\n    query,\n    queryRoute,\n  };\n}\n\n//#endregion\n\n////////////////////////////////////////////////////////////////////////////////\n//#region Helpers\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * Given an existing StaticHandlerContext and an error thrown at render time,\n * provide an updated StaticHandlerContext suitable for a second SSR render\n */\nexport function getStaticContextFromError(\n  routes: AgnosticDataRouteObject[],\n  context: StaticHandlerContext,\n  error: any\n) {\n  let newContext: StaticHandlerContext = {\n    ...context,\n    statusCode: 500,\n    errors: {\n      [context._deepestRenderedBoundaryId || routes[0].id]: error,\n    },\n  };\n  return newContext;\n}\n\nfunction isSubmissionNavigation(\n  opts: BaseNavigateOrFetchOptions\n): opts is SubmissionNavigateOptions {\n  return (\n    opts != null &&\n    ((\"formData\" in opts && opts.formData != null) ||\n      (\"body\" in opts && opts.body !== undefined))\n  );\n}\n\nfunction normalizeTo(\n  location: Path,\n  matches: AgnosticDataRouteMatch[],\n  basename: string,\n  prependBasename: boolean,\n  to: To | null,\n  v7_relativeSplatPath: boolean,\n  fromRouteId?: string,\n  relative?: RelativeRoutingType\n) {\n  let contextualMatches: AgnosticDataRouteMatch[];\n  let activeRouteMatch: AgnosticDataRouteMatch | undefined;\n  if (fromRouteId) {\n    // Grab matches up to the calling route so our route-relative logic is\n    // relative to the correct source route\n    contextualMatches = [];\n    for (let match of matches) {\n      contextualMatches.push(match);\n      if (match.route.id === fromRouteId) {\n        activeRouteMatch = match;\n        break;\n      }\n    }\n  } else {\n    contextualMatches = matches;\n    activeRouteMatch = matches[matches.length - 1];\n  }\n\n  // Resolve the relative path\n  let path = resolveTo(\n    to ? to : \".\",\n    getResolveToMatches(contextualMatches, v7_relativeSplatPath),\n    stripBasename(location.pathname, basename) || location.pathname,\n    relative === \"path\"\n  );\n\n  // When `to` is not specified we inherit search/hash from the current\n  // location, unlike when to=\".\" and we just inherit the path.\n  // See https://github.com/remix-run/remix/issues/927\n  if (to == null) {\n    path.search = location.search;\n    path.hash = location.hash;\n  }\n\n  // Add an ?index param for matched index routes if we don't already have one\n  if (\n    (to == null || to === \"\" || to === \".\") &&\n    activeRouteMatch &&\n    activeRouteMatch.route.index &&\n    !hasNakedIndexQuery(path.search)\n  ) {\n    path.search = path.search\n      ? path.search.replace(/^\\?/, \"?index&\")\n      : \"?index\";\n  }\n\n  // If we're operating within a basename, prepend it to the pathname.  If\n  // this is a root navigation, then just use the raw basename which allows\n  // the basename to have full control over the presence of a trailing slash\n  // on root actions\n  if (prependBasename && basename !== \"/\") {\n    path.pathname =\n      path.pathname === \"/\" ? basename : joinPaths([basename, path.pathname]);\n  }\n\n  return createPath(path);\n}\n\n// Normalize navigation options by converting formMethod=GET formData objects to\n// URLSearchParams so they behave identically to links with query params\nfunction normalizeNavigateOptions(\n  normalizeFormMethod: boolean,\n  isFetcher: boolean,\n  path: string,\n  opts?: BaseNavigateOrFetchOptions\n): {\n  path: string;\n  submission?: Submission;\n  error?: ErrorResponseImpl;\n} {\n  // Return location verbatim on non-submission navigations\n  if (!opts || !isSubmissionNavigation(opts)) {\n    return { path };\n  }\n\n  if (opts.formMethod && !isValidMethod(opts.formMethod)) {\n    return {\n      path,\n      error: getInternalRouterError(405, { method: opts.formMethod }),\n    };\n  }\n\n  let getInvalidBodyError = () => ({\n    path,\n    error: getInternalRouterError(400, { type: \"invalid-body\" }),\n  });\n\n  // Create a Submission on non-GET navigations\n  let rawFormMethod = opts.formMethod || \"get\";\n  let formMethod = normalizeFormMethod\n    ? (rawFormMethod.toUpperCase() as V7_FormMethod)\n    : (rawFormMethod.toLowerCase() as FormMethod);\n  let formAction = stripHashFromPath(path);\n\n  if (opts.body !== undefined) {\n    if (opts.formEncType === \"text/plain\") {\n      // text only support POST/PUT/PATCH/DELETE submissions\n      if (!isMutationMethod(formMethod)) {\n        return getInvalidBodyError();\n      }\n\n      let text =\n        typeof opts.body === \"string\"\n          ? opts.body\n          : opts.body instanceof FormData ||\n            opts.body instanceof URLSearchParams\n          ? // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#plain-text-form-data\n            Array.from(opts.body.entries()).reduce(\n              (acc, [name, value]) => `${acc}${name}=${value}\\n`,\n              \"\"\n            )\n          : String(opts.body);\n\n      return {\n        path,\n        submission: {\n          formMethod,\n          formAction,\n          formEncType: opts.formEncType,\n          formData: undefined,\n          json: undefined,\n          text,\n        },\n      };\n    } else if (opts.formEncType === \"application/json\") {\n      // json only supports POST/PUT/PATCH/DELETE submissions\n      if (!isMutationMethod(formMethod)) {\n        return getInvalidBodyError();\n      }\n\n      try {\n        let json =\n          typeof opts.body === \"string\" ? JSON.parse(opts.body) : opts.body;\n\n        return {\n          path,\n          submission: {\n            formMethod,\n            formAction,\n            formEncType: opts.formEncType,\n            formData: undefined,\n            json,\n            text: undefined,\n          },\n        };\n      } catch (e) {\n        return getInvalidBodyError();\n      }\n    }\n  }\n\n  invariant(\n    typeof FormData === \"function\",\n    \"FormData is not available in this environment\"\n  );\n\n  let searchParams: URLSearchParams;\n  let formData: FormData;\n\n  if (opts.formData) {\n    searchParams = convertFormDataToSearchParams(opts.formData);\n    formData = opts.formData;\n  } else if (opts.body instanceof FormData) {\n    searchParams = convertFormDataToSearchParams(opts.body);\n    formData = opts.body;\n  } else if (opts.body instanceof URLSearchParams) {\n    searchParams = opts.body;\n    formData = convertSearchParamsToFormData(searchParams);\n  } else if (opts.body == null) {\n    searchParams = new URLSearchParams();\n    formData = new FormData();\n  } else {\n    try {\n      searchParams = new URLSearchParams(opts.body);\n      formData = convertSearchParamsToFormData(searchParams);\n    } catch (e) {\n      return getInvalidBodyError();\n    }\n  }\n\n  let submission: Submission = {\n    formMethod,\n    formAction,\n    formEncType:\n      (opts && opts.formEncType) || \"application/x-www-form-urlencoded\",\n    formData,\n    json: undefined,\n    text: undefined,\n  };\n\n  if (isMutationMethod(submission.formMethod)) {\n    return { path, submission };\n  }\n\n  // Flatten submission onto URLSearchParams for GET submissions\n  let parsedPath = parsePath(path);\n  // On GET navigation submissions we can drop the ?index param from the\n  // resulting location since all loaders will run.  But fetcher GET submissions\n  // only run a single loader so we need to preserve any incoming ?index params\n  if (isFetcher && parsedPath.search && hasNakedIndexQuery(parsedPath.search)) {\n    searchParams.append(\"index\", \"\");\n  }\n  parsedPath.search = `?${searchParams}`;\n\n  return { path: createPath(parsedPath), submission };\n}\n\n// Filter out all routes below any caught error as they aren't going to\n// render so we don't need to load them\nfunction getLoaderMatchesUntilBoundary(\n  matches: AgnosticDataRouteMatch[],\n  boundaryId?: string\n) {\n  let boundaryMatches = matches;\n  if (boundaryId) {\n    let index = matches.findIndex((m) => m.route.id === boundaryId);\n    if (index >= 0) {\n      boundaryMatches = matches.slice(0, index);\n    }\n  }\n  return boundaryMatches;\n}\n\nfunction getMatchesToLoad(\n  history: History,\n  state: RouterState,\n  matches: AgnosticDataRouteMatch[],\n  submission: Submission | undefined,\n  location: Location,\n  isInitialLoad: boolean,\n  isRevalidationRequired: boolean,\n  cancelledDeferredRoutes: string[],\n  cancelledFetcherLoads: string[],\n  deletedFetchers: Set<string>,\n  fetchLoadMatches: Map<string, FetchLoadMatch>,\n  fetchRedirectIds: Set<string>,\n  routesToUse: AgnosticDataRouteObject[],\n  basename: string | undefined,\n  pendingActionData?: RouteData,\n  pendingError?: RouteData\n): [AgnosticDataRouteMatch[], RevalidatingFetcher[]] {\n  let actionResult = pendingError\n    ? Object.values(pendingError)[0]\n    : pendingActionData\n    ? Object.values(pendingActionData)[0]\n    : undefined;\n\n  let currentUrl = history.createURL(state.location);\n  let nextUrl = history.createURL(location);\n\n  // Pick navigation matches that are net-new or qualify for revalidation\n  let boundaryId = pendingError ? Object.keys(pendingError)[0] : undefined;\n  let boundaryMatches = getLoaderMatchesUntilBoundary(matches, boundaryId);\n\n  let navigationMatches = boundaryMatches.filter((match, index) => {\n    let { route } = match;\n    if (route.lazy) {\n      // We haven't loaded this route yet so we don't know if it's got a loader!\n      return true;\n    }\n\n    if (route.loader == null) {\n      return false;\n    }\n\n    if (isInitialLoad) {\n      if (route.loader.hydrate) {\n        return true;\n      }\n      return (\n        state.loaderData[route.id] === undefined &&\n        // Don't re-run if the loader ran and threw an error\n        (!state.errors || state.errors[route.id] === undefined)\n      );\n    }\n\n    // Always call the loader on new route instances and pending defer cancellations\n    if (\n      isNewLoader(state.loaderData, state.matches[index], match) ||\n      cancelledDeferredRoutes.some((id) => id === match.route.id)\n    ) {\n      return true;\n    }\n\n    // This is the default implementation for when we revalidate.  If the route\n    // provides it's own implementation, then we give them full control but\n    // provide this value so they can leverage it if needed after they check\n    // their own specific use cases\n    let currentRouteMatch = state.matches[index];\n    let nextRouteMatch = match;\n\n    return shouldRevalidateLoader(match, {\n      currentUrl,\n      currentParams: currentRouteMatch.params,\n      nextUrl,\n      nextParams: nextRouteMatch.params,\n      ...submission,\n      actionResult,\n      defaultShouldRevalidate:\n        // Forced revalidation due to submission, useRevalidator, or X-Remix-Revalidate\n        isRevalidationRequired ||\n        // Clicked the same link, resubmitted a GET form\n        currentUrl.pathname + currentUrl.search ===\n          nextUrl.pathname + nextUrl.search ||\n        // Search params affect all loaders\n        currentUrl.search !== nextUrl.search ||\n        isNewRouteInstance(currentRouteMatch, nextRouteMatch),\n    });\n  });\n\n  // Pick fetcher.loads that need to be revalidated\n  let revalidatingFetchers: RevalidatingFetcher[] = [];\n  fetchLoadMatches.forEach((f, key) => {\n    // Don't revalidate:\n    //  - on initial load (shouldn't be any fetchers then anyway)\n    //  - if fetcher won't be present in the subsequent render\n    //    - no longer matches the URL (v7_fetcherPersist=false)\n    //    - was unmounted but persisted due to v7_fetcherPersist=true\n    if (\n      isInitialLoad ||\n      !matches.some((m) => m.route.id === f.routeId) ||\n      deletedFetchers.has(key)\n    ) {\n      return;\n    }\n\n    let fetcherMatches = matchRoutes(routesToUse, f.path, basename);\n\n    // If the fetcher path no longer matches, push it in with null matches so\n    // we can trigger a 404 in callLoadersAndMaybeResolveData.  Note this is\n    // currently only a use-case for Remix HMR where the route tree can change\n    // at runtime and remove a route previously loaded via a fetcher\n    if (!fetcherMatches) {\n      revalidatingFetchers.push({\n        key,\n        routeId: f.routeId,\n        path: f.path,\n        matches: null,\n        match: null,\n        controller: null,\n      });\n      return;\n    }\n\n    // Revalidating fetchers are decoupled from the route matches since they\n    // load from a static href.  They revalidate based on explicit revalidation\n    // (submission, useRevalidator, or X-Remix-Revalidate)\n    let fetcher = state.fetchers.get(key);\n    let fetcherMatch = getTargetMatch(fetcherMatches, f.path);\n\n    let shouldRevalidate = false;\n    if (fetchRedirectIds.has(key)) {\n      // Never trigger a revalidation of an actively redirecting fetcher\n      shouldRevalidate = false;\n    } else if (cancelledFetcherLoads.includes(key)) {\n      // Always revalidate if the fetcher was cancelled\n      shouldRevalidate = true;\n    } else if (\n      fetcher &&\n      fetcher.state !== \"idle\" &&\n      fetcher.data === undefined\n    ) {\n      // If the fetcher hasn't ever completed loading yet, then this isn't a\n      // revalidation, it would just be a brand new load if an explicit\n      // revalidation is required\n      shouldRevalidate = isRevalidationRequired;\n    } else {\n      // Otherwise fall back on any user-defined shouldRevalidate, defaulting\n      // to explicit revalidations only\n      shouldRevalidate = shouldRevalidateLoader(fetcherMatch, {\n        currentUrl,\n        currentParams: state.matches[state.matches.length - 1].params,\n        nextUrl,\n        nextParams: matches[matches.length - 1].params,\n        ...submission,\n        actionResult,\n        defaultShouldRevalidate: isRevalidationRequired,\n      });\n    }\n\n    if (shouldRevalidate) {\n      revalidatingFetchers.push({\n        key,\n        routeId: f.routeId,\n        path: f.path,\n        matches: fetcherMatches,\n        match: fetcherMatch,\n        controller: new AbortController(),\n      });\n    }\n  });\n\n  return [navigationMatches, revalidatingFetchers];\n}\n\nfunction isNewLoader(\n  currentLoaderData: RouteData,\n  currentMatch: AgnosticDataRouteMatch,\n  match: AgnosticDataRouteMatch\n) {\n  let isNew =\n    // [a] -> [a, b]\n    !currentMatch ||\n    // [a, b] -> [a, c]\n    match.route.id !== currentMatch.route.id;\n\n  // Handle the case that we don't have data for a re-used route, potentially\n  // from a prior error or from a cancelled pending deferred\n  let isMissingData = currentLoaderData[match.route.id] === undefined;\n\n  // Always load if this is a net-new route or we don't yet have data\n  return isNew || isMissingData;\n}\n\nfunction isNewRouteInstance(\n  currentMatch: AgnosticDataRouteMatch,\n  match: AgnosticDataRouteMatch\n) {\n  let currentPath = currentMatch.route.path;\n  return (\n    // param change for this match, /users/123 -> /users/456\n    currentMatch.pathname !== match.pathname ||\n    // splat param changed, which is not present in match.path\n    // e.g. /files/images/avatar.jpg -> files/finances.xls\n    (currentPath != null &&\n      currentPath.endsWith(\"*\") &&\n      currentMatch.params[\"*\"] !== match.params[\"*\"])\n  );\n}\n\nfunction shouldRevalidateLoader(\n  loaderMatch: AgnosticDataRouteMatch,\n  arg: ShouldRevalidateFunctionArgs\n) {\n  if (loaderMatch.route.shouldRevalidate) {\n    let routeChoice = loaderMatch.route.shouldRevalidate(arg);\n    if (typeof routeChoice === \"boolean\") {\n      return routeChoice;\n    }\n  }\n\n  return arg.defaultShouldRevalidate;\n}\n\n/**\n * Execute route.lazy() methods to lazily load route modules (loader, action,\n * shouldRevalidate) and update the routeManifest in place which shares objects\n * with dataRoutes so those get updated as well.\n */\nasync function loadLazyRouteModule(\n  route: AgnosticDataRouteObject,\n  mapRouteProperties: MapRoutePropertiesFunction,\n  manifest: RouteManifest\n) {\n  if (!route.lazy) {\n    return;\n  }\n\n  let lazyRoute = await route.lazy();\n\n  // If the lazy route function was executed and removed by another parallel\n  // call then we can return - first lazy() to finish wins because the return\n  // value of lazy is expected to be static\n  if (!route.lazy) {\n    return;\n  }\n\n  let routeToUpdate = manifest[route.id];\n  invariant(routeToUpdate, \"No route found in manifest\");\n\n  // Update the route in place.  This should be safe because there's no way\n  // we could yet be sitting on this route as we can't get there without\n  // resolving lazy() first.\n  //\n  // This is different than the HMR \"update\" use-case where we may actively be\n  // on the route being updated.  The main concern boils down to \"does this\n  // mutation affect any ongoing navigations or any current state.matches\n  // values?\".  If not, it should be safe to update in place.\n  let routeUpdates: Record<string, any> = {};\n  for (let lazyRouteProperty in lazyRoute) {\n    let staticRouteValue =\n      routeToUpdate[lazyRouteProperty as keyof typeof routeToUpdate];\n\n    let isPropertyStaticallyDefined =\n      staticRouteValue !== undefined &&\n      // This property isn't static since it should always be updated based\n      // on the route updates\n      lazyRouteProperty !== \"hasErrorBoundary\";\n\n    warning(\n      !isPropertyStaticallyDefined,\n      `Route \"${routeToUpdate.id}\" has a static property \"${lazyRouteProperty}\" ` +\n        `defined but its lazy function is also returning a value for this property. ` +\n        `The lazy route property \"${lazyRouteProperty}\" will be ignored.`\n    );\n\n    if (\n      !isPropertyStaticallyDefined &&\n      !immutableRouteKeys.has(lazyRouteProperty as ImmutableRouteKey)\n    ) {\n      routeUpdates[lazyRouteProperty] =\n        lazyRoute[lazyRouteProperty as keyof typeof lazyRoute];\n    }\n  }\n\n  // Mutate the route with the provided updates.  Do this first so we pass\n  // the updated version to mapRouteProperties\n  Object.assign(routeToUpdate, routeUpdates);\n\n  // Mutate the `hasErrorBoundary` property on the route based on the route\n  // updates and remove the `lazy` function so we don't resolve the lazy\n  // route again.\n  Object.assign(routeToUpdate, {\n    // To keep things framework agnostic, we use the provided\n    // `mapRouteProperties` (or wrapped `detectErrorBoundary`) function to\n    // set the framework-aware properties (`element`/`hasErrorBoundary`) since\n    // the logic will differ between frameworks.\n    ...mapRouteProperties(routeToUpdate),\n    lazy: undefined,\n  });\n}\n\nasync function callLoaderOrAction(\n  type: \"loader\" | \"action\",\n  request: Request,\n  match: AgnosticDataRouteMatch,\n  matches: AgnosticDataRouteMatch[],\n  manifest: RouteManifest,\n  mapRouteProperties: MapRoutePropertiesFunction,\n  basename: string,\n  v7_relativeSplatPath: boolean,\n  opts: {\n    isStaticRequest?: boolean;\n    isRouteRequest?: boolean;\n    requestContext?: unknown;\n  } = {}\n): Promise<DataResult> {\n  let resultType;\n  let result;\n  let onReject: (() => void) | undefined;\n\n  let runHandler = (handler: ActionFunction | LoaderFunction) => {\n    // Setup a promise we can race against so that abort signals short circuit\n    let reject: () => void;\n    let abortPromise = new Promise((_, r) => (reject = r));\n    onReject = () => reject();\n    request.signal.addEventListener(\"abort\", onReject);\n    return Promise.race([\n      handler({\n        request,\n        params: match.params,\n        context: opts.requestContext,\n      }),\n      abortPromise,\n    ]);\n  };\n\n  try {\n    let handler = match.route[type];\n\n    if (match.route.lazy) {\n      if (handler) {\n        // Run statically defined handler in parallel with lazy()\n        let handlerError;\n        let values = await Promise.all([\n          // If the handler throws, don't let it immediately bubble out,\n          // since we need to let the lazy() execution finish so we know if this\n          // route has a boundary that can handle the error\n          runHandler(handler).catch((e) => {\n            handlerError = e;\n          }),\n          loadLazyRouteModule(match.route, mapRouteProperties, manifest),\n        ]);\n        if (handlerError) {\n          throw handlerError;\n        }\n        result = values[0];\n      } else {\n        // Load lazy route module, then run any returned handler\n        await loadLazyRouteModule(match.route, mapRouteProperties, manifest);\n\n        handler = match.route[type];\n        if (handler) {\n          // Handler still run even if we got interrupted to maintain consistency\n          // with un-abortable behavior of handler execution on non-lazy or\n          // previously-lazy-loaded routes\n          result = await runHandler(handler);\n        } else if (type === \"action\") {\n          let url = new URL(request.url);\n          let pathname = url.pathname + url.search;\n          throw getInternalRouterError(405, {\n            method: request.method,\n            pathname,\n            routeId: match.route.id,\n          });\n        } else {\n          // lazy() route has no loader to run.  Short circuit here so we don't\n          // hit the invariant below that errors on returning undefined.\n          return { type: ResultType.data, data: undefined };\n        }\n      }\n    } else if (!handler) {\n      let url = new URL(request.url);\n      let pathname = url.pathname + url.search;\n      throw getInternalRouterError(404, {\n        pathname,\n      });\n    } else {\n      result = await runHandler(handler);\n    }\n\n    invariant(\n      result !== undefined,\n      `You defined ${type === \"action\" ? \"an action\" : \"a loader\"} for route ` +\n        `\"${match.route.id}\" but didn't return anything from your \\`${type}\\` ` +\n        `function. Please return a value or \\`null\\`.`\n    );\n  } catch (e) {\n    resultType = ResultType.error;\n    result = e;\n  } finally {\n    if (onReject) {\n      request.signal.removeEventListener(\"abort\", onReject);\n    }\n  }\n\n  if (isResponse(result)) {\n    let status = result.status;\n\n    // Process redirects\n    if (redirectStatusCodes.has(status)) {\n      let location = result.headers.get(\"Location\");\n      invariant(\n        location,\n        \"Redirects returned/thrown from loaders/actions must have a Location header\"\n      );\n\n      // Support relative routing in internal redirects\n      if (!ABSOLUTE_URL_REGEX.test(location)) {\n        location = normalizeTo(\n          new URL(request.url),\n          matches.slice(0, matches.indexOf(match) + 1),\n          basename,\n          true,\n          location,\n          v7_relativeSplatPath\n        );\n      } else if (!opts.isStaticRequest) {\n        // Strip off the protocol+origin for same-origin + same-basename absolute\n        // redirects. If this is a static request, we can let it go back to the\n        // browser as-is\n        let currentUrl = new URL(request.url);\n        let url = location.startsWith(\"//\")\n          ? new URL(currentUrl.protocol + location)\n          : new URL(location);\n        let isSameBasename = stripBasename(url.pathname, basename) != null;\n        if (url.origin === currentUrl.origin && isSameBasename) {\n          location = url.pathname + url.search + url.hash;\n        }\n      }\n\n      // Don't process redirects in the router during static requests requests.\n      // Instead, throw the Response and let the server handle it with an HTTP\n      // redirect.  We also update the Location header in place in this flow so\n      // basename and relative routing is taken into account\n      if (opts.isStaticRequest) {\n        result.headers.set(\"Location\", location);\n        throw result;\n      }\n\n      return {\n        type: ResultType.redirect,\n        status,\n        location,\n        revalidate: result.headers.get(\"X-Remix-Revalidate\") !== null,\n        reloadDocument: result.headers.get(\"X-Remix-Reload-Document\") !== null,\n      };\n    }\n\n    // For SSR single-route requests, we want to hand Responses back directly\n    // without unwrapping.  We do this with the QueryRouteResponse wrapper\n    // interface so we can know whether it was returned or thrown\n    if (opts.isRouteRequest) {\n      let queryRouteResponse: QueryRouteResponse = {\n        type:\n          resultType === ResultType.error ? ResultType.error : ResultType.data,\n        response: result,\n      };\n      throw queryRouteResponse;\n    }\n\n    let data: any;\n\n    try {\n      let contentType = result.headers.get(\"Content-Type\");\n      // Check between word boundaries instead of startsWith() due to the last\n      // paragraph of https://httpwg.org/specs/rfc9110.html#field.content-type\n      if (contentType && /\\bapplication\\/json\\b/.test(contentType)) {\n        data = await result.json();\n      } else {\n        data = await result.text();\n      }\n    } catch (e) {\n      return { type: ResultType.error, error: e };\n    }\n\n    if (resultType === ResultType.error) {\n      return {\n        type: resultType,\n        error: new ErrorResponseImpl(status, result.statusText, data),\n        headers: result.headers,\n      };\n    }\n\n    return {\n      type: ResultType.data,\n      data,\n      statusCode: result.status,\n      headers: result.headers,\n    };\n  }\n\n  if (resultType === ResultType.error) {\n    return { type: resultType, error: result };\n  }\n\n  if (isDeferredData(result)) {\n    return {\n      type: ResultType.deferred,\n      deferredData: result,\n      statusCode: result.init?.status,\n      headers: result.init?.headers && new Headers(result.init.headers),\n    };\n  }\n\n  return { type: ResultType.data, data: result };\n}\n\n// Utility method for creating the Request instances for loaders/actions during\n// client-side navigations and fetches.  During SSR we will always have a\n// Request instance from the static handler (query/queryRoute)\nfunction createClientSideRequest(\n  history: History,\n  location: string | Location,\n  signal: AbortSignal,\n  submission?: Submission\n): Request {\n  let url = history.createURL(stripHashFromPath(location)).toString();\n  let init: RequestInit = { signal };\n\n  if (submission && isMutationMethod(submission.formMethod)) {\n    let { formMethod, formEncType } = submission;\n    // Didn't think we needed this but it turns out unlike other methods, patch\n    // won't be properly normalized to uppercase and results in a 405 error.\n    // See: https://fetch.spec.whatwg.org/#concept-method\n    init.method = formMethod.toUpperCase();\n\n    if (formEncType === \"application/json\") {\n      init.headers = new Headers({ \"Content-Type\": formEncType });\n      init.body = JSON.stringify(submission.json);\n    } else if (formEncType === \"text/plain\") {\n      // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)\n      init.body = submission.text;\n    } else if (\n      formEncType === \"application/x-www-form-urlencoded\" &&\n      submission.formData\n    ) {\n      // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)\n      init.body = convertFormDataToSearchParams(submission.formData);\n    } else {\n      // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)\n      init.body = submission.formData;\n    }\n  }\n\n  return new Request(url, init);\n}\n\nfunction convertFormDataToSearchParams(formData: FormData): URLSearchParams {\n  let searchParams = new URLSearchParams();\n\n  for (let [key, value] of formData.entries()) {\n    // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#converting-an-entry-list-to-a-list-of-name-value-pairs\n    searchParams.append(key, typeof value === \"string\" ? value : value.name);\n  }\n\n  return searchParams;\n}\n\nfunction convertSearchParamsToFormData(\n  searchParams: URLSearchParams\n): FormData {\n  let formData = new FormData();\n  for (let [key, value] of searchParams.entries()) {\n    formData.append(key, value);\n  }\n  return formData;\n}\n\nfunction processRouteLoaderData(\n  matches: AgnosticDataRouteMatch[],\n  matchesToLoad: AgnosticDataRouteMatch[],\n  results: DataResult[],\n  pendingError: RouteData | undefined,\n  activeDeferreds: Map<string, DeferredData>\n): {\n  loaderData: RouterState[\"loaderData\"];\n  errors: RouterState[\"errors\"] | null;\n  statusCode: number;\n  loaderHeaders: Record<string, Headers>;\n} {\n  // Fill in loaderData/errors from our loaders\n  let loaderData: RouterState[\"loaderData\"] = {};\n  let errors: RouterState[\"errors\"] | null = null;\n  let statusCode: number | undefined;\n  let foundError = false;\n  let loaderHeaders: Record<string, Headers> = {};\n\n  // Process loader results into state.loaderData/state.errors\n  results.forEach((result, index) => {\n    let id = matchesToLoad[index].route.id;\n    invariant(\n      !isRedirectResult(result),\n      \"Cannot handle redirect results in processLoaderData\"\n    );\n    if (isErrorResult(result)) {\n      // Look upwards from the matched route for the closest ancestor\n      // error boundary, defaulting to the root match\n      let boundaryMatch = findNearestBoundary(matches, id);\n      let error = result.error;\n      // If we have a pending action error, we report it at the highest-route\n      // that throws a loader error, and then clear it out to indicate that\n      // it was consumed\n      if (pendingError) {\n        error = Object.values(pendingError)[0];\n        pendingError = undefined;\n      }\n\n      errors = errors || {};\n\n      // Prefer higher error values if lower errors bubble to the same boundary\n      if (errors[boundaryMatch.route.id] == null) {\n        errors[boundaryMatch.route.id] = error;\n      }\n\n      // Clear our any prior loaderData for the throwing route\n      loaderData[id] = undefined;\n\n      // Once we find our first (highest) error, we set the status code and\n      // prevent deeper status codes from overriding\n      if (!foundError) {\n        foundError = true;\n        statusCode = isRouteErrorResponse(result.error)\n          ? result.error.status\n          : 500;\n      }\n      if (result.headers) {\n        loaderHeaders[id] = result.headers;\n      }\n    } else {\n      if (isDeferredResult(result)) {\n        activeDeferreds.set(id, result.deferredData);\n        loaderData[id] = result.deferredData.data;\n      } else {\n        loaderData[id] = result.data;\n      }\n\n      // Error status codes always override success status codes, but if all\n      // loaders are successful we take the deepest status code.\n      if (\n        result.statusCode != null &&\n        result.statusCode !== 200 &&\n        !foundError\n      ) {\n        statusCode = result.statusCode;\n      }\n      if (result.headers) {\n        loaderHeaders[id] = result.headers;\n      }\n    }\n  });\n\n  // If we didn't consume the pending action error (i.e., all loaders\n  // resolved), then consume it here.  Also clear out any loaderData for the\n  // throwing route\n  if (pendingError) {\n    errors = pendingError;\n    loaderData[Object.keys(pendingError)[0]] = undefined;\n  }\n\n  return {\n    loaderData,\n    errors,\n    statusCode: statusCode || 200,\n    loaderHeaders,\n  };\n}\n\nfunction processLoaderData(\n  state: RouterState,\n  matches: AgnosticDataRouteMatch[],\n  matchesToLoad: AgnosticDataRouteMatch[],\n  results: DataResult[],\n  pendingError: RouteData | undefined,\n  revalidatingFetchers: RevalidatingFetcher[],\n  fetcherResults: DataResult[],\n  activeDeferreds: Map<string, DeferredData>\n): {\n  loaderData: RouterState[\"loaderData\"];\n  errors?: RouterState[\"errors\"];\n} {\n  let { loaderData, errors } = processRouteLoaderData(\n    matches,\n    matchesToLoad,\n    results,\n    pendingError,\n    activeDeferreds\n  );\n\n  // Process results from our revalidating fetchers\n  for (let index = 0; index < revalidatingFetchers.length; index++) {\n    let { key, match, controller } = revalidatingFetchers[index];\n    invariant(\n      fetcherResults !== undefined && fetcherResults[index] !== undefined,\n      \"Did not find corresponding fetcher result\"\n    );\n    let result = fetcherResults[index];\n\n    // Process fetcher non-redirect errors\n    if (controller && controller.signal.aborted) {\n      // Nothing to do for aborted fetchers\n      continue;\n    } else if (isErrorResult(result)) {\n      let boundaryMatch = findNearestBoundary(state.matches, match?.route.id);\n      if (!(errors && errors[boundaryMatch.route.id])) {\n        errors = {\n          ...errors,\n          [boundaryMatch.route.id]: result.error,\n        };\n      }\n      state.fetchers.delete(key);\n    } else if (isRedirectResult(result)) {\n      // Should never get here, redirects should get processed above, but we\n      // keep this to type narrow to a success result in the else\n      invariant(false, \"Unhandled fetcher revalidation redirect\");\n    } else if (isDeferredResult(result)) {\n      // Should never get here, deferred data should be awaited for fetchers\n      // in resolveDeferredResults\n      invariant(false, \"Unhandled fetcher deferred data\");\n    } else {\n      let doneFetcher = getDoneFetcher(result.data);\n      state.fetchers.set(key, doneFetcher);\n    }\n  }\n\n  return { loaderData, errors };\n}\n\nfunction mergeLoaderData(\n  loaderData: RouteData,\n  newLoaderData: RouteData,\n  matches: AgnosticDataRouteMatch[],\n  errors: RouteData | null | undefined\n): RouteData {\n  let mergedLoaderData = { ...newLoaderData };\n  for (let match of matches) {\n    let id = match.route.id;\n    if (newLoaderData.hasOwnProperty(id)) {\n      if (newLoaderData[id] !== undefined) {\n        mergedLoaderData[id] = newLoaderData[id];\n      } else {\n        // No-op - this is so we ignore existing data if we have a key in the\n        // incoming object with an undefined value, which is how we unset a prior\n        // loaderData if we encounter a loader error\n      }\n    } else if (loaderData[id] !== undefined && match.route.loader) {\n      // Preserve existing keys not included in newLoaderData and where a loader\n      // wasn't removed by HMR\n      mergedLoaderData[id] = loaderData[id];\n    }\n\n    if (errors && errors.hasOwnProperty(id)) {\n      // Don't keep any loader data below the boundary\n      break;\n    }\n  }\n  return mergedLoaderData;\n}\n\n// Find the nearest error boundary, looking upwards from the leaf route (or the\n// route specified by routeId) for the closest ancestor error boundary,\n// defaulting to the root match\nfunction findNearestBoundary(\n  matches: AgnosticDataRouteMatch[],\n  routeId?: string\n): AgnosticDataRouteMatch {\n  let eligibleMatches = routeId\n    ? matches.slice(0, matches.findIndex((m) => m.route.id === routeId) + 1)\n    : [...matches];\n  return (\n    eligibleMatches.reverse().find((m) => m.route.hasErrorBoundary === true) ||\n    matches[0]\n  );\n}\n\nfunction getShortCircuitMatches(routes: AgnosticDataRouteObject[]): {\n  matches: AgnosticDataRouteMatch[];\n  route: AgnosticDataRouteObject;\n} {\n  // Prefer a root layout route if present, otherwise shim in a route object\n  let route =\n    routes.length === 1\n      ? routes[0]\n      : routes.find((r) => r.index || !r.path || r.path === \"/\") || {\n          id: `__shim-error-route__`,\n        };\n\n  return {\n    matches: [\n      {\n        params: {},\n        pathname: \"\",\n        pathnameBase: \"\",\n        route,\n      },\n    ],\n    route,\n  };\n}\n\nfunction getInternalRouterError(\n  status: number,\n  {\n    pathname,\n    routeId,\n    method,\n    type,\n  }: {\n    pathname?: string;\n    routeId?: string;\n    method?: string;\n    type?: \"defer-action\" | \"invalid-body\";\n  } = {}\n) {\n  let statusText = \"Unknown Server Error\";\n  let errorMessage = \"Unknown @remix-run/router error\";\n\n  if (status === 400) {\n    statusText = \"Bad Request\";\n    if (method && pathname && routeId) {\n      errorMessage =\n        `You made a ${method} request to \"${pathname}\" but ` +\n        `did not provide a \\`loader\\` for route \"${routeId}\", ` +\n        `so there is no way to handle the request.`;\n    } else if (type === \"defer-action\") {\n      errorMessage = \"defer() is not supported in actions\";\n    } else if (type === \"invalid-body\") {\n      errorMessage = \"Unable to encode submission body\";\n    }\n  } else if (status === 403) {\n    statusText = \"Forbidden\";\n    errorMessage = `Route \"${routeId}\" does not match URL \"${pathname}\"`;\n  } else if (status === 404) {\n    statusText = \"Not Found\";\n    errorMessage = `No route matches URL \"${pathname}\"`;\n  } else if (status === 405) {\n    statusText = \"Method Not Allowed\";\n    if (method && pathname && routeId) {\n      errorMessage =\n        `You made a ${method.toUpperCase()} request to \"${pathname}\" but ` +\n        `did not provide an \\`action\\` for route \"${routeId}\", ` +\n        `so there is no way to handle the request.`;\n    } else if (method) {\n      errorMessage = `Invalid request method \"${method.toUpperCase()}\"`;\n    }\n  }\n\n  return new ErrorResponseImpl(\n    status || 500,\n    statusText,\n    new Error(errorMessage),\n    true\n  );\n}\n\n// Find any returned redirect errors, starting from the lowest match\nfunction findRedirect(\n  results: DataResult[]\n): { result: RedirectResult; idx: number } | undefined {\n  for (let i = results.length - 1; i >= 0; i--) {\n    let result = results[i];\n    if (isRedirectResult(result)) {\n      return { result, idx: i };\n    }\n  }\n}\n\nfunction stripHashFromPath(path: To) {\n  let parsedPath = typeof path === \"string\" ? parsePath(path) : path;\n  return createPath({ ...parsedPath, hash: \"\" });\n}\n\nfunction isHashChangeOnly(a: Location, b: Location): boolean {\n  if (a.pathname !== b.pathname || a.search !== b.search) {\n    return false;\n  }\n\n  if (a.hash === \"\") {\n    // /page -> /page#hash\n    return b.hash !== \"\";\n  } else if (a.hash === b.hash) {\n    // /page#hash -> /page#hash\n    return true;\n  } else if (b.hash !== \"\") {\n    // /page#hash -> /page#other\n    return true;\n  }\n\n  // If the hash is removed the browser will re-perform a request to the server\n  // /page#hash -> /page\n  return false;\n}\n\nfunction isDeferredResult(result: DataResult): result is DeferredResult {\n  return result.type === ResultType.deferred;\n}\n\nfunction isErrorResult(result: DataResult): result is ErrorResult {\n  return result.type === ResultType.error;\n}\n\nfunction isRedirectResult(result?: DataResult): result is RedirectResult {\n  return (result && result.type) === ResultType.redirect;\n}\n\nexport function isDeferredData(value: any): value is DeferredData {\n  let deferred: DeferredData = value;\n  return (\n    deferred &&\n    typeof deferred === \"object\" &&\n    typeof deferred.data === \"object\" &&\n    typeof deferred.subscribe === \"function\" &&\n    typeof deferred.cancel === \"function\" &&\n    typeof deferred.resolveData === \"function\"\n  );\n}\n\nfunction isResponse(value: any): value is Response {\n  return (\n    value != null &&\n    typeof value.status === \"number\" &&\n    typeof value.statusText === \"string\" &&\n    typeof value.headers === \"object\" &&\n    typeof value.body !== \"undefined\"\n  );\n}\n\nfunction isRedirectResponse(result: any): result is Response {\n  if (!isResponse(result)) {\n    return false;\n  }\n\n  let status = result.status;\n  let location = result.headers.get(\"Location\");\n  return status >= 300 && status <= 399 && location != null;\n}\n\nfunction isQueryRouteResponse(obj: any): obj is QueryRouteResponse {\n  return (\n    obj &&\n    isResponse(obj.response) &&\n    (obj.type === ResultType.data || obj.type === ResultType.error)\n  );\n}\n\nfunction isValidMethod(method: string): method is FormMethod | V7_FormMethod {\n  return validRequestMethods.has(method.toLowerCase() as FormMethod);\n}\n\nfunction isMutationMethod(\n  method: string\n): method is MutationFormMethod | V7_MutationFormMethod {\n  return validMutationMethods.has(method.toLowerCase() as MutationFormMethod);\n}\n\nasync function resolveDeferredResults(\n  currentMatches: AgnosticDataRouteMatch[],\n  matchesToLoad: (AgnosticDataRouteMatch | null)[],\n  results: DataResult[],\n  signals: (AbortSignal | null)[],\n  isFetcher: boolean,\n  currentLoaderData?: RouteData\n) {\n  for (let index = 0; index < results.length; index++) {\n    let result = results[index];\n    let match = matchesToLoad[index];\n    // If we don't have a match, then we can have a deferred result to do\n    // anything with.  This is for revalidating fetchers where the route was\n    // removed during HMR\n    if (!match) {\n      continue;\n    }\n\n    let currentMatch = currentMatches.find(\n      (m) => m.route.id === match!.route.id\n    );\n    let isRevalidatingLoader =\n      currentMatch != null &&\n      !isNewRouteInstance(currentMatch, match) &&\n      (currentLoaderData && currentLoaderData[match.route.id]) !== undefined;\n\n    if (isDeferredResult(result) && (isFetcher || isRevalidatingLoader)) {\n      // Note: we do not have to touch activeDeferreds here since we race them\n      // against the signal in resolveDeferredData and they'll get aborted\n      // there if needed\n      let signal = signals[index];\n      invariant(\n        signal,\n        \"Expected an AbortSignal for revalidating fetcher deferred result\"\n      );\n      await resolveDeferredData(result, signal, isFetcher).then((result) => {\n        if (result) {\n          results[index] = result || results[index];\n        }\n      });\n    }\n  }\n}\n\nasync function resolveDeferredData(\n  result: DeferredResult,\n  signal: AbortSignal,\n  unwrap = false\n): Promise<SuccessResult | ErrorResult | undefined> {\n  let aborted = await result.deferredData.resolveData(signal);\n  if (aborted) {\n    return;\n  }\n\n  if (unwrap) {\n    try {\n      return {\n        type: ResultType.data,\n        data: result.deferredData.unwrappedData,\n      };\n    } catch (e) {\n      // Handle any TrackedPromise._error values encountered while unwrapping\n      return {\n        type: ResultType.error,\n        error: e,\n      };\n    }\n  }\n\n  return {\n    type: ResultType.data,\n    data: result.deferredData.data,\n  };\n}\n\nfunction hasNakedIndexQuery(search: string): boolean {\n  return new URLSearchParams(search).getAll(\"index\").some((v) => v === \"\");\n}\n\nfunction getTargetMatch(\n  matches: AgnosticDataRouteMatch[],\n  location: Location | string\n) {\n  let search =\n    typeof location === \"string\" ? parsePath(location).search : location.search;\n  if (\n    matches[matches.length - 1].route.index &&\n    hasNakedIndexQuery(search || \"\")\n  ) {\n    // Return the leaf index route when index is present\n    return matches[matches.length - 1];\n  }\n  // Otherwise grab the deepest \"path contributing\" match (ignoring index and\n  // pathless layout routes)\n  let pathMatches = getPathContributingMatches(matches);\n  return pathMatches[pathMatches.length - 1];\n}\n\nfunction getSubmissionFromNavigation(\n  navigation: Navigation\n): Submission | undefined {\n  let { formMethod, formAction, formEncType, text, formData, json } =\n    navigation;\n  if (!formMethod || !formAction || !formEncType) {\n    return;\n  }\n\n  if (text != null) {\n    return {\n      formMethod,\n      formAction,\n      formEncType,\n      formData: undefined,\n      json: undefined,\n      text,\n    };\n  } else if (formData != null) {\n    return {\n      formMethod,\n      formAction,\n      formEncType,\n      formData,\n      json: undefined,\n      text: undefined,\n    };\n  } else if (json !== undefined) {\n    return {\n      formMethod,\n      formAction,\n      formEncType,\n      formData: undefined,\n      json,\n      text: undefined,\n    };\n  }\n}\n\nfunction getLoadingNavigation(\n  location: Location,\n  submission?: Submission\n): NavigationStates[\"Loading\"] {\n  if (submission) {\n    let navigation: NavigationStates[\"Loading\"] = {\n      state: \"loading\",\n      location,\n      formMethod: submission.formMethod,\n      formAction: submission.formAction,\n      formEncType: submission.formEncType,\n      formData: submission.formData,\n      json: submission.json,\n      text: submission.text,\n    };\n    return navigation;\n  } else {\n    let navigation: NavigationStates[\"Loading\"] = {\n      state: \"loading\",\n      location,\n      formMethod: undefined,\n      formAction: undefined,\n      formEncType: undefined,\n      formData: undefined,\n      json: undefined,\n      text: undefined,\n    };\n    return navigation;\n  }\n}\n\nfunction getSubmittingNavigation(\n  location: Location,\n  submission: Submission\n): NavigationStates[\"Submitting\"] {\n  let navigation: NavigationStates[\"Submitting\"] = {\n    state: \"submitting\",\n    location,\n    formMethod: submission.formMethod,\n    formAction: submission.formAction,\n    formEncType: submission.formEncType,\n    formData: submission.formData,\n    json: submission.json,\n    text: submission.text,\n  };\n  return navigation;\n}\n\nfunction getLoadingFetcher(\n  submission?: Submission,\n  data?: Fetcher[\"data\"]\n): FetcherStates[\"Loading\"] {\n  if (submission) {\n    let fetcher: FetcherStates[\"Loading\"] = {\n      state: \"loading\",\n      formMethod: submission.formMethod,\n      formAction: submission.formAction,\n      formEncType: submission.formEncType,\n      formData: submission.formData,\n      json: submission.json,\n      text: submission.text,\n      data,\n    };\n    return fetcher;\n  } else {\n    let fetcher: FetcherStates[\"Loading\"] = {\n      state: \"loading\",\n      formMethod: undefined,\n      formAction: undefined,\n      formEncType: undefined,\n      formData: undefined,\n      json: undefined,\n      text: undefined,\n      data,\n    };\n    return fetcher;\n  }\n}\n\nfunction getSubmittingFetcher(\n  submission: Submission,\n  existingFetcher?: Fetcher\n): FetcherStates[\"Submitting\"] {\n  let fetcher: FetcherStates[\"Submitting\"] = {\n    state: \"submitting\",\n    formMethod: submission.formMethod,\n    formAction: submission.formAction,\n    formEncType: submission.formEncType,\n    formData: submission.formData,\n    json: submission.json,\n    text: submission.text,\n    data: existingFetcher ? existingFetcher.data : undefined,\n  };\n  return fetcher;\n}\n\nfunction getDoneFetcher(data: Fetcher[\"data\"]): FetcherStates[\"Idle\"] {\n  let fetcher: FetcherStates[\"Idle\"] = {\n    state: \"idle\",\n    formMethod: undefined,\n    formAction: undefined,\n    formEncType: undefined,\n    formData: undefined,\n    json: undefined,\n    text: undefined,\n    data,\n  };\n  return fetcher;\n}\n\nfunction restoreAppliedTransitions(\n  _window: Window,\n  transitions: Map<string, Set<string>>\n) {\n  try {\n    let sessionPositions = _window.sessionStorage.getItem(\n      TRANSITIONS_STORAGE_KEY\n    );\n    if (sessionPositions) {\n      let json = JSON.parse(sessionPositions);\n      for (let [k, v] of Object.entries(json || {})) {\n        if (v && Array.isArray(v)) {\n          transitions.set(k, new Set(v || []));\n        }\n      }\n    }\n  } catch (e) {\n    // no-op, use default empty object\n  }\n}\n\nfunction persistAppliedTransitions(\n  _window: Window,\n  transitions: Map<string, Set<string>>\n) {\n  if (transitions.size > 0) {\n    let json: Record<string, string[]> = {};\n    for (let [k, v] of transitions) {\n      json[k] = [...v];\n    }\n    try {\n      _window.sessionStorage.setItem(\n        TRANSITIONS_STORAGE_KEY,\n        JSON.stringify(json)\n      );\n    } catch (error) {\n      warning(\n        false,\n        `Failed to save applied view transitions in sessionStorage (${error}).`\n      );\n    }\n  }\n}\n\n//#endregion\n", "/**\n * @remix-run/server-runtime v2.4.1\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n/**\n * The mode to use when running the server.\n */\nlet ServerMode = /*#__PURE__*/function (ServerMode) {\n  ServerMode[\"Development\"] = \"development\";\n  ServerMode[\"Production\"] = \"production\";\n  ServerMode[\"Test\"] = \"test\";\n  return ServerMode;\n}({});\nfunction isServerMode(value) {\n  return value === ServerMode.Development || value === ServerMode.Production || value === ServerMode.Test;\n}\n\nexports.ServerMode = ServerMode;\nexports.isServerMode = isServerMode;\n", "/**\n * @remix-run/server-runtime v2.4.1\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar router = require('@remix-run/router');\nvar mode = require('./mode.js');\n\n/**\n * This thing probably warrants some explanation.\n *\n * The whole point here is to emulate componentDidCatch for server rendering and\n * data loading. It can get tricky. React can do this on component boundaries\n * but doesn't support it for server rendering or data loading. We know enough\n * with nested routes to be able to emulate the behavior (because we know them\n * statically before rendering.)\n *\n * Each route can export an `ErrorBoundary`.\n *\n * - When rendering throws an error, the nearest error boundary will render\n *   (normal react componentDidCatch). This will be the route's own boundary, but\n *   if none is provided, it will bubble up to the parents.\n * - When data loading throws an error, the nearest error boundary will render\n * - When performing an action, the nearest error boundary for the action's\n *   route tree will render (no redirect happens)\n *\n * During normal react rendering, we do nothing special, just normal\n * componentDidCatch.\n *\n * For server rendering, we mutate `renderBoundaryRouteId` to know the last\n * layout that has an error boundary that tried to render. This emulates which\n * layout would catch a thrown error. If the rendering fails, we catch the error\n * on the server, and go again a second time with the emulator holding on to the\n * information it needs to render the same error boundary as a dynamically\n * thrown render error.\n *\n * When data loading, server or client side, we use the emulator to likewise\n * hang on to the error and re-render at the appropriate layout (where a thrown\n * error would have been caught by cDC).\n *\n * When actions throw, it all works the same. There's an edge case to be aware\n * of though. Actions normally are required to redirect, but in the case of\n * errors, we render the action's route with the emulator holding on to the\n * error. If during this render a parent route/loader throws we ignore that new\n * error and render the action's original error as deeply as possible. In other\n * words, we simply ignore the new error and use the action's error in place\n * because it came first, and that just wouldn't be fair to let errors cut in\n * line.\n */\n\nfunction sanitizeError(error, serverMode) {\n  if (error instanceof Error && serverMode !== mode.ServerMode.Development) {\n    let sanitized = new Error(\"Unexpected Server Error\");\n    sanitized.stack = undefined;\n    return sanitized;\n  }\n  return error;\n}\nfunction sanitizeErrors(errors, serverMode) {\n  return Object.entries(errors).reduce((acc, [routeId, error]) => {\n    return Object.assign(acc, {\n      [routeId]: sanitizeError(error, serverMode)\n    });\n  }, {});\n}\n\n// must be type alias due to inference issues on interfaces\n// https://github.com/microsoft/TypeScript/issues/15300\nfunction serializeError(error, serverMode) {\n  let sanitized = sanitizeError(error, serverMode);\n  return {\n    message: sanitized.message,\n    stack: sanitized.stack\n  };\n}\nfunction serializeErrors(errors, serverMode) {\n  if (!errors) return null;\n  let entries = Object.entries(errors);\n  let serialized = {};\n  for (let [key, val] of entries) {\n    // Hey you!  If you change this, please change the corresponding logic in\n    // deserializeErrors in remix-react/errors.ts :)\n    if (router.isRouteErrorResponse(val)) {\n      serialized[key] = {\n        ...val,\n        __type: \"RouteErrorResponse\"\n      };\n    } else if (val instanceof Error) {\n      let sanitized = sanitizeError(val, serverMode);\n      serialized[key] = {\n        message: sanitized.message,\n        stack: sanitized.stack,\n        __type: \"Error\",\n        // If this is a subclass (i.e., ReferenceError), send up the type so we\n        // can re-create the same type during hydration.  This will only apply\n        // in dev mode since all production errors are sanitized to normal\n        // Error instances\n        ...(sanitized.name !== \"Error\" ? {\n          __subType: sanitized.name\n        } : {})\n      };\n    } else {\n      serialized[key] = val;\n    }\n  }\n  return serialized;\n}\n\nexports.sanitizeError = sanitizeError;\nexports.sanitizeErrors = sanitizeErrors;\nexports.serializeError = serializeError;\nexports.serializeErrors = serializeErrors;\n", "/**\n * @remix-run/server-runtime v2.4.1\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar router = require('@remix-run/router');\nvar errors = require('./errors.js');\n\n// must be a type since this is a subtype of response\n// interfaces must conform to the types they extend\n/**\n * This is a shortcut for creating `application/json` responses. Converts `data`\n * to JSON and sets the `Content-Type` header.\n *\n * @see https://remix.run/utils/json\n */\nconst json = (data, init = {}) => {\n  return router.json(data, init);\n};\n\n/**\n * This is a shortcut for creating Remix deferred responses\n *\n * @see https://remix.run/utils/defer\n */\nconst defer = (data, init = {}) => {\n  return router.defer(data, init);\n};\n/**\n * A redirect response. Sets the status code and the `Location` header.\n * Defaults to \"302 Found\".\n *\n * @see https://remix.run/utils/redirect\n */\nconst redirect = (url, init = 302) => {\n  return router.redirect(url, init);\n};\n\n/**\n * A redirect response that will force a document reload to the new location.\n * Sets the status code and the `Location` header.\n * Defaults to \"302 Found\".\n *\n * @see https://remix.run/utils/redirect\n */\nconst redirectDocument = (url, init = 302) => {\n  return router.redirectDocument(url, init);\n};\nfunction isDeferredData(value) {\n  let deferred = value;\n  return deferred && typeof deferred === \"object\" && typeof deferred.data === \"object\" && typeof deferred.subscribe === \"function\" && typeof deferred.cancel === \"function\" && typeof deferred.resolveData === \"function\";\n}\nfunction isResponse(value) {\n  return value != null && typeof value.status === \"number\" && typeof value.statusText === \"string\" && typeof value.headers === \"object\" && typeof value.body !== \"undefined\";\n}\nconst redirectStatusCodes = new Set([301, 302, 303, 307, 308]);\nfunction isRedirectStatusCode(statusCode) {\n  return redirectStatusCodes.has(statusCode);\n}\nfunction isRedirectResponse(response) {\n  return isRedirectStatusCode(response.status);\n}\nfunction isTrackedPromise(value) {\n  return value != null && typeof value.then === \"function\" && value._tracked === true;\n}\n\n// TODO: Figure out why ReadableStream types are borked sooooooo badly\n// in this file. Probably related to our TS configurations and configs\n// bleeding into each other.\nconst DEFERRED_VALUE_PLACEHOLDER_PREFIX = \"__deferred_promise:\";\nfunction createDeferredReadableStream(deferredData, signal, serverMode) {\n  let encoder = new TextEncoder();\n  let stream = new ReadableStream({\n    async start(controller) {\n      let criticalData = {};\n      let preresolvedKeys = [];\n      for (let [key, value] of Object.entries(deferredData.data)) {\n        if (isTrackedPromise(value)) {\n          criticalData[key] = `${DEFERRED_VALUE_PLACEHOLDER_PREFIX}${key}`;\n          if (typeof value._data !== \"undefined\" || typeof value._error !== \"undefined\") {\n            preresolvedKeys.push(key);\n          }\n        } else {\n          criticalData[key] = value;\n        }\n      }\n\n      // Send the critical data\n      controller.enqueue(encoder.encode(JSON.stringify(criticalData) + \"\\n\\n\"));\n      for (let preresolvedKey of preresolvedKeys) {\n        enqueueTrackedPromise(controller, encoder, preresolvedKey, deferredData.data[preresolvedKey], serverMode);\n      }\n      let unsubscribe = deferredData.subscribe((aborted, settledKey) => {\n        if (settledKey) {\n          enqueueTrackedPromise(controller, encoder, settledKey, deferredData.data[settledKey], serverMode);\n        }\n      });\n      await deferredData.resolveData(signal);\n      unsubscribe();\n      controller.close();\n    }\n  });\n  return stream;\n}\nfunction enqueueTrackedPromise(controller, encoder, settledKey, promise, serverMode) {\n  if (\"_error\" in promise) {\n    controller.enqueue(encoder.encode(\"error:\" + JSON.stringify({\n      [settledKey]: promise._error instanceof Error ? errors.serializeError(promise._error, serverMode) : promise._error\n    }) + \"\\n\\n\"));\n  } else {\n    controller.enqueue(encoder.encode(\"data:\" + JSON.stringify({\n      [settledKey]: promise._data ?? null\n    }) + \"\\n\\n\"));\n  }\n}\n\nexports.createDeferredReadableStream = createDeferredReadableStream;\nexports.defer = defer;\nexports.isDeferredData = isDeferredData;\nexports.isRedirectResponse = isRedirectResponse;\nexports.isRedirectStatusCode = isRedirectStatusCode;\nexports.isResponse = isResponse;\nexports.json = json;\nexports.redirect = redirect;\nexports.redirectDocument = redirectDocument;\n", "/**\n * @remix-run/server-runtime v2.4.1\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nfunction createEntryRouteModules(manifest) {\n  return Object.keys(manifest).reduce((memo, routeId) => {\n    memo[routeId] = manifest[routeId].module;\n    return memo;\n  }, {});\n}\n\nexports.createEntryRouteModules = createEntryRouteModules;\n", "\"use strict\";\n\nvar defaultParseOptions = {\n  decodeValues: true,\n  map: false,\n  silent: false,\n};\n\nfunction isNonEmptyString(str) {\n  return typeof str === \"string\" && !!str.trim();\n}\n\nfunction parseString(setCookieValue, options) {\n  var parts = setCookieValue.split(\";\").filter(isNonEmptyString);\n\n  var nameValuePairStr = parts.shift();\n  var parsed = parseNameValuePair(nameValuePairStr);\n  var name = parsed.name;\n  var value = parsed.value;\n\n  options = options\n    ? Object.assign({}, defaultParseOptions, options)\n    : defaultParseOptions;\n\n  try {\n    value = options.decodeValues ? decodeURIComponent(value) : value; // decode cookie value\n  } catch (e) {\n    console.error(\n      \"set-cookie-parser encountered an error while decoding a cookie with value '\" +\n        value +\n        \"'. Set options.decodeValues to false to disable this feature.\",\n      e\n    );\n  }\n\n  var cookie = {\n    name: name,\n    value: value,\n  };\n\n  parts.forEach(function (part) {\n    var sides = part.split(\"=\");\n    var key = sides.shift().trimLeft().toLowerCase();\n    var value = sides.join(\"=\");\n    if (key === \"expires\") {\n      cookie.expires = new Date(value);\n    } else if (key === \"max-age\") {\n      cookie.maxAge = parseInt(value, 10);\n    } else if (key === \"secure\") {\n      cookie.secure = true;\n    } else if (key === \"httponly\") {\n      cookie.httpOnly = true;\n    } else if (key === \"samesite\") {\n      cookie.sameSite = value;\n    } else {\n      cookie[key] = value;\n    }\n  });\n\n  return cookie;\n}\n\nfunction parseNameValuePair(nameValuePairStr) {\n  // Parses name-value-pair according to rfc6265bis draft\n\n  var name = \"\";\n  var value = \"\";\n  var nameValueArr = nameValuePairStr.split(\"=\");\n  if (nameValueArr.length > 1) {\n    name = nameValueArr.shift();\n    value = nameValueArr.join(\"=\"); // everything after the first =, joined by a \"=\" if there was more than one part\n  } else {\n    value = nameValuePairStr;\n  }\n\n  return { name: name, value: value };\n}\n\nfunction parse(input, options) {\n  options = options\n    ? Object.assign({}, defaultParseOptions, options)\n    : defaultParseOptions;\n\n  if (!input) {\n    if (!options.map) {\n      return [];\n    } else {\n      return {};\n    }\n  }\n\n  if (input.headers) {\n    if (typeof input.headers.getSetCookie === \"function\") {\n      // for fetch responses - they combine headers of the same type in the headers array,\n      // but getSetCookie returns an uncombined array\n      input = input.headers.getSetCookie();\n    } else if (input.headers[\"set-cookie\"]) {\n      // fast-path for node.js (which automatically normalizes header names to lower-case\n      input = input.headers[\"set-cookie\"];\n    } else {\n      // slow-path for other environments - see #25\n      var sch =\n        input.headers[\n          Object.keys(input.headers).find(function (key) {\n            return key.toLowerCase() === \"set-cookie\";\n          })\n        ];\n      // warn if called on a request-like object with a cookie header rather than a set-cookie header - see #34, 36\n      if (!sch && input.headers.cookie && !options.silent) {\n        console.warn(\n          \"Warning: set-cookie-parser appears to have been called on a request object. It is designed to parse Set-Cookie headers from responses, not Cookie headers from requests. Set the option {silent: true} to suppress this warning.\"\n        );\n      }\n      input = sch;\n    }\n  }\n  if (!Array.isArray(input)) {\n    input = [input];\n  }\n\n  options = options\n    ? Object.assign({}, defaultParseOptions, options)\n    : defaultParseOptions;\n\n  if (!options.map) {\n    return input.filter(isNonEmptyString).map(function (str) {\n      return parseString(str, options);\n    });\n  } else {\n    var cookies = {};\n    return input.filter(isNonEmptyString).reduce(function (cookies, str) {\n      var cookie = parseString(str, options);\n      cookies[cookie.name] = cookie;\n      return cookies;\n    }, cookies);\n  }\n}\n\n/*\n  Set-Cookie header field-values are sometimes comma joined in one string. This splits them without choking on commas\n  that are within a single set-cookie field-value, such as in the Expires portion.\n\n  This is uncommon, but explicitly allowed - see https://tools.ietf.org/html/rfc2616#section-4.2\n  Node.js does this for every header *except* set-cookie - see https://github.com/nodejs/node/blob/d5e363b77ebaf1caf67cd7528224b651c86815c1/lib/_http_incoming.js#L128\n  React Native's fetch does this for *every* header, including set-cookie.\n\n  Based on: https://github.com/google/j2objc/commit/16820fdbc8f76ca0c33472810ce0cb03d20efe25\n  Credits to: https://github.com/tomball for original and https://github.com/chrusart for JavaScript implementation\n*/\nfunction splitCookiesString(cookiesString) {\n  if (Array.isArray(cookiesString)) {\n    return cookiesString;\n  }\n  if (typeof cookiesString !== \"string\") {\n    return [];\n  }\n\n  var cookiesStrings = [];\n  var pos = 0;\n  var start;\n  var ch;\n  var lastComma;\n  var nextStart;\n  var cookiesSeparatorFound;\n\n  function skipWhitespace() {\n    while (pos < cookiesString.length && /\\s/.test(cookiesString.charAt(pos))) {\n      pos += 1;\n    }\n    return pos < cookiesString.length;\n  }\n\n  function notSpecialChar() {\n    ch = cookiesString.charAt(pos);\n\n    return ch !== \"=\" && ch !== \";\" && ch !== \",\";\n  }\n\n  while (pos < cookiesString.length) {\n    start = pos;\n    cookiesSeparatorFound = false;\n\n    while (skipWhitespace()) {\n      ch = cookiesString.charAt(pos);\n      if (ch === \",\") {\n        // ',' is a cookie separator if we have later first '=', not ';' or ','\n        lastComma = pos;\n        pos += 1;\n\n        skipWhitespace();\n        nextStart = pos;\n\n        while (pos < cookiesString.length && notSpecialChar()) {\n          pos += 1;\n        }\n\n        // currently special character\n        if (pos < cookiesString.length && cookiesString.charAt(pos) === \"=\") {\n          // we found cookies separator\n          cookiesSeparatorFound = true;\n          // pos is inside the next cookie, so back up and return it.\n          pos = nextStart;\n          cookiesStrings.push(cookiesString.substring(start, lastComma));\n          start = pos;\n        } else {\n          // in param ',' or param separator ';',\n          // we continue from that comma\n          pos = lastComma + 1;\n        }\n      } else {\n        pos += 1;\n      }\n    }\n\n    if (!cookiesSeparatorFound || pos >= cookiesString.length) {\n      cookiesStrings.push(cookiesString.substring(start, cookiesString.length));\n    }\n  }\n\n  return cookiesStrings;\n}\n\nmodule.exports = parse;\nmodule.exports.parse = parse;\nmodule.exports.parseString = parseString;\nmodule.exports.splitCookiesString = splitCookiesString;\n", "/**\n * @remix-run/server-runtime v2.4.1\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar setCookieParser = require('set-cookie-parser');\n\nfunction getDocumentHeadersRR(build, context) {\n  let boundaryIdx = context.errors ? context.matches.findIndex(m => context.errors[m.route.id]) : -1;\n  let matches = boundaryIdx >= 0 ? context.matches.slice(0, boundaryIdx + 1) : context.matches;\n  let errorHeaders;\n  if (boundaryIdx >= 0) {\n    // Look for any errorHeaders from the boundary route down, which can be\n    // identified by the presence of headers but no data\n    let {\n      actionHeaders,\n      actionData,\n      loaderHeaders,\n      loaderData\n    } = context;\n    context.matches.slice(boundaryIdx).some(match => {\n      let id = match.route.id;\n      if (actionHeaders[id] && (!actionData || actionData[id] === undefined)) {\n        errorHeaders = actionHeaders[id];\n      } else if (loaderHeaders[id] && loaderData[id] === undefined) {\n        errorHeaders = loaderHeaders[id];\n      }\n      return errorHeaders != null;\n    });\n  }\n  return matches.reduce((parentHeaders, match, idx) => {\n    let {\n      id\n    } = match.route;\n    let routeModule = build.routes[id].module;\n    let loaderHeaders = context.loaderHeaders[id] || new Headers();\n    let actionHeaders = context.actionHeaders[id] || new Headers();\n\n    // Only expose errorHeaders to the leaf headers() function to\n    // avoid duplication via parentHeaders\n    let includeErrorHeaders = errorHeaders != undefined && idx === matches.length - 1;\n    // Only prepend cookies from errorHeaders at the leaf renderable route\n    // when it's not the same as loaderHeaders/actionHeaders to avoid\n    // duplicate cookies\n    let includeErrorCookies = includeErrorHeaders && errorHeaders !== loaderHeaders && errorHeaders !== actionHeaders;\n\n    // Use the parent headers for any route without a `headers` export\n    if (routeModule.headers == null) {\n      let headers = new Headers(parentHeaders);\n      if (includeErrorCookies) {\n        prependCookies(errorHeaders, headers);\n      }\n      prependCookies(actionHeaders, headers);\n      prependCookies(loaderHeaders, headers);\n      return headers;\n    }\n    let headers = new Headers(routeModule.headers ? typeof routeModule.headers === \"function\" ? routeModule.headers({\n      loaderHeaders,\n      parentHeaders,\n      actionHeaders,\n      errorHeaders: includeErrorHeaders ? errorHeaders : undefined\n    }) : routeModule.headers : undefined);\n\n    // Automatically preserve Set-Cookie headers from bubbled responses,\n    // loaders, errors, and parent routes\n    if (includeErrorCookies) {\n      prependCookies(errorHeaders, headers);\n    }\n    prependCookies(actionHeaders, headers);\n    prependCookies(loaderHeaders, headers);\n    prependCookies(parentHeaders, headers);\n    return headers;\n  }, new Headers());\n}\nfunction prependCookies(parentHeaders, childHeaders) {\n  let parentSetCookieString = parentHeaders.get(\"Set-Cookie\");\n  if (parentSetCookieString) {\n    let cookies = setCookieParser.splitCookiesString(parentSetCookieString);\n    cookies.forEach(cookie => {\n      childHeaders.append(\"Set-Cookie\", cookie);\n    });\n  }\n}\n\nexports.getDocumentHeadersRR = getDocumentHeadersRR;\n", "/**\n * @remix-run/server-runtime v2.4.1\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nfunction invariant(value, message) {\n  if (value === false || value === null || typeof value === \"undefined\") {\n    console.error(\"The following error is a bug in Remix; please open an issue! https://github.com/remix-run/remix/issues/new\");\n    throw new Error(message);\n  }\n}\n\nexports[\"default\"] = invariant;\n", "/**\n * @remix-run/server-runtime v2.4.1\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar router = require('@remix-run/router');\n\nfunction matchServerRoutes(routes, pathname) {\n  let matches = router.matchRoutes(routes, pathname);\n  if (!matches) return null;\n  return matches.map(match => ({\n    params: match.params,\n    pathname: match.pathname,\n    route: match.route\n  }));\n}\n\nexports.matchServerRoutes = matchServerRoutes;\n", "/**\n * @remix-run/server-runtime v2.4.1\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar responses = require('./responses.js');\n\n/**\n * An object of unknown type for route loaders and actions provided by the\n * server's `getLoadContext()` function.  This is defined as an empty interface\n * specifically so apps can leverage declaration merging to augment this type\n * globally: https://www.typescriptlang.org/docs/handbook/declaration-merging.html\n */\n\n/**\n * Data for a route that was returned from a `loader()`.\n */\n\nasync function callRouteActionRR({\n  loadContext,\n  action,\n  params,\n  request,\n  routeId\n}) {\n  let result = await action({\n    request: stripDataParam(stripIndexParam(request)),\n    context: loadContext,\n    params\n  });\n  if (result === undefined) {\n    throw new Error(`You defined an action for route \"${routeId}\" but didn't return ` + `anything from your \\`action\\` function. Please return a value or \\`null\\`.`);\n  }\n  return responses.isResponse(result) ? result : responses.json(result);\n}\nasync function callRouteLoaderRR({\n  loadContext,\n  loader,\n  params,\n  request,\n  routeId\n}) {\n  let result = await loader({\n    request: stripDataParam(stripIndexParam(request)),\n    context: loadContext,\n    params\n  });\n  if (result === undefined) {\n    throw new Error(`You defined a loader for route \"${routeId}\" but didn't return ` + `anything from your \\`loader\\` function. Please return a value or \\`null\\`.`);\n  }\n  if (responses.isDeferredData(result)) {\n    if (result.init && responses.isRedirectStatusCode(result.init.status || 200)) {\n      return responses.redirect(new Headers(result.init.headers).get(\"Location\"), result.init);\n    }\n    return result;\n  }\n  return responses.isResponse(result) ? result : responses.json(result);\n}\n\n// TODO: Document these search params better\n// and stop stripping these in V2. These break\n// support for running in a SW and also expose\n// valuable info to data funcs that is being asked\n// for such as \"is this a data request?\".\nfunction stripIndexParam(request) {\n  let url = new URL(request.url);\n  let indexValues = url.searchParams.getAll(\"index\");\n  url.searchParams.delete(\"index\");\n  let indexValuesToKeep = [];\n  for (let indexValue of indexValues) {\n    if (indexValue) {\n      indexValuesToKeep.push(indexValue);\n    }\n  }\n  for (let toKeep of indexValuesToKeep) {\n    url.searchParams.append(\"index\", toKeep);\n  }\n  let init = {\n    method: request.method,\n    body: request.body,\n    headers: request.headers,\n    signal: request.signal\n  };\n  if (init.body) {\n    init.duplex = \"half\";\n  }\n  return new Request(url.href, init);\n}\nfunction stripDataParam(request) {\n  let url = new URL(request.url);\n  url.searchParams.delete(\"_data\");\n  let init = {\n    method: request.method,\n    body: request.body,\n    headers: request.headers,\n    signal: request.signal\n  };\n  if (init.body) {\n    init.duplex = \"half\";\n  }\n  return new Request(url.href, init);\n}\n\nexports.callRouteActionRR = callRouteActionRR;\nexports.callRouteLoaderRR = callRouteLoaderRR;\n", "/**\n * @remix-run/server-runtime v2.4.1\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar data = require('./data.js');\n\n// NOTE: make sure to change the Route in remix-react if you change this\n\n// NOTE: make sure to change the EntryRoute in remix-react if you change this\n\nfunction groupRoutesByParentId(manifest) {\n  let routes = {};\n  Object.values(manifest).forEach(route => {\n    let parentId = route.parentId || \"\";\n    if (!routes[parentId]) {\n      routes[parentId] = [];\n    }\n    routes[parentId].push(route);\n  });\n  return routes;\n}\n\n// Create a map of routes by parentId to use recursively instead of\n// repeatedly filtering the manifest.\nfunction createRoutes(manifest, parentId = \"\", routesByParentId = groupRoutesByParentId(manifest)) {\n  return (routesByParentId[parentId] || []).map(route => ({\n    ...route,\n    children: createRoutes(manifest, route.id, routesByParentId)\n  }));\n}\n\n// Convert the Remix ServerManifest into DataRouteObject's for use with\n// createStaticHandler\nfunction createStaticHandlerDataRoutes(manifest, future, parentId = \"\", routesByParentId = groupRoutesByParentId(manifest)) {\n  return (routesByParentId[parentId] || []).map(route => {\n    let commonRoute = {\n      // Always include root due to default boundaries\n      hasErrorBoundary: route.id === \"root\" || route.module.ErrorBoundary != null,\n      id: route.id,\n      path: route.path,\n      loader: route.module.loader ?\n      // Need to use RR's version here to permit the optional context even\n      // though we know it'll always be provided in remix\n      args => data.callRouteLoaderRR({\n        request: args.request,\n        params: args.params,\n        loadContext: args.context,\n        loader: route.module.loader,\n        routeId: route.id\n      }) : undefined,\n      action: route.module.action ? args => data.callRouteActionRR({\n        request: args.request,\n        params: args.params,\n        loadContext: args.context,\n        action: route.module.action,\n        routeId: route.id\n      }) : undefined,\n      handle: route.module.handle\n    };\n    return route.index ? {\n      index: true,\n      ...commonRoute\n    } : {\n      caseSensitive: route.caseSensitive,\n      children: createStaticHandlerDataRoutes(manifest, future, route.id, routesByParentId),\n      ...commonRoute\n    };\n  });\n}\n\nexports.createRoutes = createRoutes;\nexports.createStaticHandlerDataRoutes = createStaticHandlerDataRoutes;\n", "/**\n * @remix-run/server-runtime v2.4.1\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n// This escapeHtml utility is based on https://github.com/zertosh/htmlescape\n// License: https://github.com/zertosh/htmlescape/blob/0527ca7156a524d256101bb310a9f970f63078ad/LICENSE\n\n// We've chosen to inline the utility here to reduce the number of npm dependencies we have,\n// slightly decrease the code size compared the original package and make it esm compatible.\n\nconst ESCAPE_LOOKUP = {\n  \"&\": \"\\\\u0026\",\n  \">\": \"\\\\u003e\",\n  \"<\": \"\\\\u003c\",\n  \"\\u2028\": \"\\\\u2028\",\n  \"\\u2029\": \"\\\\u2029\"\n};\nconst ESCAPE_REGEX = /[&><\\u2028\\u2029]/g;\nfunction escapeHtml(html) {\n  return html.replace(ESCAPE_REGEX, match => ESCAPE_LOOKUP[match]);\n}\n\nexports.escapeHtml = escapeHtml;\n", "/**\n * @remix-run/server-runtime v2.4.1\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar markup = require('./markup.js');\n\n// TODO: Remove Promises from serialization\nfunction createServerHandoffString(serverHandoff) {\n  // Uses faster alternative of jsesc to escape data returned from the loaders.\n  // This string is inserted directly into the HTML in the `<Scripts>` element.\n  return markup.escapeHtml(JSON.stringify(serverHandoff));\n}\n\nexports.createServerHandoffString = createServerHandoffString;\n", "/**\n * @remix-run/server-runtime v2.4.1\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nasync function broadcastDevReady(build, origin) {\n  origin ??= process.env.REMIX_DEV_ORIGIN;\n  if (!origin) throw Error(\"Dev server origin not set\");\n  let url = new URL(origin);\n  url.pathname = \"ping\";\n  let response = await fetch(url.href, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\"\n    },\n    body: JSON.stringify({\n      buildHash: build.assets.version\n    })\n  }).catch(error => {\n    console.error(`Could not reach Remix dev server at ${url}`);\n    throw error;\n  });\n  if (!response.ok) {\n    console.error(`Could not reach Remix dev server at ${url} (${response.status})`);\n    throw Error(await response.text());\n  }\n}\nfunction logDevReady(build) {\n  console.log(`[REMIX DEV] ${build.assets.version} ready`);\n}\nconst globalDevServerHooksKey = \"__remix_devServerHooks\";\nfunction setDevServerHooks(devServerHooks) {\n  // @ts-expect-error\n  globalThis[globalDevServerHooksKey] = devServerHooks;\n}\nfunction getDevServerHooks() {\n  // @ts-expect-error\n  return globalThis[globalDevServerHooksKey];\n}\n\nexports.broadcastDevReady = broadcastDevReady;\nexports.getDevServerHooks = getDevServerHooks;\nexports.logDevReady = logDevReady;\nexports.setDevServerHooks = setDevServerHooks;\n", "/**\n * @remix-run/server-runtime v2.4.1\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar router = require('@remix-run/router');\nvar entry = require('./entry.js');\nvar errors = require('./errors.js');\nvar headers = require('./headers.js');\nvar invariant = require('./invariant.js');\nvar mode = require('./mode.js');\nvar routeMatching = require('./routeMatching.js');\nvar routes = require('./routes.js');\nvar responses = require('./responses.js');\nvar serverHandoff = require('./serverHandoff.js');\nvar dev = require('./dev.js');\n\nfunction derive(build, mode$1) {\n  var _build$future;\n  let routes$1 = routes.createRoutes(build.routes);\n  let dataRoutes = routes.createStaticHandlerDataRoutes(build.routes, build.future);\n  let serverMode = mode.isServerMode(mode$1) ? mode$1 : mode.ServerMode.Production;\n  let staticHandler = router.createStaticHandler(dataRoutes, {\n    future: {\n      v7_relativeSplatPath: (_build$future = build.future) === null || _build$future === void 0 ? void 0 : _build$future.v3_relativeSplatPath\n    }\n  });\n  let errorHandler = build.entry.module.handleError || ((error, {\n    request\n  }) => {\n    if (serverMode !== mode.ServerMode.Test && !request.signal.aborted) {\n      console.error(\n      // @ts-expect-error This is \"private\" from users but intended for internal use\n      router.isRouteErrorResponse(error) && error.error ? error.error : error);\n    }\n  });\n  return {\n    routes: routes$1,\n    dataRoutes,\n    serverMode,\n    staticHandler,\n    errorHandler\n  };\n}\nconst createRequestHandler = (build, mode$1) => {\n  let _build;\n  let routes;\n  let serverMode;\n  let staticHandler;\n  let errorHandler;\n  return async function requestHandler(request, loadContext = {}) {\n    _build = typeof build === \"function\" ? await build() : build;\n    if (typeof build === \"function\") {\n      let derived = derive(_build, mode$1);\n      routes = derived.routes;\n      serverMode = derived.serverMode;\n      staticHandler = derived.staticHandler;\n      errorHandler = derived.errorHandler;\n    } else if (!routes || !serverMode || !staticHandler || !errorHandler) {\n      let derived = derive(_build, mode$1);\n      routes = derived.routes;\n      serverMode = derived.serverMode;\n      staticHandler = derived.staticHandler;\n      errorHandler = derived.errorHandler;\n    }\n    let url = new URL(request.url);\n    let matches = routeMatching.matchServerRoutes(routes, url.pathname);\n    let handleError = error => {\n      if (mode$1 === mode.ServerMode.Development) {\n        var _getDevServerHooks, _getDevServerHooks$pr;\n        (_getDevServerHooks = dev.getDevServerHooks()) === null || _getDevServerHooks === void 0 ? void 0 : (_getDevServerHooks$pr = _getDevServerHooks.processRequestError) === null || _getDevServerHooks$pr === void 0 ? void 0 : _getDevServerHooks$pr.call(_getDevServerHooks, error);\n      }\n      errorHandler(error, {\n        context: loadContext,\n        params: matches && matches.length > 0 ? matches[0].params : {},\n        request\n      });\n    };\n    let response;\n    if (url.searchParams.has(\"_data\")) {\n      let routeId = url.searchParams.get(\"_data\");\n      response = await handleDataRequestRR(serverMode, staticHandler, routeId, request, loadContext, handleError);\n      if (_build.entry.module.handleDataRequest) {\n        var _matches$find;\n        response = await _build.entry.module.handleDataRequest(response, {\n          context: loadContext,\n          params: (matches === null || matches === void 0 ? void 0 : (_matches$find = matches.find(m => m.route.id == routeId)) === null || _matches$find === void 0 ? void 0 : _matches$find.params) || {},\n          request\n        });\n      }\n    } else if (matches && matches[matches.length - 1].route.module.default == null && matches[matches.length - 1].route.module.ErrorBoundary == null) {\n      response = await handleResourceRequestRR(serverMode, staticHandler, matches.slice(-1)[0].route.id, request, loadContext, handleError);\n    } else {\n      var _getDevServerHooks2, _getDevServerHooks2$g;\n      let criticalCss = mode$1 === mode.ServerMode.Development ? await ((_getDevServerHooks2 = dev.getDevServerHooks()) === null || _getDevServerHooks2 === void 0 ? void 0 : (_getDevServerHooks2$g = _getDevServerHooks2.getCriticalCss) === null || _getDevServerHooks2$g === void 0 ? void 0 : _getDevServerHooks2$g.call(_getDevServerHooks2, _build, url.pathname)) : undefined;\n      response = await handleDocumentRequestRR(serverMode, _build, staticHandler, request, loadContext, handleError, criticalCss);\n    }\n    if (request.method === \"HEAD\") {\n      return new Response(null, {\n        headers: response.headers,\n        status: response.status,\n        statusText: response.statusText\n      });\n    }\n    return response;\n  };\n};\nasync function handleDataRequestRR(serverMode, staticHandler, routeId, request, loadContext, handleError) {\n  try {\n    let response = await staticHandler.queryRoute(request, {\n      routeId,\n      requestContext: loadContext\n    });\n    if (responses.isRedirectResponse(response)) {\n      // We don't have any way to prevent a fetch request from following\n      // redirects. So we use the `X-Remix-Redirect` header to indicate the\n      // next URL, and then \"follow\" the redirect manually on the client.\n      let headers = new Headers(response.headers);\n      headers.set(\"X-Remix-Redirect\", headers.get(\"Location\"));\n      headers.set(\"X-Remix-Status\", response.status);\n      headers.delete(\"Location\");\n      if (response.headers.get(\"Set-Cookie\") !== null) {\n        headers.set(\"X-Remix-Revalidate\", \"yes\");\n      }\n      return new Response(null, {\n        status: 204,\n        headers\n      });\n    }\n    if (router.UNSAFE_DEFERRED_SYMBOL in response) {\n      let deferredData = response[router.UNSAFE_DEFERRED_SYMBOL];\n      let body = responses.createDeferredReadableStream(deferredData, request.signal, serverMode);\n      let init = deferredData.init || {};\n      let headers = new Headers(init.headers);\n      headers.set(\"Content-Type\", \"text/remix-deferred\");\n      // Mark successful responses with a header so we can identify in-flight\n      // network errors that are missing this header\n      headers.set(\"X-Remix-Response\", \"yes\");\n      init.headers = headers;\n      return new Response(body, init);\n    }\n\n    // Mark all successful responses with a header so we can identify in-flight\n    // network errors that are missing this header\n    response.headers.set(\"X-Remix-Response\", \"yes\");\n    return response;\n  } catch (error) {\n    if (responses.isResponse(error)) {\n      error.headers.set(\"X-Remix-Catch\", \"yes\");\n      return error;\n    }\n    if (router.isRouteErrorResponse(error)) {\n      if (error) {\n        handleError(error);\n      }\n      return errorResponseToJson(error, serverMode);\n    }\n    let errorInstance = error instanceof Error ? error : new Error(\"Unexpected Server Error\");\n    handleError(errorInstance);\n    return router.json(errors.serializeError(errorInstance, serverMode), {\n      status: 500,\n      headers: {\n        \"X-Remix-Error\": \"yes\"\n      }\n    });\n  }\n}\nasync function handleDocumentRequestRR(serverMode, build, staticHandler, request, loadContext, handleError, criticalCss) {\n  let context;\n  try {\n    context = await staticHandler.query(request, {\n      requestContext: loadContext\n    });\n  } catch (error) {\n    handleError(error);\n    return new Response(null, {\n      status: 500\n    });\n  }\n  if (responses.isResponse(context)) {\n    return context;\n  }\n\n  // Sanitize errors outside of development environments\n  if (context.errors) {\n    Object.values(context.errors).forEach(err => {\n      // @ts-expect-error This is \"private\" from users but intended for internal use\n      if (!router.isRouteErrorResponse(err) || err.error) {\n        handleError(err);\n      }\n    });\n    context.errors = errors.sanitizeErrors(context.errors, serverMode);\n  }\n  let headers$1 = headers.getDocumentHeadersRR(build, context);\n  let entryContext = {\n    manifest: build.assets,\n    routeModules: entry.createEntryRouteModules(build.routes),\n    staticHandlerContext: context,\n    criticalCss,\n    serverHandoffString: serverHandoff.createServerHandoffString({\n      url: context.location.pathname,\n      criticalCss,\n      state: {\n        loaderData: context.loaderData,\n        actionData: context.actionData,\n        errors: errors.serializeErrors(context.errors, serverMode)\n      },\n      future: build.future\n    }),\n    future: build.future,\n    serializeError: err => errors.serializeError(err, serverMode)\n  };\n  let handleDocumentRequestFunction = build.entry.module.default;\n  try {\n    return await handleDocumentRequestFunction(request, context.statusCode, headers$1, entryContext, loadContext);\n  } catch (error) {\n    handleError(error);\n\n    // Get a new StaticHandlerContext that contains the error at the right boundary\n    context = router.getStaticContextFromError(staticHandler.dataRoutes, context, error);\n\n    // Sanitize errors outside of development environments\n    if (context.errors) {\n      context.errors = errors.sanitizeErrors(context.errors, serverMode);\n    }\n\n    // Update entryContext for the second render pass\n    entryContext = {\n      ...entryContext,\n      staticHandlerContext: context,\n      serverHandoffString: serverHandoff.createServerHandoffString({\n        url: context.location.pathname,\n        state: {\n          loaderData: context.loaderData,\n          actionData: context.actionData,\n          errors: errors.serializeErrors(context.errors, serverMode)\n        },\n        future: build.future\n      })\n    };\n    try {\n      return await handleDocumentRequestFunction(request, context.statusCode, headers$1, entryContext, loadContext);\n    } catch (error) {\n      handleError(error);\n      return returnLastResortErrorResponse(error, serverMode);\n    }\n  }\n}\nasync function handleResourceRequestRR(serverMode, staticHandler, routeId, request, loadContext, handleError) {\n  try {\n    // Note we keep the routeId here to align with the Remix handling of\n    // resource routes which doesn't take ?index into account and just takes\n    // the leaf match\n    let response = await staticHandler.queryRoute(request, {\n      routeId,\n      requestContext: loadContext\n    });\n    // callRouteLoader/callRouteAction always return responses\n    invariant[\"default\"](responses.isResponse(response), \"Expected a Response to be returned from queryRoute\");\n    return response;\n  } catch (error) {\n    if (responses.isResponse(error)) {\n      // Note: Not functionally required but ensures that our response headers\n      // match identically to what Remix returns\n      error.headers.set(\"X-Remix-Catch\", \"yes\");\n      return error;\n    }\n    if (router.isRouteErrorResponse(error)) {\n      if (error) {\n        handleError(error);\n      }\n      return errorResponseToJson(error, serverMode);\n    }\n    handleError(error);\n    return returnLastResortErrorResponse(error, serverMode);\n  }\n}\nfunction errorResponseToJson(errorResponse, serverMode) {\n  return router.json(errors.serializeError(\n  // @ts-expect-error This is \"private\" from users but intended for internal use\n  errorResponse.error || new Error(\"Unexpected Server Error\"), serverMode), {\n    status: errorResponse.status,\n    statusText: errorResponse.statusText,\n    headers: {\n      \"X-Remix-Error\": \"yes\"\n    }\n  });\n}\nfunction returnLastResortErrorResponse(error, serverMode) {\n  let message = \"Unexpected Server Error\";\n  if (serverMode !== mode.ServerMode.Production) {\n    message += `\\n\\n${String(error)}`;\n  }\n\n  // Good grief folks, get your act together \uD83D\uDE02!\n  return new Response(message, {\n    status: 500,\n    headers: {\n      \"Content-Type\": \"text/plain\"\n    }\n  });\n}\n\nexports.createRequestHandler = createRequestHandler;\n", "/**\n * @remix-run/server-runtime v2.4.1\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar cookies = require('./cookies.js');\nvar warnings = require('./warnings.js');\n\n/**\n * An object of name/value pairs to be used in the session.\n */\n\n/**\n * Session persists data across HTTP requests.\n *\n * @see https://remix.run/utils/sessions#session-api\n */\n\nfunction flash(name) {\n  return `__flash_${name}__`;\n}\n/**\n * Creates a new Session object.\n *\n * Note: This function is typically not invoked directly by application code.\n * Instead, use a `SessionStorage` object's `getSession` method.\n *\n * @see https://remix.run/utils/sessions#createsession\n */\nconst createSession = (initialData = {}, id = \"\") => {\n  let map = new Map(Object.entries(initialData));\n  return {\n    get id() {\n      return id;\n    },\n    get data() {\n      return Object.fromEntries(map);\n    },\n    has(name) {\n      return map.has(name) || map.has(flash(name));\n    },\n    get(name) {\n      if (map.has(name)) return map.get(name);\n      let flashName = flash(name);\n      if (map.has(flashName)) {\n        let value = map.get(flashName);\n        map.delete(flashName);\n        return value;\n      }\n      return undefined;\n    },\n    set(name, value) {\n      map.set(name, value);\n    },\n    flash(name, value) {\n      map.set(flash(name), value);\n    },\n    unset(name) {\n      map.delete(name);\n    }\n  };\n};\n/**\n * Returns true if an object is a Remix session.\n *\n * @see https://remix.run/utils/sessions#issession\n */\nconst isSession = object => {\n  return object != null && typeof object.id === \"string\" && typeof object.data !== \"undefined\" && typeof object.has === \"function\" && typeof object.get === \"function\" && typeof object.set === \"function\" && typeof object.flash === \"function\" && typeof object.unset === \"function\";\n};\n\n/**\n * SessionStorage stores session data between HTTP requests and knows how to\n * parse and create cookies.\n *\n * A SessionStorage creates Session objects using a `Cookie` header as input.\n * Then, later it generates the `Set-Cookie` header to be used in the response.\n */\n\n/**\n * SessionIdStorageStrategy is designed to allow anyone to easily build their\n * own SessionStorage using `createSessionStorage(strategy)`.\n *\n * This strategy describes a common scenario where the session id is stored in\n * a cookie but the actual session data is stored elsewhere, usually in a\n * database or on disk. A set of create, read, update, and delete operations\n * are provided for managing the session data.\n */\n\n/**\n * Creates a SessionStorage object using a SessionIdStorageStrategy.\n *\n * Note: This is a low-level API that should only be used if none of the\n * existing session storage options meet your requirements.\n *\n * @see https://remix.run/utils/sessions#createsessionstorage\n */\nconst createSessionStorageFactory = createCookie => ({\n  cookie: cookieArg,\n  createData,\n  readData,\n  updateData,\n  deleteData\n}) => {\n  let cookie = cookies.isCookie(cookieArg) ? cookieArg : createCookie((cookieArg === null || cookieArg === void 0 ? void 0 : cookieArg.name) || \"__session\", cookieArg);\n  warnOnceAboutSigningSessionCookie(cookie);\n  return {\n    async getSession(cookieHeader, options) {\n      let id = cookieHeader && (await cookie.parse(cookieHeader, options));\n      let data = id && (await readData(id));\n      return createSession(data || {}, id || \"\");\n    },\n    async commitSession(session, options) {\n      let {\n        id,\n        data\n      } = session;\n      let expires = (options === null || options === void 0 ? void 0 : options.maxAge) != null ? new Date(Date.now() + options.maxAge * 1000) : (options === null || options === void 0 ? void 0 : options.expires) != null ? options.expires : cookie.expires;\n      if (id) {\n        await updateData(id, data, expires);\n      } else {\n        id = await createData(data, expires);\n      }\n      return cookie.serialize(id, options);\n    },\n    async destroySession(session, options) {\n      await deleteData(session.id);\n      return cookie.serialize(\"\", {\n        ...options,\n        maxAge: undefined,\n        expires: new Date(0)\n      });\n    }\n  };\n};\nfunction warnOnceAboutSigningSessionCookie(cookie) {\n  warnings.warnOnce(cookie.isSigned, `The \"${cookie.name}\" cookie is not signed, but session cookies should be ` + `signed to prevent tampering on the client before they are sent back to the ` + `server. See https://remix.run/utils/cookies#signing-cookies ` + `for more information.`);\n}\n\nexports.createSession = createSession;\nexports.createSessionStorageFactory = createSessionStorageFactory;\nexports.isSession = isSession;\nexports.warnOnceAboutSigningSessionCookie = warnOnceAboutSigningSessionCookie;\n", "/**\n * @remix-run/server-runtime v2.4.1\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar cookies = require('../cookies.js');\nvar sessions = require('../sessions.js');\n\n/**\n * Creates and returns a SessionStorage object that stores all session data\n * directly in the session cookie itself.\n *\n * This has the advantage that no database or other backend services are\n * needed, and can help to simplify some load-balanced scenarios. However, it\n * also has the limitation that serialized session data may not exceed the\n * browser's maximum cookie size. Trade-offs!\n *\n * @see https://remix.run/utils/sessions#createcookiesessionstorage\n */\nconst createCookieSessionStorageFactory = createCookie => ({\n  cookie: cookieArg\n} = {}) => {\n  let cookie = cookies.isCookie(cookieArg) ? cookieArg : createCookie((cookieArg === null || cookieArg === void 0 ? void 0 : cookieArg.name) || \"__session\", cookieArg);\n  sessions.warnOnceAboutSigningSessionCookie(cookie);\n  return {\n    async getSession(cookieHeader, options) {\n      return sessions.createSession(cookieHeader && (await cookie.parse(cookieHeader, options)) || {});\n    },\n    async commitSession(session, options) {\n      let serializedCookie = await cookie.serialize(session.data, options);\n      if (serializedCookie.length > 4096) {\n        throw new Error(\"Cookie length will exceed browser maximum. Length: \" + serializedCookie.length);\n      }\n      return serializedCookie;\n    },\n    async destroySession(_session, options) {\n      return cookie.serialize(\"\", {\n        ...options,\n        maxAge: undefined,\n        expires: new Date(0)\n      });\n    }\n  };\n};\n\nexports.createCookieSessionStorageFactory = createCookieSessionStorageFactory;\n", "/**\n * @remix-run/server-runtime v2.4.1\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n/**\n * Creates and returns a simple in-memory SessionStorage object, mostly useful\n * for testing and as a reference implementation.\n *\n * Note: This storage does not scale beyond a single process, so it is not\n * suitable for most production scenarios.\n *\n * @see https://remix.run/utils/sessions#creatememorysessionstorage\n */\nconst createMemorySessionStorageFactory = createSessionStorage => ({\n  cookie\n} = {}) => {\n  let map = new Map();\n  return createSessionStorage({\n    cookie,\n    async createData(data, expires) {\n      let id = Math.random().toString(36).substring(2, 10);\n      map.set(id, {\n        data,\n        expires\n      });\n      return id;\n    },\n    async readData(id) {\n      if (map.has(id)) {\n        let {\n          data,\n          expires\n        } = map.get(id);\n        if (!expires || expires > new Date()) {\n          return data;\n        }\n\n        // Remove expired session data.\n        if (expires) map.delete(id);\n      }\n      return null;\n    },\n    async updateData(id, data, expires) {\n      map.set(id, {\n        data,\n        expires\n      });\n    },\n    async deleteData(id) {\n      map.delete(id);\n    }\n  });\n};\n\nexports.createMemorySessionStorageFactory = createMemorySessionStorageFactory;\n", "/**\n * @remix-run/server-runtime v2.4.1\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nclass MaxPartSizeExceededError extends Error {\n  constructor(field, maxBytes) {\n    super(`Field \"${field}\" exceeded upload size of ${maxBytes} bytes.`);\n    this.field = field;\n    this.maxBytes = maxBytes;\n  }\n}\n\nexports.MaxPartSizeExceededError = MaxPartSizeExceededError;\n", "/**\n * @remix-run/server-runtime v2.4.1\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar errors = require('./errors.js');\n\nfunction createMemoryUploadHandler({\n  filter,\n  maxPartSize = 3000000\n} = {}) {\n  return async ({\n    filename,\n    contentType,\n    name,\n    data\n  }) => {\n    if (filter && !(await filter({\n      filename,\n      contentType,\n      name\n    }))) {\n      return undefined;\n    }\n    let size = 0;\n    let chunks = [];\n    for await (let chunk of data) {\n      size += chunk.byteLength;\n      if (size > maxPartSize) {\n        throw new errors.MaxPartSizeExceededError(name, maxPartSize);\n      }\n      chunks.push(chunk);\n    }\n    if (typeof filename === \"string\") {\n      return new File(chunks, filename, {\n        type: contentType\n      });\n    }\n    return await new Blob(chunks, {\n      type: contentType\n    }).text();\n  };\n}\n\nexports.createMemoryUploadHandler = createMemoryUploadHandler;\n", "/**\n * @remix-run/server-runtime v2.4.1\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar cookies = require('./cookies.js');\nvar formData = require('./formData.js');\nvar responses = require('./responses.js');\nvar server = require('./server.js');\nvar sessions = require('./sessions.js');\nvar cookieStorage = require('./sessions/cookieStorage.js');\nvar memoryStorage = require('./sessions/memoryStorage.js');\nvar memoryUploadHandler = require('./upload/memoryUploadHandler.js');\nvar errors = require('./upload/errors.js');\nvar dev = require('./dev.js');\n\n\n\nexports.createCookieFactory = cookies.createCookieFactory;\nexports.isCookie = cookies.isCookie;\nexports.unstable_composeUploadHandlers = formData.composeUploadHandlers;\nexports.unstable_parseMultipartFormData = formData.parseMultipartFormData;\nexports.defer = responses.defer;\nexports.json = responses.json;\nexports.redirect = responses.redirect;\nexports.redirectDocument = responses.redirectDocument;\nexports.createRequestHandler = server.createRequestHandler;\nexports.createSession = sessions.createSession;\nexports.createSessionStorageFactory = sessions.createSessionStorageFactory;\nexports.isSession = sessions.isSession;\nexports.createCookieSessionStorageFactory = cookieStorage.createCookieSessionStorageFactory;\nexports.createMemorySessionStorageFactory = memoryStorage.createMemorySessionStorageFactory;\nexports.unstable_createMemoryUploadHandler = memoryUploadHandler.createMemoryUploadHandler;\nexports.MaxPartSizeExceededError = errors.MaxPartSizeExceededError;\nexports.broadcastDevReady = dev.broadcastDevReady;\nexports.logDevReady = dev.logDevReady;\nexports.unstable_setDevServerHooks = dev.setDevServerHooks;\n", "/**\n * @remix-run/cloudflare v2.4.1\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst encoder = new TextEncoder();\nconst sign = async (value, secret) => {\n  let key = await createKey(secret, [\"sign\"]);\n  let data = encoder.encode(value);\n  let signature = await crypto.subtle.sign(\"HMAC\", key, data);\n  let hash = btoa(String.fromCharCode(...new Uint8Array(signature))).replace(/=+$/, \"\");\n  return value + \".\" + hash;\n};\nconst unsign = async (signed, secret) => {\n  let index = signed.lastIndexOf(\".\");\n  let value = signed.slice(0, index);\n  let hash = signed.slice(index + 1);\n  let key = await createKey(secret, [\"verify\"]);\n  let data = encoder.encode(value);\n  let signature = byteStringToUint8Array(atob(hash));\n  let valid = await crypto.subtle.verify(\"HMAC\", key, signature, data);\n  return valid ? value : false;\n};\nasync function createKey(secret, usages) {\n  let key = await crypto.subtle.importKey(\"raw\", encoder.encode(secret), {\n    name: \"HMAC\",\n    hash: \"SHA-256\"\n  }, false, usages);\n  return key;\n}\nfunction byteStringToUint8Array(byteString) {\n  let array = new Uint8Array(byteString.length);\n  for (let i = 0; i < byteString.length; i++) {\n    array[i] = byteString.charCodeAt(i);\n  }\n  return array;\n}\n\nexports.sign = sign;\nexports.unsign = unsign;\n", "/**\n * @remix-run/cloudflare v2.4.1\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar serverRuntime = require('@remix-run/server-runtime');\nvar crypto = require('./crypto.js');\n\nconst createCookie = serverRuntime.createCookieFactory({\n  sign: crypto.sign,\n  unsign: crypto.unsign\n});\nconst createCookieSessionStorage = serverRuntime.createCookieSessionStorageFactory(createCookie);\nconst createSessionStorage = serverRuntime.createSessionStorageFactory(createCookie);\nconst createMemorySessionStorage = serverRuntime.createMemorySessionStorageFactory(createSessionStorage);\n\nexports.createCookie = createCookie;\nexports.createCookieSessionStorage = createCookieSessionStorage;\nexports.createMemorySessionStorage = createMemorySessionStorage;\nexports.createSessionStorage = createSessionStorage;\n", "/**\n * @remix-run/cloudflare v2.4.1\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar implementations = require('../implementations.js');\n\n/**\n * Creates a SessionStorage that stores session data in the Clouldflare KV Store.\n *\n * The advantage of using this instead of cookie session storage is that\n * KV Store may contain much more data than cookies.\n */\nfunction createWorkersKVSessionStorage({\n  cookie,\n  kv\n}) {\n  return implementations.createSessionStorage({\n    cookie,\n    async createData(data, expires) {\n      while (true) {\n        let randomBytes = new Uint8Array(8);\n        crypto.getRandomValues(randomBytes);\n        // This storage manages an id space of 2^64 ids, which is far greater\n        // than the maximum number of files allowed on an NTFS or ext4 volume\n        // (2^32). However, the larger id space should help to avoid collisions\n        // with existing ids when creating new sessions, which speeds things up.\n        let id = [...randomBytes].map(x => x.toString(16).padStart(2, \"0\")).join(\"\");\n        if (await kv.get(id, \"json\")) {\n          continue;\n        }\n        await kv.put(id, JSON.stringify(data), {\n          expiration: expires ? Math.round(expires.getTime() / 1000) : undefined\n        });\n        return id;\n      }\n    },\n    async readData(id) {\n      let session = await kv.get(id);\n      if (!session) {\n        return null;\n      }\n      return JSON.parse(session);\n    },\n    async updateData(id, data, expires) {\n      await kv.put(id, JSON.stringify(data), {\n        expiration: expires ? Math.round(expires.getTime() / 1000) : undefined\n      });\n    },\n    async deleteData(id) {\n      await kv.delete(id);\n    }\n  });\n}\n\nexports.createWorkersKVSessionStorage = createWorkersKVSessionStorage;\n", "/**\n * @remix-run/cloudflare v2.4.1\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar workersKVStorage = require('./sessions/workersKVStorage.js');\nvar implementations = require('./implementations.js');\nvar serverRuntime = require('@remix-run/server-runtime');\n\n\n\nexports.createWorkersKVSessionStorage = workersKVStorage.createWorkersKVSessionStorage;\nexports.createCookie = implementations.createCookie;\nexports.createCookieSessionStorage = implementations.createCookieSessionStorage;\nexports.createMemorySessionStorage = implementations.createMemorySessionStorage;\nexports.createSessionStorage = implementations.createSessionStorage;\nObject.defineProperty(exports, 'MaxPartSizeExceededError', {\n  enumerable: true,\n  get: function () { return serverRuntime.MaxPartSizeExceededError; }\n});\nObject.defineProperty(exports, 'broadcastDevReady', {\n  enumerable: true,\n  get: function () { return serverRuntime.broadcastDevReady; }\n});\nObject.defineProperty(exports, 'createRequestHandler', {\n  enumerable: true,\n  get: function () { return serverRuntime.createRequestHandler; }\n});\nObject.defineProperty(exports, 'createSession', {\n  enumerable: true,\n  get: function () { return serverRuntime.createSession; }\n});\nObject.defineProperty(exports, 'defer', {\n  enumerable: true,\n  get: function () { return serverRuntime.defer; }\n});\nObject.defineProperty(exports, 'isCookie', {\n  enumerable: true,\n  get: function () { return serverRuntime.isCookie; }\n});\nObject.defineProperty(exports, 'isSession', {\n  enumerable: true,\n  get: function () { return serverRuntime.isSession; }\n});\nObject.defineProperty(exports, 'json', {\n  enumerable: true,\n  get: function () { return serverRuntime.json; }\n});\nObject.defineProperty(exports, 'logDevReady', {\n  enumerable: true,\n  get: function () { return serverRuntime.logDevReady; }\n});\nObject.defineProperty(exports, 'redirect', {\n  enumerable: true,\n  get: function () { return serverRuntime.redirect; }\n});\nObject.defineProperty(exports, 'redirectDocument', {\n  enumerable: true,\n  get: function () { return serverRuntime.redirectDocument; }\n});\nObject.defineProperty(exports, 'unstable_composeUploadHandlers', {\n  enumerable: true,\n  get: function () { return serverRuntime.unstable_composeUploadHandlers; }\n});\nObject.defineProperty(exports, 'unstable_createMemoryUploadHandler', {\n  enumerable: true,\n  get: function () { return serverRuntime.unstable_createMemoryUploadHandler; }\n});\nObject.defineProperty(exports, 'unstable_parseMultipartFormData', {\n  enumerable: true,\n  get: function () { return serverRuntime.unstable_parseMultipartFormData; }\n});\n", "// Assuming EnvWithKV is an interface that includes your KV bindings and any other environment variables.\nimport { createWorkersKVSessionStorage, createCookie } from \"@remix-run/cloudflare\";\nimport { EnvWithKV } from \"api/schemas/kv\";\n\ntype SessionData = {\n  // Define the structure of your session data\n  pages?: string[];\n};\n\ntype SessionFlashData = {\n  error: string;\n};\n\n// You don't need to manually fetch the session secret from the environment variables;\n// Cloudflare automatically makes them available via the `env` parameter in your functions.\n// This function now simply ensures types are respected.\nfunction getSessionSecret(env: any) {\n\n  console.log (env, \"env\")  \n  \n  return env || \"default-secret\"; // Fallback is not recommended for production\n}\n\nexport function createSessionStorage(context: any) {\n\n  // Create a cookie to store session data\n  const sessionCookie = createCookie(\"__session\", {\n    httpOnly: true,\n    maxAge: 60 * 60 * 24 * 30, // 30 days\n    path: \"/\",\n    sameSite: \"lax\",\n    secrets: [getSessionSecret(context.USER_SESSION_SECRET)], // Securely using the session secret from environment variables\n    secure: true,\n  });\n\n  const { getSession, commitSession, destroySession } = createWorkersKVSessionStorage<SessionData, SessionFlashData>({\n    kv: context.theform, // Using the KV namespace from the environment\n    cookie: sessionCookie,\n  });\n\n  return { getSession, commitSession, destroySession };\n}\n", "import { createSessionStorage } from \"./session/session\";\n\nexport async function checkAuthentication(request: any, context: any) {\n  const authCookie = createSessionStorage(context.env).getSession(\n    context.request.headers.get(\"Cookie\")\n  );\n  console.log(authCookie, \"authCookie\");\n  if (authCookie) {\n    try {\n      const parsedCookieData = authCookie;\n      return parsedCookieData;\n    } catch (error) {\n      console.error(\"Error parsing cookie data:\", error);\n    }\n  }\n  return false;\n}\n", "import { checkAuthentication } from \"~/utils/checkAuthentication\";\n\n// In root.ts (Cloudflare Worker)\nexport async function onRequest(context: any) {\n  const { request, env, next } = context;\n  const url = new URL(request.url);\n\n  if (url.pathname === '/login') {\n    return next(request);\n  }\n\n  const isAuthenticated = await checkAuthentication(request, env); // Use the same function as in root loader\n\n  if (isAuthenticated) {\n    return next(request);\n  } else {\n    return Response.redirect(new URL('/login', request.url).toString());\n  }\n}\n", "import type { PluginData } from \"@cloudflare/pages-plugin-cloudflare-access\";\nimport { getIdentity } from \"@cloudflare/pages-plugin-cloudflare-access/api\";\n\n\ninterface Env {\n    theform: KVNamespace;\n  }\n\n  export const onRequest: PagesFunction<Env> = async (context) => {\n\n    let test = '<html><head><title>Test</title></head><body><h1>Test</h1></body></html>';\n\n    await context.env.theform.put(\"html\", test);\n\n    const task = await context.env.theform.get(\"html\");\n\n    return new Response(task);\n  }\n// export const onRequest: PagesFunction<PluginData> = async ({\n//   data, context\n// }) => {\n\n//     const task = await context.env.TODO_LIST.get(\"Task:123\");\n\n\n//   const identity = await getIdentity({\n//     jwt: \"eyJhbGciOiJIUzI1NiIsImtpZCI6IjkzMzhhYmUxYmFmMmZlNDkyZjY0NmE3MzZmMjVhZmJmN2IwMjVlMzVjNjI3YmU0ZjYwYzQxNGQ0YzczMDY5YjgiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOlsiOTdlMmFhZTEyMDEyMWY5MDJkZjhiYzk5ZmMzNDU5MTNhYjE4NmQxNzRmMzA3OWVhNzI5MjM2NzY2YjJlN2M0YSJdLCJlbWFpbCI6ImFkbWluQGV4YW1wbGUuY29tIiwiZXhwIjoxNTE5NDE4MjE0LCJpYXQiOjE1MTkzMzE4MTUsImlzcyI6Imh0dHBzOi8vdGVzdC5jbG91ZGZsYXJlYWNjZXNzLmNvbSIsIm5vbmNlIjoiMWQ4MDgzZjcwOGE0Nzk4MjI5NmYyZDk4OTZkNzBmMjA3YTI3OTM4ZjAyNjU0MGMzOTJiOTAzZTVmZGY0ZDZlOSIsInN1YiI6ImNhNjM5YmI5LTI2YWItNDJlNS1iOWJmLTNhZWEyN2IzMzFmZCJ9.05vGt-_0Mw6WEFJF3jpaqkNb88PUMplsjzlEUvCEfnQ\",\n//     domain: \"https://test.cloudflareaccess.com\",\n//   });\n\n//   if (identity != undefined) {\n//     return new Response(`Hello, ${identity.name || \"service user\"}!`);\n//   }\n//   return new Response(\n//     `Hello, ${data.cloudflareAccess.JWT.payload.email || \"service user\"}!`\n//   );\n// };\n\n  \n\n  ", "import { onRequest as __auth_home_ts_onRequest } from \"/home/runmy/Desktop/clarance/functions/auth/home.ts\"\nimport { onRequest as __auth_login_ts_onRequest } from \"/home/runmy/Desktop/clarance/functions/auth/login.ts\"\nimport { onRequest as __auth_logout_ts_onRequest } from \"/home/runmy/Desktop/clarance/functions/auth/logout.ts\"\nimport { onRequest as __auth_root_ts_onRequest } from \"/home/runmy/Desktop/clarance/functions/auth/root.ts\"\nimport { onRequest as __greet_ts_onRequest } from \"/home/runmy/Desktop/clarance/functions/greet.ts\"\n\nexport const routes = [\n    {\n      routePath: \"/auth/home\",\n      mountPath: \"/auth\",\n      method: \"\",\n      middlewares: [],\n      modules: [__auth_home_ts_onRequest],\n    },\n  {\n      routePath: \"/auth/login\",\n      mountPath: \"/auth\",\n      method: \"\",\n      middlewares: [],\n      modules: [__auth_login_ts_onRequest],\n    },\n  {\n      routePath: \"/auth/logout\",\n      mountPath: \"/auth\",\n      method: \"\",\n      middlewares: [],\n      modules: [__auth_logout_ts_onRequest],\n    },\n  {\n      routePath: \"/auth/root\",\n      mountPath: \"/auth\",\n      method: \"\",\n      middlewares: [],\n      modules: [__auth_root_ts_onRequest],\n    },\n  {\n      routePath: \"/greet\",\n      mountPath: \"/\",\n      method: \"\",\n      middlewares: [],\n      modules: [__greet_ts_onRequest],\n    },\n  ]", "// // This loads all middlewares exposed on the middleware object\n// // and then starts the invocation chain.\n// // The big idea is that we can add these to the middleware export dynamically\n// // through wrangler, or we can potentially let users directly add them as a sort\n// // of \"plugin\" system.\n\nimport worker from \"/home/runmy/Desktop/clarance/.wrangler/tmp/bundle-2HsAiA/middleware-insertion-facade.js\";\nimport {\n\t__facade_invoke__,\n\t__facade_register__,\n\tDispatcher,\n\tMiddleware,\n} from \"/home/runmy/Desktop/clarance/node_modules/wrangler/templates/middleware/common.ts\";\n\n// We need to preserve all of the exports from the worker\nexport * from \"/home/runmy/Desktop/clarance/.wrangler/tmp/bundle-2HsAiA/middleware-insertion-facade.js\";\n\nclass __Facade_ScheduledController__ implements ScheduledController {\n\t#noRetry: ScheduledController[\"noRetry\"];\n\n\tconstructor(\n\t\treadonly scheduledTime: number,\n\t\treadonly cron: string,\n\t\tnoRetry: ScheduledController[\"noRetry\"]\n\t) {\n\t\tthis.#noRetry = noRetry;\n\t}\n\n\tnoRetry() {\n\t\tif (!(this instanceof __Facade_ScheduledController__)) {\n\t\t\tthrow new TypeError(\"Illegal invocation\");\n\t\t}\n\t\t// Need to call native method immediately in case uncaught error thrown\n\t\tthis.#noRetry();\n\t}\n}\n\nconst __facade_modules_fetch__: ExportedHandlerFetchHandler = function (\n\trequest,\n\tenv,\n\tctx\n) {\n\tif (worker.fetch === undefined)\n\t\tthrow new Error(\"Handler does not export a fetch() function.\");\n\treturn worker.fetch(request, env, ctx);\n};\n\nfunction getMaskedEnv(rawEnv: unknown) {\n\tlet env = rawEnv as Record<string, unknown>;\n\tif (worker.envWrappers && worker.envWrappers.length > 0) {\n\t\tfor (const wrapFn of worker.envWrappers) {\n\t\t\tenv = wrapFn(env);\n\t\t}\n\t}\n\treturn env;\n}\n\n/**\n * This type is here to cause a type error if a new export handler is added to\n * `ExportHandler` without it being included in the `facade` below.\n */\ntype MissingExportHandlers = Omit<\n\tRequired<ExportedHandler>,\n\t\"tail\" | \"trace\" | \"scheduled\" | \"queue\" | \"test\" | \"email\" | \"fetch\"\n>;\n\nlet registeredMiddleware = false;\n\nconst facade: ExportedHandler<unknown> & MissingExportHandlers = {\n\t...(worker.tail && {\n\t\ttail: maskHandlerEnv(worker.tail),\n\t}),\n\t...(worker.trace && {\n\t\ttrace: maskHandlerEnv(worker.trace),\n\t}),\n\t...(worker.scheduled && {\n\t\tscheduled: maskHandlerEnv(worker.scheduled),\n\t}),\n\t...(worker.queue && {\n\t\tqueue: maskHandlerEnv(worker.queue),\n\t}),\n\t...(worker.test && {\n\t\ttest: maskHandlerEnv(worker.test),\n\t}),\n\t...(worker.email && {\n\t\temail: maskHandlerEnv(worker.email),\n\t}),\n\n\tfetch(request, rawEnv, ctx) {\n\t\tconst env = getMaskedEnv(rawEnv);\n\t\t// Get the chain of middleware from the worker object\n\t\tif (worker.middleware && worker.middleware.length > 0) {\n\t\t\t// Make sure we only register middleware once:\n\t\t\t// https://github.com/cloudflare/workers-sdk/issues/2386#issuecomment-1614715911\n\t\t\tif (!registeredMiddleware) {\n\t\t\t\tregisteredMiddleware = true;\n\t\t\t\tfor (const middleware of worker.middleware) {\n\t\t\t\t\t__facade_register__(middleware);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst __facade_modules_dispatch__: Dispatcher = function (type, init) {\n\t\t\t\tif (type === \"scheduled\" && worker.scheduled !== undefined) {\n\t\t\t\t\tconst controller = new __Facade_ScheduledController__(\n\t\t\t\t\t\tDate.now(),\n\t\t\t\t\t\tinit.cron ?? \"\",\n\t\t\t\t\t\t() => {}\n\t\t\t\t\t);\n\t\t\t\t\treturn worker.scheduled(controller, env, ctx);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\treturn __facade_invoke__(\n\t\t\t\trequest,\n\t\t\t\tenv,\n\t\t\t\tctx,\n\t\t\t\t__facade_modules_dispatch__,\n\t\t\t\t__facade_modules_fetch__\n\t\t\t);\n\t\t} else {\n\t\t\t// We didn't have any middleware so we can skip the invocation chain,\n\t\t\t// and just call the fetch handler directly\n\n\t\t\t// We \"don't care\" if this is undefined as we want to have the same behavior\n\t\t\t// as if the worker completely bypassed middleware.\n\t\t\treturn __facade_modules_fetch__(request, env, ctx);\n\t\t}\n\t},\n};\n\ntype HandlerFn<D, R> = (data: D, env: unknown, ctx: ExecutionContext) => R;\nfunction maskHandlerEnv<D, R>(handler: HandlerFn<D, R>): HandlerFn<D, R> {\n\treturn (data, env, ctx) => handler(data, getMaskedEnv(env), ctx);\n}\n\nexport default facade;\n", "\t\t\t\timport worker, * as OTHER_EXPORTS from \"/home/runmy/Desktop/clarance/node_modules/wrangler/templates/pages-template-worker.ts\";\n\t\t\t\timport * as __MIDDLEWARE_0__ from \"/home/runmy/Desktop/clarance/node_modules/wrangler/templates/middleware/middleware-miniflare3-json-error.ts\";\n\t\t\t\tconst envWrappers = [__MIDDLEWARE_0__.wrap].filter(Boolean);\n\t\t\t\tconst facade = {\n\t\t\t\t\t...worker,\n\t\t\t\t\tenvWrappers,\n\t\t\t\t\tmiddleware: [\n\t\t\t\t\t\t__MIDDLEWARE_0__.default,\n            ...(worker.middleware ? worker.middleware : []),\n\t\t\t\t\t].filter(Boolean)\n\t\t\t\t}\n\t\t\t\texport * from \"/home/runmy/Desktop/clarance/node_modules/wrangler/templates/pages-template-worker.ts\";\n\n\t\t\t\tconst maskDurableObjectDefinition = (cls) =>\n\t\t\t\t\tclass extends cls {\n\t\t\t\t\t\tconstructor(state, env) {\n\t\t\t\t\t\t\tlet wrappedEnv = env\n\t\t\t\t\t\t\tfor (const wrapFn of envWrappers) {\n\t\t\t\t\t\t\t\twrappedEnv = wrapFn(wrappedEnv)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsuper(state, wrappedEnv);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\n\n\t\t\t\texport default facade;", "import { match } from \"path-to-regexp\";\n\n//note: this explicitly does not include the * character, as pages requires this\nconst escapeRegex = /[.+?^${}()|[\\]\\\\]/g;\n\ntype HTTPMethod =\n\t| \"HEAD\"\n\t| \"OPTIONS\"\n\t| \"GET\"\n\t| \"POST\"\n\t| \"PUT\"\n\t| \"PATCH\"\n\t| \"DELETE\";\n\n/* TODO: Grab these from @cloudflare/workers-types instead */\ntype Params<P extends string = string> = Record<P, string | string[]>;\n\ntype EventContext<Env, P extends string, Data> = {\n\trequest: Request;\n\tfunctionPath: string;\n\twaitUntil: (promise: Promise<unknown>) => void;\n\tpassThroughOnException: () => void;\n\tnext: (input?: Request | string, init?: RequestInit) => Promise<Response>;\n\tenv: Env & { ASSETS: { fetch: typeof fetch } };\n\tparams: Params<P>;\n\tdata: Data;\n};\n\ndeclare type PagesFunction<\n\tEnv = unknown,\n\tP extends string = string,\n\tData extends Record<string, unknown> = Record<string, unknown>\n> = (context: EventContext<Env, P, Data>) => Response | Promise<Response>;\n/* end @cloudflare/workers-types */\n\ntype RouteHandler = {\n\troutePath: string;\n\tmountPath: string;\n\tmethod?: HTTPMethod;\n\tmodules: PagesFunction[];\n\tmiddlewares: PagesFunction[];\n};\n\n// inject `routes` via ESBuild\ndeclare const routes: RouteHandler[];\n// define `__FALLBACK_SERVICE__` via ESBuild\ndeclare const __FALLBACK_SERVICE__: string;\n\n// expect an ASSETS fetcher binding pointing to the asset-server stage\ntype FetchEnv = {\n\t[name: string]: { fetch: typeof fetch };\n\tASSETS: { fetch: typeof fetch };\n};\n\ntype WorkerContext = {\n\twaitUntil: (promise: Promise<unknown>) => void;\n\tpassThroughOnException: () => void;\n};\n\nfunction* executeRequest(request: Request) {\n\tconst requestPath = new URL(request.url).pathname;\n\n\t// First, iterate through the routes (backwards) and execute \"middlewares\" on partial route matches\n\tfor (const route of [...routes].reverse()) {\n\t\tif (route.method && route.method !== request.method) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// replaces with \"\\\\$&\", this prepends a backslash to the matched string, e.g. \"[\" becomes \"\\[\"\n\t\tconst routeMatcher = match(route.routePath.replace(escapeRegex, \"\\\\$&\"), {\n\t\t\tend: false,\n\t\t});\n\t\tconst mountMatcher = match(route.mountPath.replace(escapeRegex, \"\\\\$&\"), {\n\t\t\tend: false,\n\t\t});\n\t\tconst matchResult = routeMatcher(requestPath);\n\t\tconst mountMatchResult = mountMatcher(requestPath);\n\t\tif (matchResult && mountMatchResult) {\n\t\t\tfor (const handler of route.middlewares.flat()) {\n\t\t\t\tyield {\n\t\t\t\t\thandler,\n\t\t\t\t\tparams: matchResult.params as Params,\n\t\t\t\t\tpath: mountMatchResult.path,\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t}\n\n\t// Then look for the first exact route match and execute its \"modules\"\n\tfor (const route of routes) {\n\t\tif (route.method && route.method !== request.method) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst routeMatcher = match(route.routePath.replace(escapeRegex, \"\\\\$&\"), {\n\t\t\tend: true,\n\t\t});\n\t\tconst mountMatcher = match(route.mountPath.replace(escapeRegex, \"\\\\$&\"), {\n\t\t\tend: false,\n\t\t});\n\t\tconst matchResult = routeMatcher(requestPath);\n\t\tconst mountMatchResult = mountMatcher(requestPath);\n\t\tif (matchResult && mountMatchResult && route.modules.length) {\n\t\t\tfor (const handler of route.modules.flat()) {\n\t\t\t\tyield {\n\t\t\t\t\thandler,\n\t\t\t\t\tparams: matchResult.params as Params,\n\t\t\t\t\tpath: matchResult.path,\n\t\t\t\t};\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nexport default {\n\tasync fetch(\n\t\toriginalRequest: Request,\n\t\tenv: FetchEnv,\n\t\tworkerContext: WorkerContext\n\t) {\n\t\tlet request = originalRequest;\n\t\tconst handlerIterator = executeRequest(request);\n\t\tlet data = {}; // arbitrary data the user can set between functions\n\t\tlet isFailOpen = false;\n\n\t\tconst next = async (input?: RequestInfo, init?: RequestInit) => {\n\t\t\tif (input !== undefined) {\n\t\t\t\tlet url = input;\n\t\t\t\tif (typeof input === \"string\") {\n\t\t\t\t\turl = new URL(input, request.url).toString();\n\t\t\t\t}\n\t\t\t\trequest = new Request(url, init);\n\t\t\t}\n\n\t\t\tconst result = handlerIterator.next();\n\t\t\t// Note we can't use `!result.done` because this doesn't narrow to the correct type\n\t\t\tif (result.done === false) {\n\t\t\t\tconst { handler, params, path } = result.value;\n\t\t\t\tconst context = {\n\t\t\t\t\trequest: new Request(request.clone()),\n\t\t\t\t\tfunctionPath: path,\n\t\t\t\t\tnext,\n\t\t\t\t\tparams,\n\t\t\t\t\tget data() {\n\t\t\t\t\t\treturn data;\n\t\t\t\t\t},\n\t\t\t\t\tset data(value) {\n\t\t\t\t\t\tif (typeof value !== \"object\" || value === null) {\n\t\t\t\t\t\t\tthrow new Error(\"context.data must be an object\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// user has overriden context.data, so we need to merge it with the existing data\n\t\t\t\t\t\tdata = value;\n\t\t\t\t\t},\n\t\t\t\t\tenv,\n\t\t\t\t\twaitUntil: workerContext.waitUntil.bind(workerContext),\n\t\t\t\t\tpassThroughOnException: () => {\n\t\t\t\t\t\tisFailOpen = true;\n\t\t\t\t\t},\n\t\t\t\t};\n\n\t\t\t\tconst response = await handler(context);\n\n\t\t\t\tif (!(response instanceof Response)) {\n\t\t\t\t\tthrow new Error(\"Your Pages function should return a Response\");\n\t\t\t\t}\n\n\t\t\t\treturn cloneResponse(response);\n\t\t\t} else if (__FALLBACK_SERVICE__) {\n\t\t\t\t// There are no more handlers so finish with the fallback service (`env.ASSETS.fetch` in Pages' case)\n\t\t\t\tconst response = await env[__FALLBACK_SERVICE__].fetch(request);\n\t\t\t\treturn cloneResponse(response);\n\t\t\t} else {\n\t\t\t\t// There was not fallback service so actually make the request to the origin.\n\t\t\t\tconst response = await fetch(request);\n\t\t\t\treturn cloneResponse(response);\n\t\t\t}\n\t\t};\n\n\t\ttry {\n\t\t\treturn await next();\n\t\t} catch (error) {\n\t\t\tif (isFailOpen) {\n\t\t\t\tconst response = await env[__FALLBACK_SERVICE__].fetch(request);\n\t\t\t\treturn cloneResponse(response);\n\t\t\t}\n\n\t\t\tthrow error;\n\t\t}\n\t},\n};\n\n// This makes a Response mutable\nconst cloneResponse = (response: Response) =>\n\t// https://fetch.spec.whatwg.org/#null-body-status\n\tnew Response(\n\t\t[101, 204, 205, 304].includes(response.status) ? null : response.body,\n\t\tresponse\n\t);\n", "/**\n * Tokenizer results.\n */\ninterface LexToken {\n  type:\n    | \"OPEN\"\n    | \"CLOSE\"\n    | \"PATTERN\"\n    | \"NAME\"\n    | \"CHAR\"\n    | \"ESCAPED_CHAR\"\n    | \"MODIFIER\"\n    | \"END\";\n  index: number;\n  value: string;\n}\n\n/**\n * Tokenize input string.\n */\nfunction lexer(str: string): LexToken[] {\n  const tokens: LexToken[] = [];\n  let i = 0;\n\n  while (i < str.length) {\n    const char = str[i];\n\n    if (char === \"*\" || char === \"+\" || char === \"?\") {\n      tokens.push({ type: \"MODIFIER\", index: i, value: str[i++] });\n      continue;\n    }\n\n    if (char === \"\\\\\") {\n      tokens.push({ type: \"ESCAPED_CHAR\", index: i++, value: str[i++] });\n      continue;\n    }\n\n    if (char === \"{\") {\n      tokens.push({ type: \"OPEN\", index: i, value: str[i++] });\n      continue;\n    }\n\n    if (char === \"}\") {\n      tokens.push({ type: \"CLOSE\", index: i, value: str[i++] });\n      continue;\n    }\n\n    if (char === \":\") {\n      let name = \"\";\n      let j = i + 1;\n\n      while (j < str.length) {\n        const code = str.charCodeAt(j);\n\n        if (\n          // `0-9`\n          (code >= 48 && code <= 57) ||\n          // `A-Z`\n          (code >= 65 && code <= 90) ||\n          // `a-z`\n          (code >= 97 && code <= 122) ||\n          // `_`\n          code === 95\n        ) {\n          name += str[j++];\n          continue;\n        }\n\n        break;\n      }\n\n      if (!name) throw new TypeError(`Missing parameter name at ${i}`);\n\n      tokens.push({ type: \"NAME\", index: i, value: name });\n      i = j;\n      continue;\n    }\n\n    if (char === \"(\") {\n      let count = 1;\n      let pattern = \"\";\n      let j = i + 1;\n\n      if (str[j] === \"?\") {\n        throw new TypeError(`Pattern cannot start with \"?\" at ${j}`);\n      }\n\n      while (j < str.length) {\n        if (str[j] === \"\\\\\") {\n          pattern += str[j++] + str[j++];\n          continue;\n        }\n\n        if (str[j] === \")\") {\n          count--;\n          if (count === 0) {\n            j++;\n            break;\n          }\n        } else if (str[j] === \"(\") {\n          count++;\n          if (str[j + 1] !== \"?\") {\n            throw new TypeError(`Capturing groups are not allowed at ${j}`);\n          }\n        }\n\n        pattern += str[j++];\n      }\n\n      if (count) throw new TypeError(`Unbalanced pattern at ${i}`);\n      if (!pattern) throw new TypeError(`Missing pattern at ${i}`);\n\n      tokens.push({ type: \"PATTERN\", index: i, value: pattern });\n      i = j;\n      continue;\n    }\n\n    tokens.push({ type: \"CHAR\", index: i, value: str[i++] });\n  }\n\n  tokens.push({ type: \"END\", index: i, value: \"\" });\n\n  return tokens;\n}\n\nexport interface ParseOptions {\n  /**\n   * Set the default delimiter for repeat parameters. (default: `'/'`)\n   */\n  delimiter?: string;\n  /**\n   * List of characters to automatically consider prefixes when parsing.\n   */\n  prefixes?: string;\n}\n\n/**\n * Parse a string for the raw tokens.\n */\nexport function parse(str: string, options: ParseOptions = {}): Token[] {\n  const tokens = lexer(str);\n  const { prefixes = \"./\" } = options;\n  const defaultPattern = `[^${escapeString(options.delimiter || \"/#?\")}]+?`;\n  const result: Token[] = [];\n  let key = 0;\n  let i = 0;\n  let path = \"\";\n\n  const tryConsume = (type: LexToken[\"type\"]): string | undefined => {\n    if (i < tokens.length && tokens[i].type === type) return tokens[i++].value;\n  };\n\n  const mustConsume = (type: LexToken[\"type\"]): string => {\n    const value = tryConsume(type);\n    if (value !== undefined) return value;\n    const { type: nextType, index } = tokens[i];\n    throw new TypeError(`Unexpected ${nextType} at ${index}, expected ${type}`);\n  };\n\n  const consumeText = (): string => {\n    let result = \"\";\n    let value: string | undefined;\n    while ((value = tryConsume(\"CHAR\") || tryConsume(\"ESCAPED_CHAR\"))) {\n      result += value;\n    }\n    return result;\n  };\n\n  while (i < tokens.length) {\n    const char = tryConsume(\"CHAR\");\n    const name = tryConsume(\"NAME\");\n    const pattern = tryConsume(\"PATTERN\");\n\n    if (name || pattern) {\n      let prefix = char || \"\";\n\n      if (prefixes.indexOf(prefix) === -1) {\n        path += prefix;\n        prefix = \"\";\n      }\n\n      if (path) {\n        result.push(path);\n        path = \"\";\n      }\n\n      result.push({\n        name: name || key++,\n        prefix,\n        suffix: \"\",\n        pattern: pattern || defaultPattern,\n        modifier: tryConsume(\"MODIFIER\") || \"\",\n      });\n      continue;\n    }\n\n    const value = char || tryConsume(\"ESCAPED_CHAR\");\n    if (value) {\n      path += value;\n      continue;\n    }\n\n    if (path) {\n      result.push(path);\n      path = \"\";\n    }\n\n    const open = tryConsume(\"OPEN\");\n    if (open) {\n      const prefix = consumeText();\n      const name = tryConsume(\"NAME\") || \"\";\n      const pattern = tryConsume(\"PATTERN\") || \"\";\n      const suffix = consumeText();\n\n      mustConsume(\"CLOSE\");\n\n      result.push({\n        name: name || (pattern ? key++ : \"\"),\n        pattern: name && !pattern ? defaultPattern : pattern,\n        prefix,\n        suffix,\n        modifier: tryConsume(\"MODIFIER\") || \"\",\n      });\n      continue;\n    }\n\n    mustConsume(\"END\");\n  }\n\n  return result;\n}\n\nexport interface TokensToFunctionOptions {\n  /**\n   * When `true` the regexp will be case sensitive. (default: `false`)\n   */\n  sensitive?: boolean;\n  /**\n   * Function for encoding input strings for output.\n   */\n  encode?: (value: string, token: Key) => string;\n  /**\n   * When `false` the function can produce an invalid (unmatched) path. (default: `true`)\n   */\n  validate?: boolean;\n}\n\n/**\n * Compile a string to a template function for the path.\n */\nexport function compile<P extends object = object>(\n  str: string,\n  options?: ParseOptions & TokensToFunctionOptions\n) {\n  return tokensToFunction<P>(parse(str, options), options);\n}\n\nexport type PathFunction<P extends object = object> = (data?: P) => string;\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nexport function tokensToFunction<P extends object = object>(\n  tokens: Token[],\n  options: TokensToFunctionOptions = {}\n): PathFunction<P> {\n  const reFlags = flags(options);\n  const { encode = (x: string) => x, validate = true } = options;\n\n  // Compile all the tokens into regexps.\n  const matches = tokens.map((token) => {\n    if (typeof token === \"object\") {\n      return new RegExp(`^(?:${token.pattern})$`, reFlags);\n    }\n  });\n\n  return (data: Record<string, any> | null | undefined) => {\n    let path = \"\";\n\n    for (let i = 0; i < tokens.length; i++) {\n      const token = tokens[i];\n\n      if (typeof token === \"string\") {\n        path += token;\n        continue;\n      }\n\n      const value = data ? data[token.name] : undefined;\n      const optional = token.modifier === \"?\" || token.modifier === \"*\";\n      const repeat = token.modifier === \"*\" || token.modifier === \"+\";\n\n      if (Array.isArray(value)) {\n        if (!repeat) {\n          throw new TypeError(\n            `Expected \"${token.name}\" to not repeat, but got an array`\n          );\n        }\n\n        if (value.length === 0) {\n          if (optional) continue;\n\n          throw new TypeError(`Expected \"${token.name}\" to not be empty`);\n        }\n\n        for (let j = 0; j < value.length; j++) {\n          const segment = encode(value[j], token);\n\n          if (validate && !(matches[i] as RegExp).test(segment)) {\n            throw new TypeError(\n              `Expected all \"${token.name}\" to match \"${token.pattern}\", but got \"${segment}\"`\n            );\n          }\n\n          path += token.prefix + segment + token.suffix;\n        }\n\n        continue;\n      }\n\n      if (typeof value === \"string\" || typeof value === \"number\") {\n        const segment = encode(String(value), token);\n\n        if (validate && !(matches[i] as RegExp).test(segment)) {\n          throw new TypeError(\n            `Expected \"${token.name}\" to match \"${token.pattern}\", but got \"${segment}\"`\n          );\n        }\n\n        path += token.prefix + segment + token.suffix;\n        continue;\n      }\n\n      if (optional) continue;\n\n      const typeOfMessage = repeat ? \"an array\" : \"a string\";\n      throw new TypeError(`Expected \"${token.name}\" to be ${typeOfMessage}`);\n    }\n\n    return path;\n  };\n}\n\nexport interface RegexpToFunctionOptions {\n  /**\n   * Function for decoding strings for params.\n   */\n  decode?: (value: string, token: Key) => string;\n}\n\n/**\n * A match result contains data about the path match.\n */\nexport interface MatchResult<P extends object = object> {\n  path: string;\n  index: number;\n  params: P;\n}\n\n/**\n * A match is either `false` (no match) or a match result.\n */\nexport type Match<P extends object = object> = false | MatchResult<P>;\n\n/**\n * The match function takes a string and returns whether it matched the path.\n */\nexport type MatchFunction<P extends object = object> = (\n  path: string\n) => Match<P>;\n\n/**\n * Create path match function from `path-to-regexp` spec.\n */\nexport function match<P extends object = object>(\n  str: Path,\n  options?: ParseOptions & TokensToRegexpOptions & RegexpToFunctionOptions\n) {\n  const keys: Key[] = [];\n  const re = pathToRegexp(str, keys, options);\n  return regexpToFunction<P>(re, keys, options);\n}\n\n/**\n * Create a path match function from `path-to-regexp` output.\n */\nexport function regexpToFunction<P extends object = object>(\n  re: RegExp,\n  keys: Key[],\n  options: RegexpToFunctionOptions = {}\n): MatchFunction<P> {\n  const { decode = (x: string) => x } = options;\n\n  return function (pathname: string) {\n    const m = re.exec(pathname);\n    if (!m) return false;\n\n    const { 0: path, index } = m;\n    const params = Object.create(null);\n\n    for (let i = 1; i < m.length; i++) {\n      if (m[i] === undefined) continue;\n\n      const key = keys[i - 1];\n\n      if (key.modifier === \"*\" || key.modifier === \"+\") {\n        params[key.name] = m[i].split(key.prefix + key.suffix).map((value) => {\n          return decode(value, key);\n        });\n      } else {\n        params[key.name] = decode(m[i], key);\n      }\n    }\n\n    return { path, index, params };\n  };\n}\n\n/**\n * Escape a regular expression string.\n */\nfunction escapeString(str: string) {\n  return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, \"\\\\$1\");\n}\n\n/**\n * Get the flags for a regexp from the options.\n */\nfunction flags(options?: { sensitive?: boolean }) {\n  return options && options.sensitive ? \"\" : \"i\";\n}\n\n/**\n * Metadata about a key.\n */\nexport interface Key {\n  name: string | number;\n  prefix: string;\n  suffix: string;\n  pattern: string;\n  modifier: string;\n}\n\n/**\n * A token is a string (nothing special) or key metadata (capture group).\n */\nexport type Token = string | Key;\n\n/**\n * Pull out keys from a regexp.\n */\nfunction regexpToRegexp(path: RegExp, keys?: Key[]): RegExp {\n  if (!keys) return path;\n\n  const groupsRegex = /\\((?:\\?<(.*?)>)?(?!\\?)/g;\n\n  let index = 0;\n  let execResult = groupsRegex.exec(path.source);\n  while (execResult) {\n    keys.push({\n      // Use parenthesized substring match if available, index otherwise\n      name: execResult[1] || index++,\n      prefix: \"\",\n      suffix: \"\",\n      modifier: \"\",\n      pattern: \"\",\n    });\n    execResult = groupsRegex.exec(path.source);\n  }\n\n  return path;\n}\n\n/**\n * Transform an array into a regexp.\n */\nfunction arrayToRegexp(\n  paths: Array<string | RegExp>,\n  keys?: Key[],\n  options?: TokensToRegexpOptions & ParseOptions\n): RegExp {\n  const parts = paths.map((path) => pathToRegexp(path, keys, options).source);\n  return new RegExp(`(?:${parts.join(\"|\")})`, flags(options));\n}\n\n/**\n * Create a path regexp from string input.\n */\nfunction stringToRegexp(\n  path: string,\n  keys?: Key[],\n  options?: TokensToRegexpOptions & ParseOptions\n) {\n  return tokensToRegexp(parse(path, options), keys, options);\n}\n\nexport interface TokensToRegexpOptions {\n  /**\n   * When `true` the regexp will be case sensitive. (default: `false`)\n   */\n  sensitive?: boolean;\n  /**\n   * When `true` the regexp won't allow an optional trailing delimiter to match. (default: `false`)\n   */\n  strict?: boolean;\n  /**\n   * When `true` the regexp will match to the end of the string. (default: `true`)\n   */\n  end?: boolean;\n  /**\n   * When `true` the regexp will match from the beginning of the string. (default: `true`)\n   */\n  start?: boolean;\n  /**\n   * Sets the final character for non-ending optimistic matches. (default: `/`)\n   */\n  delimiter?: string;\n  /**\n   * List of characters that can also be \"end\" characters.\n   */\n  endsWith?: string;\n  /**\n   * Encode path tokens for use in the `RegExp`.\n   */\n  encode?: (value: string) => string;\n}\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n */\nexport function tokensToRegexp(\n  tokens: Token[],\n  keys?: Key[],\n  options: TokensToRegexpOptions = {}\n) {\n  const {\n    strict = false,\n    start = true,\n    end = true,\n    encode = (x: string) => x,\n    delimiter = \"/#?\",\n    endsWith = \"\",\n  } = options;\n  const endsWithRe = `[${escapeString(endsWith)}]|$`;\n  const delimiterRe = `[${escapeString(delimiter)}]`;\n  let route = start ? \"^\" : \"\";\n\n  // Iterate over the tokens and create our regexp string.\n  for (const token of tokens) {\n    if (typeof token === \"string\") {\n      route += escapeString(encode(token));\n    } else {\n      const prefix = escapeString(encode(token.prefix));\n      const suffix = escapeString(encode(token.suffix));\n\n      if (token.pattern) {\n        if (keys) keys.push(token);\n\n        if (prefix || suffix) {\n          if (token.modifier === \"+\" || token.modifier === \"*\") {\n            const mod = token.modifier === \"*\" ? \"?\" : \"\";\n            route += `(?:${prefix}((?:${token.pattern})(?:${suffix}${prefix}(?:${token.pattern}))*)${suffix})${mod}`;\n          } else {\n            route += `(?:${prefix}(${token.pattern})${suffix})${token.modifier}`;\n          }\n        } else {\n          if (token.modifier === \"+\" || token.modifier === \"*\") {\n            route += `((?:${token.pattern})${token.modifier})`;\n          } else {\n            route += `(${token.pattern})${token.modifier}`;\n          }\n        }\n      } else {\n        route += `(?:${prefix}${suffix})${token.modifier}`;\n      }\n    }\n  }\n\n  if (end) {\n    if (!strict) route += `${delimiterRe}?`;\n\n    route += !options.endsWith ? \"$\" : `(?=${endsWithRe})`;\n  } else {\n    const endToken = tokens[tokens.length - 1];\n    const isEndDelimited =\n      typeof endToken === \"string\"\n        ? delimiterRe.indexOf(endToken[endToken.length - 1]) > -1\n        : endToken === undefined;\n\n    if (!strict) {\n      route += `(?:${delimiterRe}(?=${endsWithRe}))?`;\n    }\n\n    if (!isEndDelimited) {\n      route += `(?=${delimiterRe}|${endsWithRe})`;\n    }\n  }\n\n  return new RegExp(route, flags(options));\n}\n\n/**\n * Supported `path-to-regexp` input types.\n */\nexport type Path = string | RegExp | Array<string | RegExp>;\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n */\nexport function pathToRegexp(\n  path: Path,\n  keys?: Key[],\n  options?: TokensToRegexpOptions & ParseOptions\n) {\n  if (path instanceof RegExp) return regexpToRegexp(path, keys);\n  if (Array.isArray(path)) return arrayToRegexp(path, keys, options);\n  return stringToRegexp(path, keys, options);\n}\n", "import type { Middleware } from \"./common\";\n\ninterface JsonError {\n\tmessage?: string;\n\tname?: string;\n\tstack?: string;\n\tcause?: JsonError;\n}\n\nfunction reduceError(e: any): JsonError {\n\treturn {\n\t\tname: e?.name,\n\t\tmessage: e?.message ?? String(e),\n\t\tstack: e?.stack,\n\t\tcause: e?.cause === undefined ? undefined : reduceError(e.cause),\n\t};\n}\n\n// See comment in `bundle.ts` for details on why this is needed\nconst jsonError: Middleware = async (request, env, _ctx, middlewareCtx) => {\n\ttry {\n\t\treturn await middlewareCtx.next(request, env);\n\t} catch (e: any) {\n\t\tconst error = reduceError(e);\n\t\treturn Response.json(error, {\n\t\t\tstatus: 500,\n\t\t\theaders: { \"MF-Experimental-Error-Stack\": \"true\" },\n\t\t});\n\t}\n};\n\nexport default jsonError;\nexport const wrap = undefined;\n", "export type Awaitable<T> = T | Promise<T>;\n// TODO: allow dispatching more events?\nexport type Dispatcher = (\n\ttype: \"scheduled\",\n\tinit: { cron?: string }\n) => Awaitable<void>;\n\nexport type IncomingRequest = Request<\n\tunknown,\n\tIncomingRequestCfProperties<unknown>\n>;\n\nexport interface MiddlewareContext {\n\tdispatch: Dispatcher;\n\tnext(request: IncomingRequest, env: any): Awaitable<Response>;\n}\n\nexport type Middleware = (\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tmiddlewareCtx: MiddlewareContext\n) => Awaitable<Response>;\n\nconst __facade_middleware__: Middleware[] = [];\n\n// The register functions allow for the insertion of one or many middleware,\n// We register internal middleware first in the stack, but have no way of controlling\n// the order that addMiddleware is run in service workers so need an internal function.\nexport function __facade_register__(...args: (Middleware | Middleware[])[]) {\n\t__facade_middleware__.push(...args.flat());\n}\nexport function __facade_registerInternal__(\n\t...args: (Middleware | Middleware[])[]\n) {\n\t__facade_middleware__.unshift(...args.flat());\n}\n\nfunction __facade_invokeChain__(\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tdispatch: Dispatcher,\n\tmiddlewareChain: Middleware[]\n): Awaitable<Response> {\n\tconst [head, ...tail] = middlewareChain;\n\tconst middlewareCtx: MiddlewareContext = {\n\t\tdispatch,\n\t\tnext(newRequest, newEnv) {\n\t\t\treturn __facade_invokeChain__(newRequest, newEnv, ctx, dispatch, tail);\n\t\t},\n\t};\n\treturn head(request, env, ctx, middlewareCtx);\n}\n\nexport function __facade_invoke__(\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tdispatch: Dispatcher,\n\tfinalMiddleware: Middleware\n): Awaitable<Response> {\n\treturn __facade_invokeChain__(request, env, ctx, dispatch, [\n\t\t...__facade_middleware__,\n\t\tfinalMiddleware,\n\t]);\n}\n", "/**\n * @param pathname A pathname string, such as `/foo` or `/foo/bar`\n * @param routingRule The routing rule, such as `/foo/*`\n * @returns True if pathname matches the routing rule\n *\n * /       ->  /\n * /*      ->  /*\n * /foo    ->  /foo\n * /foo*   ->  /foo, /foo-bar, /foo/*\n * /foo/*  ->  /foo, /foo/bar\n */\nexport function isRoutingRuleMatch(\n\tpathname: string,\n\troutingRule: string\n): boolean {\n\t// sanity checks\n\tif (!pathname) {\n\t\tthrow new Error(\"Pathname is undefined.\");\n\t}\n\tif (!routingRule) {\n\t\tthrow new Error(\"Routing rule is undefined.\");\n\t}\n\n\tconst ruleRegExp = transformRoutingRuleToRegExp(routingRule);\n\treturn pathname.match(ruleRegExp) !== null;\n}\n\nfunction transformRoutingRuleToRegExp(rule: string): RegExp {\n\tlet transformedRule;\n\n\tif (rule === \"/\" || rule === \"/*\") {\n\t\ttransformedRule = rule;\n\t} else if (rule.endsWith(\"/*\")) {\n\t\t// make `/*` an optional group so we can match both /foo/* and /foo\n\t\t// /foo/* => /foo(/*)?\n\t\ttransformedRule = `${rule.substring(0, rule.length - 2)}(/*)?`;\n\t} else if (rule.endsWith(\"/\")) {\n\t\t// make `/` an optional group so we can match both /foo/ and /foo\n\t\t// /foo/ => /foo(/)?\n\t\ttransformedRule = `${rule.substring(0, rule.length - 1)}(/)?`;\n\t} else if (rule.endsWith(\"*\")) {\n\t\ttransformedRule = rule;\n\t} else {\n\t\ttransformedRule = `${rule}(/)?`;\n\t}\n\n\t// /foo* => /foo.* => ^/foo.*$\n\t// /*.* => /*\\.* => /.*\\..* => ^/.*\\..*$\n\ttransformedRule = `^${transformedRule\n\t\t.replaceAll(/\\./g, \"\\\\.\")\n\t\t.replaceAll(/\\*/g, \".*\")}$`;\n\n\t// ^/foo.*$ => /^\\/foo.*$/\n\treturn new RegExp(transformedRule);\n}\n", "", "// @ts-ignore entry point will get replaced\nimport worker from \"__ENTRY_POINT__\";\nimport { isRoutingRuleMatch } from \"./pages-dev-util\";\n\n// @ts-ignore entry point will get replaced\nexport * from \"__ENTRY_POINT__\";\n\n// @ts-ignore routes are injected\nconst routes = __ROUTES__;\n\nexport default <ExportedHandler<{ ASSETS: Fetcher }>>{\n\tfetch(request, env, context) {\n\t\tconst { pathname } = new URL(request.url);\n\n\t\tfor (const exclude of routes.exclude) {\n\t\t\tif (isRoutingRuleMatch(pathname, exclude)) {\n\t\t\t\treturn env.ASSETS.fetch(request);\n\t\t\t}\n\t\t}\n\n\t\tfor (const include of routes.include) {\n\t\t\tif (isRoutingRuleMatch(pathname, include)) {\n\t\t\t\tif (worker.fetch === undefined) {\n\t\t\t\t\tthrow new TypeError(\"Entry point missing `fetch` handler\");\n\t\t\t\t}\n\t\t\t\treturn worker.fetch(request, env, context);\n\t\t\t}\n\t\t}\n\n\t\treturn env.ASSETS.fetch(request);\n\t},\n};\n", "import type { Middleware } from \"./common\";\n\ninterface JsonError {\n\tmessage?: string;\n\tname?: string;\n\tstack?: string;\n\tcause?: JsonError;\n}\n\nfunction reduceError(e: any): JsonError {\n\treturn {\n\t\tname: e?.name,\n\t\tmessage: e?.message ?? String(e),\n\t\tstack: e?.stack,\n\t\tcause: e?.cause === undefined ? undefined : reduceError(e.cause),\n\t};\n}\n\n// See comment in `bundle.ts` for details on why this is needed\nconst jsonError: Middleware = async (request, env, _ctx, middlewareCtx) => {\n\ttry {\n\t\treturn await middlewareCtx.next(request, env);\n\t} catch (e: any) {\n\t\tconst error = reduceError(e);\n\t\treturn Response.json(error, {\n\t\t\tstatus: 500,\n\t\t\theaders: { \"MF-Experimental-Error-Stack\": \"true\" },\n\t\t});\n\t}\n};\n\nexport default jsonError;\nexport const wrap = undefined;\n", "/// <reference path=\"middleware-serve-static-assets.d.ts\"/>\n\nimport manifest from \"__STATIC_CONTENT_MANIFEST\";\nimport {\n\tgetAssetFromKV,\n\tMethodNotAllowedError,\n\tNotFoundError,\n\tserveSinglePageApp,\n} from \"@cloudflare/kv-asset-handler\";\nimport { cacheControl, spaMode } from \"config:middleware/serve-static-assets\";\nimport type { Middleware } from \"./common\";\nimport type { Options } from \"@cloudflare/kv-asset-handler\";\nimport type * as kvAssetHandler from \"@cloudflare/kv-asset-handler\";\n\nconst ASSET_MANIFEST = JSON.parse(manifest);\n\nconst staticAssets: Middleware = async (request, env, _ctx, middlewareCtx) => {\n\tlet options: Partial<Options> = {\n\t\tASSET_MANIFEST,\n\t\tASSET_NAMESPACE: env.__STATIC_CONTENT,\n\t\tcacheControl: cacheControl,\n\t\tmapRequestToAsset: spaMode ? serveSinglePageApp : undefined,\n\t};\n\n\ttry {\n\t\tconst page = await (getAssetFromKV as typeof kvAssetHandler.getAssetFromKV)(\n\t\t\t{\n\t\t\t\trequest,\n\t\t\t\twaitUntil(promise) {\n\t\t\t\t\treturn _ctx.waitUntil(promise);\n\t\t\t\t},\n\t\t\t},\n\t\t\toptions\n\t\t);\n\n\t\t// allow headers to be altered\n\t\tconst response = new Response(page.body, page);\n\n\t\tresponse.headers.set(\"X-XSS-Protection\", \"1; mode=block\");\n\t\tresponse.headers.set(\"X-Content-Type-Options\", \"nosniff\");\n\t\tresponse.headers.set(\"X-Frame-Options\", \"DENY\");\n\t\tresponse.headers.set(\"Referrer-Policy\", \"unsafe-url\");\n\t\tresponse.headers.set(\"Feature-Policy\", \"none\");\n\n\t\treturn response;\n\t} catch (e) {\n\t\tif (e instanceof NotFoundError || e instanceof MethodNotAllowedError) {\n\t\t\t// if a known error is thrown then serve from actual worker\n\t\t\treturn await middlewareCtx.next(request, env);\n\t\t}\n\t\t// otherwise it's a real error, so throw it\n\t\tthrow e;\n\t}\n};\n\nexport default staticAssets;\n", "{\"spaMode\":false,\"cacheControl\":{\"browserTTL\":172800,\"bypassCache\":true}}", "export type Awaitable<T> = T | Promise<T>;\n// TODO: allow dispatching more events?\nexport type Dispatcher = (\n\ttype: \"scheduled\",\n\tinit: { cron?: string }\n) => Awaitable<void>;\n\nexport type IncomingRequest = Request<\n\tunknown,\n\tIncomingRequestCfProperties<unknown>\n>;\n\nexport interface MiddlewareContext {\n\tdispatch: Dispatcher;\n\tnext(request: IncomingRequest, env: any): Awaitable<Response>;\n}\n\nexport type Middleware = (\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tmiddlewareCtx: MiddlewareContext\n) => Awaitable<Response>;\n\nconst __facade_middleware__: Middleware[] = [];\n\n// The register functions allow for the insertion of one or many middleware,\n// We register internal middleware first in the stack, but have no way of controlling\n// the order that addMiddleware is run in service workers so need an internal function.\nexport function __facade_register__(...args: (Middleware | Middleware[])[]) {\n\t__facade_middleware__.push(...args.flat());\n}\nexport function __facade_registerInternal__(\n\t...args: (Middleware | Middleware[])[]\n) {\n\t__facade_middleware__.unshift(...args.flat());\n}\n\nfunction __facade_invokeChain__(\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tdispatch: Dispatcher,\n\tmiddlewareChain: Middleware[]\n): Awaitable<Response> {\n\tconst [head, ...tail] = middlewareChain;\n\tconst middlewareCtx: MiddlewareContext = {\n\t\tdispatch,\n\t\tnext(newRequest, newEnv) {\n\t\t\treturn __facade_invokeChain__(newRequest, newEnv, ctx, dispatch, tail);\n\t\t},\n\t};\n\treturn head(request, env, ctx, middlewareCtx);\n}\n\nexport function __facade_invoke__(\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tdispatch: Dispatcher,\n\tfinalMiddleware: Middleware\n): Awaitable<Response> {\n\treturn __facade_invokeChain__(request, env, ctx, dispatch, [\n\t\t...__facade_middleware__,\n\t\tfinalMiddleware,\n\t]);\n}\n"],
  "mappings": "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",
  "names": ["checkURL", "request", "init", "url", "urls", "init_checked_fetch", "__esmMin", "target", "thisArg", "argArray", "init_wrangler_modules_watch", "__esmMin", "init_checked_fetch", "init_modules_watch_stub", "init_modules_watch_stub", "__esmMin", "init_wrangler_modules_watch", "require_Mime", "__commonJSMin", "exports", "module", "init_checked_fetch", "init_modules_watch_stub", "Mime", "i", "typeMap", "force", "type", "extensions", "t", "ext", "path", "last", "hasPath", "require_standard", "__commonJSMin", "exports", "module", "init_checked_fetch", "init_modules_watch_stub", "require_other", "__commonJSMin", "exports", "module", "init_checked_fetch", "init_modules_watch_stub", "require_mime", "__commonJSMin", "exports", "module", "init_checked_fetch", "init_modules_watch_stub", "Mime", "require_types", "__commonJSMin", "exports", "init_checked_fetch", "init_modules_watch_stub", "KVError", "message", "status", "MethodNotAllowedError", "NotFoundError", "InternalError", "require_dist", "__commonJSMin", "exports", "init_checked_fetch", "init_modules_watch_stub", "mime", "types_1", "defaultCacheControl", "parseStringAsObject", "maybeString", "getAssetFromKVDefaultOptions", "assignOptions", "options", "mapRequestToAsset", "request", "parsedUrl", "pathname", "serveSinglePageApp", "getAssetFromKV", "event", "ASSET_NAMESPACE", "ASSET_MANIFEST", "rawPathKey", "pathIsEncoded", "requestKey", "mappedRequest", "mappedRawPathKey", "pathKey", "cache", "mimeType", "shouldEdgeCache", "cacheKey", "evalCacheOpts", "formatETag", "entityId", "validatorType", "shouldSetBrowserCache", "response", "opts", "body", "etag", "ifNoneMatch", "proxyCacheStatus", "init_checked_fetch", "init_modules_watch_stub", "init_checked_fetch", "init_modules_watch_stub", "checkURL", "request", "init", "url", "urls", "init_checked_fetch", "__esm", "target", "thisArg", "argArray", "init_wrangler_modules_watch", "init_functionsRoutes_0_2765862793624314", "init_modules_watch_stub", "onRequest", "init_home", "context", "value", "generateLoginURL", "generateLogoutURL", "init_api", "redirectURLInit", "domain", "aud", "redirectURL", "hostname", "loginPathname", "searchParams", "init_login", "loginURL", "init_logout", "require_cookie", "__commonJS", "exports", "parse", "serialize", "__toString", "fieldContentRegExp", "str", "options", "obj", "opt", "dec", "decode", "index", "eqIdx", "endIdx", "key", "val", "tryDecode", "name", "enc", "encode", "maxAge", "expires", "isDate", "priority", "sameSite", "require_warnings", "alreadyWarned", "warnOnce", "condition", "message", "require_cookies", "cookie", "warnings", "createCookieFactory", "sign", "unsign", "cookieOptions", "secrets", "warnOnceAboutExpiresCookie", "cookieHeader", "parseOptions", "cookies", "decodeCookieValue", "serializeOptions", "encodeCookieValue", "isCookie", "object", "encoded", "encodeData", "secret", "unsignedValue", "decodeData", "myUnescape", "myEscape", "result", "chr", "code", "hex", "length", "part", "stringToArray", "s", "utf8", "_", "arrayToString", "a", "mergeArrays", "arrays", "out", "total", "arr", "offset", "arraysEqual", "b", "i", "init_utils", "coerce", "jsmemcmp", "buf1", "pos1", "buf2", "pos2", "len", "fn1", "fn2", "createOccurenceTable", "table", "MATCH", "StreamSearch", "ReadableStreamSearch", "EOQ", "QueueableStreamSearch", "init_search", "needle", "chunk", "pos", "tokens", "allTokens", "tail", "data", "bufPos", "ch", "bytesToCutOff", "_readableStream", "reader", "chunks", "resolve", "src_exports", "__export", "iterateMultipart", "streamMultipart", "parseContentDisposition", "header", "parts", "kv", "parsePartHeaders", "lines", "entries", "disposition", "line", "colon", "readHeaderLines", "it", "firstChunk", "lastTokenWasMatch", "headerLines", "crlfSearch", "CRLF", "dash", "token", "isMatch", "mergeArrays2", "body", "boundary", "feedChunk", "trailingCRLF", "nextToken", "done", "nextChunk", "bufferedChunks", "init_src", "require_formData", "multipartParser", "__toCommonJS", "composeUploadHandlers", "handlers", "handler", "parseMultipartFormData", "uploadHandler", "contentType", "type", "formData", "Action", "PopStateEventType", "createMemoryHistory", "initialEntries", "initialIndex", "v5Compat", "map", "entry", "createMemoryLocation", "state", "undefined", "clampIndex", "action", "Pop", "listener", "n", "Math", "min", "max", "getCurrentLocation", "to", "location", "createLocation", "pathname", "warning", "charAt", "JSON", "stringify", "createHref", "createPath", "createURL", "URL", "encodeLocation", "path", "parsePath", "search", "hash", "push", "Push", "nextLocation", "splice", "delta", "replace", "Replace", "go", "nextIndex", "listen", "fn", "createBrowserHistory", "createBrowserLocation", "window", "globalHistory", "usr", "createBrowserHref", "getUrlBasedHistory", "createHashHistory", "createHashLocation", "substr", "startsWith", "createHashHref", "base", "document", "querySelector", "href", "getAttribute", "hashIndex", "indexOf", "slice", "validateHashLocation", "invariant", "Error", "cond", "console", "warn", "createKey", "random", "toString", "getHistoryState", "idx", "current", "_extends", "_ref", "parsedPath", "searchIndex", "getLocation", "validateLocation", "defaultView", "history", "getIndex", "replaceState", "handlePop", "historyState", "pushState", "error", "DOMException", "assign", "origin", "addEventListener", "removeEventListener", "ResultType", "immutableRouteKeys", "Set", "isIndexRoute", "route", "convertRoutesToDataRoutes", "routes", "mapRouteProperties", "parentPath", "manifest", "treePath", "id", "join", "children", "indexRoute", "pathOrLayoutRoute", "matchRoutes", "locationArg", "basename", "stripBasename", "branches", "flattenRoutes", "rankRouteBranches", "matches", "matchRouteBranch", "safelyDecodeURI", "convertRouteMatchToUiMatch", "match", "loaderData", "params", "handle", "parentsMeta", "flattenRoute", "relativePath", "meta", "caseSensitive", "childrenIndex", "joinPaths", "routesMeta", "concat", "score", "computeScore", "forEach", "_route$path", "includes", "exploded", "explodeOptionalSegments", "segments", "split", "first", "rest", "isOptional", "endsWith", "required", "restExploded", "subpath", "sort", "compareIndexes", "paramRe", "dynamicSegmentValue", "indexRouteValue", "emptySegmentValue", "staticSegmentValue", "splatPenalty", "isSplat", "initialScore", "some", "filter", "reduce", "segment", "test", "every", "branch", "matchedParams", "matchedPathname", "end", "remainingPathname", "matchPath", "Object", "pathnameBase", "normalizePathname", "generatePath", "originalPath", "prefix", "p", "String", "array", "keyMatch", "optional", "param", "pattern", "matcher", "compiledParams", "compilePath", "captureGroups", "memo", "paramName", "splatValue", "safelyDecodeURIComponent", "regexpSource", "RegExp", "decodeURI", "decodeURIComponent", "toLowerCase", "startIndex", "nextChar", "resolvePath", "fromPathname", "toPathname", "resolvePathname", "normalizeSearch", "normalizeHash", "relativeSegments", "pop", "getInvalidPathError", "char", "field", "dest", "getPathContributingMatches", "getResolveToMatches", "v7_relativeSplatPath", "pathMatches", "resolveTo", "toArg", "routePathnames", "locationPathname", "isPathRelative", "isEmptyPath", "from", "routePathnameIndex", "toSegments", "shift", "hasExplicitTrailingSlash", "hasCurrentTrailingSlash", "getToPathname", "paths", "json", "responseInit", "status", "headers", "Headers", "has", "set", "Response", "AbortedDeferredError", "DeferredData", "constructor", "pendingKeysSet", "subscribers", "deferredKeys", "Array", "isArray", "reject", "abortPromise", "Promise", "r", "controller", "AbortController", "onAbort", "unlistenAbortSignal", "signal", "acc", "_ref2", "trackPromise", "add", "promise", "race", "then", "onSettle", "catch", "defineProperty", "get", "aborted", "delete", "undefinedError", "emit", "settledKey", "subscriber", "subscribe", "cancel", "abort", "v", "k", "resolveData", "size", "unwrappedData", "_ref3", "unwrapTrackedPromise", "pendingKeys", "isTrackedPromise", "_tracked", "_error", "_data", "defer", "redirect", "redirectDocument", "response", "ErrorResponseImpl", "statusText", "internal", "isRouteErrorResponse", "validMutationMethodsArr", "validMutationMethods", "validRequestMethodsArr", "validRequestMethods", "redirectStatusCodes", "redirectPreserveMethodStatusCodes", "IDLE_NAVIGATION", "formMethod", "formAction", "formEncType", "text", "IDLE_FETCHER", "IDLE_BLOCKER", "proceed", "reset", "ABSOLUTE_URL_REGEX", "defaultMapRouteProperties", "hasErrorBoundary", "Boolean", "TRANSITIONS_STORAGE_KEY", "createRouter", "routerWindow", "isBrowser", "createElement", "isServer", "detectErrorBoundary", "dataRoutes", "inFlightDataRoutes", "future", "v7_fetcherPersist", "v7_normalizeFormMethod", "v7_partialHydration", "v7_prependBasename", "unlistenHistory", "savedScrollPositions", "getScrollRestorationKey", "getScrollPosition", "initialScrollRestored", "hydrationData", "initialMatches", "initialErrors", "getInternalRouterError", "getShortCircuitMatches", "initialized", "hasLazyRoutes", "m", "lazy", "hasLoaders", "loader", "errors", "hydrate", "router", "historyAction", "navigation", "restoreScrollPosition", "preventScrollReset", "revalidation", "actionData", "fetchers", "Map", "blockers", "pendingAction", "HistoryAction", "pendingPreventScrollReset", "pendingNavigationController", "pendingViewTransitionEnabled", "appliedViewTransitions", "removePageHideEventListener", "isUninterruptedRevalidation", "isRevalidationRequired", "cancelledDeferredRoutes", "cancelledFetcherLoads", "fetchControllers", "incrementingLoadId", "pendingNavigationLoadId", "fetchReloadIds", "fetchRedirectIds", "fetchLoadMatches", "activeFetchers", "deletedFetchers", "activeDeferreds", "blockerFunctions", "ignoreNextHistoryUpdate", "initialize", "blockerKey", "shouldBlockNavigation", "currentLocation", "updateBlocker", "updateState", "startNavigation", "restoreAppliedTransitions", "_saveAppliedTransitions", "persistAppliedTransitions", "initialHydration", "dispose", "clear", "deleteFetcher", "deleteBlocker", "newState", "opts", "completedFetchers", "deletedFetchersKeys", "fetcher", "unstable_viewTransitionOpts", "viewTransitionOpts", "unstable_flushSync", "flushSync", "completeNavigation", "_temp", "_location$state", "_location$state2", "isActionReload", "isMutationMethod", "_isRedirect", "keys", "mergeLoaderData", "priorPaths", "toPaths", "getSavedScrollPosition", "navigate", "normalizedPath", "normalizeTo", "fromRouteId", "relative", "submission", "normalizeNavigateOptions", "userReplace", "pendingError", "enableViewTransition", "unstable_viewTransition", "revalidate", "interruptActiveLoads", "startUninterruptedRevalidation", "overrideNavigation", "saveScrollPosition", "routesToUse", "loadingNavigation", "notFoundMatches", "cancelActiveDeferreds", "isHashChangeOnly", "createClientSideRequest", "pendingActionData", "findNearestBoundary", "actionOutput", "handleAction", "shortCircuited", "pendingActionError", "getLoadingNavigation", "Request", "handleLoaders", "fetcherSubmission", "getSubmittingNavigation", "actionMatch", "getTargetMatch", "method", "routeId", "callLoaderOrAction", "isRedirectResult", "startRedirectNavigation", "isErrorResult", "boundaryMatch", "isDeferredResult", "activeSubmission", "getSubmissionFromNavigation", "matchesToLoad", "revalidatingFetchers", "getMatchesToLoad", "updatedFetchers", "markFetchRedirectsDone", "rf", "revalidatingFetcher", "getLoadingFetcher", "abortFetcher", "abortPendingFetchRevalidations", "f", "results", "loaderResults", "fetcherResults", "callLoadersAndMaybeResolveData", "findRedirect", "fetcherKey", "processLoaderData", "deferredData", "didAbortFetchLoads", "abortStaleFetchLoads", "shouldUpdateFetchers", "fetch", "setFetcherError", "handleFetcherAction", "handleFetcherLoader", "requestMatches", "existingFetcher", "updateFetcherState", "getSubmittingFetcher", "abortController", "fetchRequest", "originatingLoadId", "actionResult", "getDoneFetcher", "revalidationRequest", "loadId", "loadFetcher", "staleKey", "doneFetcher", "resolveDeferredData", "_temp2", "redirectLocation", "isDocumentReload", "reloadDocument", "redirectHistoryAction", "currentMatches", "fetchersToLoad", "all", "resolveDeferredResults", "getFetcher", "deleteFetcherAndUpdateState", "count", "markFetchersDone", "doneKeys", "landedId", "yeetedKeys", "getBlocker", "blocker", "newBlocker", "blockerFunction", "predicate", "cancelledRouteIds", "dfd", "enableScrollRestoration", "positions", "getPosition", "getKey", "y", "getScrollKey", "_internalSetRoutes", "newRoutes", "_internalFetchControllers", "_internalActiveDeferreds", "UNSAFE_DEFERRED_SYMBOL", "Symbol", "createStaticHandler", "query", "_temp3", "requestContext", "isValidMethod", "methodNotAllowedMatches", "statusCode", "loaderHeaders", "actionHeaders", "queryImpl", "isResponse", "queryRoute", "_temp4", "find", "values", "_result$activeDeferre", "routeMatch", "submit", "loadRouteData", "e", "isQueryRouteResponse", "isRedirectResponse", "isRouteRequest", "isStaticRequest", "Location", "loaderRequest", "getLoaderMatchesUntilBoundary", "processRouteLoaderData", "executedLoaders", "fromEntries", "getStaticContextFromError", "_deepestRenderedBoundaryId", "isSubmissionNavigation", "prependBasename", "contextualMatches", "activeRouteMatch", "hasNakedIndexQuery", "normalizeFormMethod", "isFetcher", "getInvalidBodyError", "rawFormMethod", "toUpperCase", "stripHashFromPath", "FormData", "URLSearchParams", "convertFormDataToSearchParams", "convertSearchParamsToFormData", "append", "boundaryId", "boundaryMatches", "findIndex", "isInitialLoad", "currentUrl", "nextUrl", "navigationMatches", "isNewLoader", "currentRouteMatch", "nextRouteMatch", "shouldRevalidateLoader", "currentParams", "nextParams", "defaultShouldRevalidate", "isNewRouteInstance", "fetcherMatches", "fetcherMatch", "shouldRevalidate", "currentLoaderData", "currentMatch", "isNew", "isMissingData", "currentPath", "loaderMatch", "arg", "routeChoice", "loadLazyRouteModule", "lazyRoute", "routeToUpdate", "routeUpdates", "lazyRouteProperty", "isPropertyStaticallyDefined", "resultType", "onReject", "runHandler", "handlerError", "protocol", "isSameBasename", "isDeferredData", "_result$init", "_result$init2", "deferred", "foundError", "newLoaderData", "mergedLoaderData", "hasOwnProperty", "reverse", "_temp5", "errorMessage", "signals", "isRevalidatingLoader", "unwrap", "getAll", "_window", "transitions", "sessionPositions", "sessionStorage", "getItem", "setItem", "require_mode", "ServerMode", "isServerMode", "require_errors", "require_router_cjs", "mode", "sanitizeError", "serverMode", "sanitized", "sanitizeErrors", "serializeError", "serializeErrors", "serialized", "require_responses", "isRedirectStatusCode", "DEFERRED_VALUE_PLACEHOLDER_PREFIX", "createDeferredReadableStream", "encoder", "criticalData", "preresolvedKeys", "preresolvedKey", "enqueueTrackedPromise", "unsubscribe", "require_entry", "createEntryRouteModules", "require_set_cookie", "module", "defaultParseOptions", "isNonEmptyString", "parseString", "setCookieValue", "nameValuePairStr", "parsed", "parseNameValuePair", "sides", "nameValueArr", "input", "sch", "splitCookiesString", "cookiesString", "cookiesStrings", "start", "lastComma", "nextStart", "cookiesSeparatorFound", "skipWhitespace", "notSpecialChar", "require_headers", "setCookieParser", "getDocumentHeadersRR", "build", "boundaryIdx", "errorHeaders", "parentHeaders", "routeModule", "includeErrorHeaders", "includeErrorCookies", "prependCookies", "childHeaders", "parentSetCookieString", "require_invariant", "require_routeMatching", "matchServerRoutes", "require_data", "responses", "callRouteActionRR", "loadContext", "stripDataParam", "stripIndexParam", "callRouteLoaderRR", "indexValues", "indexValuesToKeep", "indexValue", "toKeep", "require_routes", "groupRoutesByParentId", "parentId", "createRoutes", "routesByParentId", "createStaticHandlerDataRoutes", "commonRoute", "args", "require_markup", "ESCAPE_LOOKUP", "ESCAPE_REGEX", "escapeHtml", "html", "require_serverHandoff", "markup", "createServerHandoffString", "serverHandoff", "require_dev", "broadcastDevReady", "logDevReady", "globalDevServerHooksKey", "setDevServerHooks", "devServerHooks", "getDevServerHooks", "require_server", "routeMatching", "dev", "derive", "mode$1", "_build$future", "routes$1", "staticHandler", "errorHandler", "createRequestHandler", "_build", "derived", "handleError", "_getDevServerHooks", "_getDevServerHooks$pr", "handleDataRequestRR", "_matches$find", "handleResourceRequestRR", "_getDevServerHooks2", "_getDevServerHooks2$g", "criticalCss", "handleDocumentRequestRR", "errorResponseToJson", "errorInstance", "err", "headers$1", "entryContext", "handleDocumentRequestFunction", "returnLastResortErrorResponse", "errorResponse", "require_sessions", "flash", "createSession", "initialData", "flashName", "isSession", "createSessionStorageFactory", "createCookie", "cookieArg", "createData", "readData", "updateData", "deleteData", "warnOnceAboutSigningSessionCookie", "session", "require_cookieStorage", "sessions", "createCookieSessionStorageFactory", "serializedCookie", "_session", "require_memoryStorage", "createMemorySessionStorageFactory", "createSessionStorage", "MaxPartSizeExceededError", "maxBytes", "require_memoryUploadHandler", "require_errors2", "createMemoryUploadHandler", "maxPartSize", "filename", "require_dist", "server", "cookieStorage", "memoryStorage", "memoryUploadHandler", "require_crypto", "signature", "signed", "byteStringToUint8Array", "usages", "byteString", "require_implementations", "serverRuntime", "crypto", "createCookieSessionStorage", "createMemorySessionStorage", "require_workersKVStorage", "implementations", "createWorkersKVSessionStorage", "randomBytes", "x", "workersKVStorage", "getSessionSecret", "env", "sessionCookie", "import_cloudflare", "getSession", "commitSession", "destroySession", "init_session", "__toESM", "require_dist2", "checkAuthentication", "authCookie", "init_checkAuthentication", "next", "init_root", "init_greet", "task", "lexer", "j", "_a", "prefixes", "defaultPattern", "escapeString", "tryConsume", "mustConsume", "nextType", "consumeText", "open", "name_1", "pattern_1", "suffix", "re", "pathToRegexp", "regexpToFunction", "flags", "regexpToRegexp", "groupsRegex", "execResult", "arrayToRegexp", "stringToRegexp", "tokensToRegexp", "strict", "_b", "_c", "_d", "_e", "delimiter", "_f", "endsWithRe", "delimiterRe", "_i", "tokens_1", "mod", "endToken", "isEndDelimited", "escapeRegex", "executeRequest", "requestPath", "routeMatcher", "mountMatcher", "matchResult", "mountMatchResult", "pages_template_worker_default", "originalRequest", "workerContext", "handlerIterator", "isFailOpen", "cloneResponse", "reduceError", "jsonError", "_ctx", "middlewareCtx", "middleware_miniflare3_json_error_default", "wrap", "envWrappers", "facade", "middleware_insertion_facade_default", "__facade_middleware__", "__facade_register__", "__facade_invokeChain__", "ctx", "dispatch", "middlewareChain", "head", "newRequest", "newEnv", "__facade_invoke__", "finalMiddleware", "__Facade_ScheduledController__", "scheduledTime", "cron", "noRetry", "#noRetry", "__facade_modules_fetch__", "getMaskedEnv", "rawEnv", "wrapFn", "registeredMiddleware", "maskHandlerEnv", "middleware", "middleware_loader_entry_default", "init_checked_fetch", "init_modules_watch_stub", "isRoutingRuleMatch", "pathname", "routingRule", "ruleRegExp", "transformRoutingRuleToRegExp", "rule", "transformedRule", "define_ROUTES_default", "routes", "pages_dev_pipeline_default", "request", "env", "context", "pathname", "exclude", "isRoutingRuleMatch", "include", "middleware_loader_entry_default", "init_checked_fetch", "init_modules_watch_stub", "reduceError", "jsonError", "request", "env", "_ctx", "middlewareCtx", "e", "error", "middleware_miniflare3_json_error_default", "wrap", "init_checked_fetch", "init_modules_watch_stub", "import_kv_asset_handler", "manifest", "spaMode", "cacheControl", "ASSET_MANIFEST", "manifest", "staticAssets", "request", "env", "_ctx", "middlewareCtx", "options", "cacheControl", "spaMode", "page", "promise", "response", "e", "middleware_serve_static_assets_default", "envWrappers", "wrap", "facade", "pages_dev_pipeline_default", "middleware_miniflare3_json_error_default", "middleware_serve_static_assets_default", "middleware_insertion_facade_default", "facade", "init_checked_fetch", "init_modules_watch_stub", "__facade_middleware__", "__facade_register__", "args", "__facade_invokeChain__", "request", "env", "ctx", "dispatch", "middlewareChain", "head", "tail", "newRequest", "newEnv", "__facade_invoke__", "finalMiddleware", "__facade_middleware__", "__Facade_ScheduledController__", "scheduledTime", "cron", "noRetry", "#noRetry", "__facade_modules_fetch__", "request", "env", "ctx", "middleware_insertion_facade_default", "getMaskedEnv", "rawEnv", "wrapFn", "registeredMiddleware", "facade", "maskHandlerEnv", "middleware", "__facade_register__", "__facade_invoke__", "type", "init", "controller", "handler", "data", "middleware_loader_entry_default"]
}
